/*
 *  This file is a part of Massively Parallel Quantum Chemistry package (v4).
 *  Copyright (C) 2017  Virginia Tech
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef SRC_MPQC_MATH_GROUPS_PETITE_LIST_H_
#define SRC_MPQC_MATH_GROUPS_PETITE_LIST_H_

#include <cstdint>
#include <map>
#include <memory>
#include <stdexcept>
#include <string>

namespace mpqc {
namespace math {

/// A helper class for symmetric tensor algebra

/// PetiteList implements auxiliary representation theory algebra needed to evaluate efficiently
/// expressions involving tensors with symmetries (permutation and otherwise).
/// The concept was introduced by Michel Dupuis and Harry King
/// (DOI 10.1002/qua.560110408).
/// @note only permutation groups are supported right now
class PetiteList {
 public:
  PetiteList() = default;
  virtual ~PetiteList() = default;

  /// permutation groups implemented by SymmPetiteList
  enum class Symmetry {
    e,      //!< identity (E)
    aa,     //!< generated by {0<->1}
    aa_bb,  //!< generated by {0<->1}, {2<->3}
    ab_ab,  //!< generated by {0<->2,1<->3}
    aa_aa   //!< generated by {0<->1}, {2<->3}, {0<->2,1<->3}
  };
  static std::map<Symmetry, std::string> symmetry_to_string;

  virtual bool is_canonical(long idx0) const = 0;
  virtual bool is_canonical(long idx0, long idx1) const = 0;
  virtual bool is_canonical(long idx0, long idx1, long idx2) const = 0;
  virtual bool is_canonical(long idx0, long idx1, long idx2,
                            long idx3) const = 0;

  virtual int64_t multiplicity(long idx0) const = 0;
  virtual int64_t multiplicity(long idx0, long idx1) const = 0;
  virtual int64_t multiplicity(long idx0, long idx1, long idx2) const = 0;
  virtual int64_t multiplicity(long idx0, long idx1, long idx2,
                               long idx3) const = 0;

  static std::shared_ptr<const PetiteList> make_trivial();
  static std::shared_ptr<const PetiteList> make(Symmetry symmetry);
};

/// converts PetiteList::Symmetry to \c std::string
/// @param symmetry a PetiteList::Symmetry object
/// @return string representation of symmetry
std::string to_string(PetiteList::Symmetry symmetry);

namespace detail {

template <PetiteList::Symmetry TC>
struct TupleCanonicalizer;

template <>
struct TupleCanonicalizer<PetiteList::Symmetry::e> {
  template <typename... Is>
  static bool is_canonical(Is... idxs) {
    return true;
  }
  template <typename... Is>
  static int64_t multiplicity(Is... idxs) {
    return 1;
  }
};

template <>
struct TupleCanonicalizer<PetiteList::Symmetry::aa> {
  template <typename I>
  static bool is_canonical(I idx0) {
    return true;
  }
  template <typename I>
  static bool is_canonical(I idx0, I idx1) {
    return idx0 >= idx1;
  }
  template <typename I>
  static bool is_canonical(I idx0, I idx1, I idx2) {
    return is_canonical(idx0, idx1);
  }
  template <typename I>
  static bool is_canonical(I idx0, I idx1, I idx2, I idx3) {
    return is_canonical(idx0, idx1);
  }
  template <typename I>
  static int64_t multiplicity(I idx0) {
    throw std::logic_error(
        "underfined TupleCanonicalizer<aa>::multiplicity()");
  }
  template <typename I>
  static int64_t multiplicity(I idx0, I idx1) {
    return (idx0 == idx1) ? 1 : 2;
  }
  template <typename I>
  static int64_t multiplicity(I idx0, I idx1, I idx2) {
    return multiplicity(idx0, idx1);
  }
  template <typename I>
  static int64_t multiplicity(I idx0, I idx1, I idx2, I idx3) {
    return multiplicity(idx0, idx1);
  }
};

template <>
struct TupleCanonicalizer<PetiteList::Symmetry::aa_aa> {
  template <typename I>
  static bool is_canonical(I idx0) {
    return true;
  }
  template <typename I>
  static bool is_canonical(I idx0, I idx1) {
    return idx0 >= idx1;
  }
  template <typename I>
  static bool is_canonical(I idx0, I idx1, I idx2) {
    return is_canonical(idx0, idx1);
  }
  template <typename I>
  static bool is_canonical(I idx0, I idx1, I idx2, I idx3) {
    if (idx0 < idx1) return false;
    if (idx2 < idx3) return false;
    if (idx0 == idx2 && idx1 < idx3) return false;
    return true;
  }
  template <typename I>
  static int64_t multiplicity(I idx0) {
    throw std::logic_error(
        "underfined TupleCanonicalizer<aaaa>::multiplicity()");
  }
  template <typename I>
  static int64_t multiplicity(I idx0, I idx1) {
    throw std::logic_error(
        "underfined TupleCanonicalizer<aaaa>::multiplicity(,)");
  }
  template <typename I>
  static int64_t multiplicity(I idx0, I idx1, I idx2) {
    throw std::logic_error(
        "underfined TupleCanonicalizer<aaaa>::multiplicity(,,)");
  }
  template <typename I>
  static int64_t multiplicity(I idx0, I idx1, I idx2, I idx3) {
    return ((idx0 == idx1) ? 1 : 2) * ((idx2 == idx3) ? 1 : 2) *
           ((idx0 == idx2 && idx1 == idx3) ? 1 : 2);
  }
};

template <>
struct TupleCanonicalizer<PetiteList::Symmetry::aa_bb> {
  template <typename I>
  static bool is_canonical(I idx0) {
    return true;
  }
  template <typename I>
  static bool is_canonical(I idx0, I idx1) {
    return idx0 >= idx1;
  }
  template <typename I>
  static bool is_canonical(I idx0, I idx1, I idx2) {
    return is_canonical(idx0, idx1);
  }
  template <typename I>
  static bool is_canonical(I idx0, I idx1, I idx2, I idx3) {
    return is_canonical(idx0, idx1) && is_canonical(idx2, idx3);
  }
  template <typename I>
  static int64_t multiplicity(I idx0) {
    throw std::logic_error(
        "undefined TupleCanonicalizer<aabb>::multiplicity()");
  }
  template <typename I>
  static int64_t multiplicity(I idx0, I idx1) {
    throw std::logic_error(
        "undefined TupleCanonicalizer<aabb>::multiplicity(,)");
  }
  template <typename I>
  static int64_t multiplicity(I idx0, I idx1, I idx2) {
    throw std::logic_error(
        "undefined TupleCanonicalizer<aabb>::multiplicity(,,)");
  }
  template <typename I>
  static int64_t multiplicity(I idx0, I idx1, I idx2, I idx3) {
    return ((idx0 == idx1) ? 1 : 2) * ((idx2 == idx3) ? 1 : 2);
  }
};

template <>
struct TupleCanonicalizer<PetiteList::Symmetry::ab_ab> {
  template <typename I>
  static bool is_canonical(I idx0) {
    return true;
  }
  template <typename I>
  static bool is_canonical(I idx0, I idx1) {
    return true;
  }
  template <typename I>
  static bool is_canonical(I idx0, I idx1, I idx2) {
    return idx0 >= idx2;
  }
  template <typename I>
  static bool is_canonical(I idx0, I idx1, I idx2, I idx3) {
    return idx0 > idx2 || (idx0 == idx2 && idx1 >= idx3);
  }
  template <typename I>
  static int64_t multiplicity(I idx0) {
    throw std::logic_error(
        "undefined TupleCanonicalizer<abab>::multiplicity()");
  }
  template <typename I>
  static int64_t multiplicity(I idx0, I idx1) {
    throw std::logic_error(
        "undefined TupleCanonicalizer<abab>::multiplicity(,)");
  }
  template <typename I>
  static int64_t multiplicity(I idx0, I idx1, I idx2) {
    throw std::logic_error(
        "undefined TupleCanonicalizer<abab>::multiplicity(,,)");
  }
  template <typename I>
  static int64_t multiplicity(I idx0, I idx1, I idx2, I idx3) {
    return (idx0 != idx2) ? 2 : ((idx1 == idx3) ? 1 : 2);
  }
};

}  // namespace detail

template <PetiteList::Symmetry TC = PetiteList::Symmetry::e>
class SymmPetiteList : public PetiteList {
 public:
  SymmPetiteList() = default;
  ~SymmPetiteList() = default;

  bool is_canonical(long idx0) const override {
    return detail::TupleCanonicalizer<TC>::is_canonical(idx0);
  }
  bool is_canonical(long idx0, long idx1) const override {
    return detail::TupleCanonicalizer<TC>::is_canonical(idx0, idx1);
  }
  bool is_canonical(long idx0, long idx1, long idx2) const override {
    return detail::TupleCanonicalizer<TC>::is_canonical(idx0, idx1, idx2);
  }
  bool is_canonical(long idx0, long idx1, long idx2, long idx3) const override {
    return detail::TupleCanonicalizer<TC>::is_canonical(idx0, idx1, idx2, idx3);
  }
  int64_t multiplicity(long idx0) const override {
    return detail::TupleCanonicalizer<TC>::multiplicity(idx0);
  }
  int64_t multiplicity(long idx0, long idx1) const override {
    return detail::TupleCanonicalizer<TC>::multiplicity(idx0, idx1);
  }
  int64_t multiplicity(long idx0, long idx1, long idx2) const override {
    return detail::TupleCanonicalizer<TC>::multiplicity(idx0, idx1, idx2);
  }
  int64_t multiplicity(long idx0, long idx1, long idx2,
                       long idx3) const override {
    return detail::TupleCanonicalizer<TC>::multiplicity(idx0, idx1, idx2, idx3);
  }
};

}  // namespace math
}  // namespace mpqc

#endif  // SRC_MPQC_MATH_GROUPS_PETITE_LIST_H_
