@c -*-texinfo-*-
@node The KeyVal Library, The Matrix Library, The State Library, Top
@chapter The KeyVal Library
@cindex keyword/value associations

The @code{KeyVal} class provides a means for users to associate keywords
with values.  The package is flexible enough to allow complex structures
and arrays to be read from an input file.  Classes which are descendants
of @code{DescribedClass} (@pxref{The DescribedClass Class}) and have a
@code{KeyVal} constructor can be completely specified by a
@code{KeyVal} object and initialized with a single C++ statement.

@menu
* The KeyVal Class:: The abstract base class for keyword/value associations.
* The AssignedKeyVal Class:: A KeyVal that allows assigning values to keywords.
* The StringKeyVal Class:: A KeyVal for data represented as strings.
* The AggregateKeyVal Class:: Combining multiple KeyVal objects into one.
* The PrefixKeyVal Class:: Automatically apply a prefix to all keywords.
* The ParsedKeyVal Class:: A KeyVal implementation for human readable input.
@end menu

@c -------------------------------------------------------------------------

@node The KeyVal Class, The AssignedKeyVal Class, The KeyVal Library, The KeyVal Library
@section The KeyVal Class
@clindex KeyVal
@c texi2html: do not split

@include KeyVal.texi

@menu
* KeyVal Interface:: The interface to the KeyVal class.
* KeyVal Errors:: Errors codes used by the KeyVal class.
@end menu

@c .........................................................................

@node KeyVal Interface, KeyVal Errors, The KeyVal Class, The KeyVal Class
@subsection Interface

The public interface to @code{KeyVal} is:
@include KeyVal.pub.texi

Each of the members taking a keyword for an argument can have up to two
more integers following the keyword in the
argument list.  These are intepreted as array indices and result in
segments being appending to the keyword.  The segments correspond to the
decimal representation of the indices.  These members can also take
just one or two integer arguments, with the keyword omitted.

The protected interface is:
@include KeyVal.pro.texi

@c .........................................................................

@node KeyVal Errors,  , KeyVal Interface, The KeyVal Class
@subsection Error Conditions

Errors are specified by the @code{KeyVal}@code{::}@code{KeyValError}
enum.  The possibilities for @code{KeyValError} are:
@table @code
@item OK
No problem.
@item HasNoValue
The keyword has no value.
@item WrongType
The datum is not of the appropiate type.
@item UnknownKeyword
The keyword was not found.
@item OperationFailed
The requested operation failed.
@end table

@c -------------------------------------------------------------------------

@node The AssignedKeyVal Class, The StringKeyVal Class, The KeyVal Class, The KeyVal Library
@section The AssignedKeyVal Class
@clindex AssignedKeyVal
@c texi2html: do not split

The @code{AssignedKeyVal} class is a specialization of @code{KeyVal} that
associates keywords with values using its @code{assign} members:

@table @code
@item void assign(const char*, const RefKeyValValue&);
@item void assign(const char*, double);
@item void assignboolean(const char*, int);
@item void assign(const char*, float);
@item void assign(const char*, char);
@item void assign(const char*, int);
@item void assign(const char*, const char*);
@item void assign(const char*, RefDescribedClass&);
@end table

@c -------------------------------------------------------------------------

@node The StringKeyVal Class, The AggregateKeyVal Class, The AssignedKeyVal Class, The KeyVal Library
@section The StringKeyVal Class
@clindex StringKeyVal
@c texi2html: do not split

The @code{StringKeyVal} class is an abstract specialization of
@code{KeyVal} in which all data is ultimately represented as
strings.
Its public members are:

@table @code
@item virtual const char* stringvalue(const char *@var{keyword}) = 0
  Returns the string value of @var{keyword}.
@item virtual const char* classname(const char* @var{keyword})
  Returns the name of the exact class of the object associated with
  @var{keyword}.
@item virtual const char* truekeyword(const char* key)
  Returns a string which is the actual keyword that to which @var{key} refers.
  If no sort of variable substitution takes place the return value is key the
  same as @var{key}.  (This is needed to make multiple references to the
  same object work in derived class that have a reference mechanism.)
@item RefKeyValValue key_value(const char*)
@item int key_exists(const char*)
  These are @code{KeyVal} members that are overridden to make use of
  the string data returned by @code{stringvalue}, @code{classname},
  and @code{truekeyword}.
@end table

@c -------------------------------------------------------------------------

@node The AggregateKeyVal Class, The PrefixKeyVal Class, The StringKeyVal Class, The KeyVal Library
@section The AggregateKeyVal Class
@clindex AggregateKeyVal
@c texi2html: do not split

The @code{AggregateKeyVal} class is a concrete specialization of
@code{KeyVal} which searches through several @code{KeyVal} objects
until a value is found for a keyword.

It overrides some of the members of @code{KeyVal} and provides the
following constructors:

@table @code
@item AggregateKeyVal(KeyVal&)
@item AggregateKeyVal(KeyVal&,KeyVal&)
@item AggregateKeyVal(KeyVal&,KeyVal&,KeyVal&)
@item AggregateKeyVal(KeyVal&,KeyVal&,KeyVal&,KeyVal&)
  The constructors take one to four arguments of type @code{KeyVal}.
  Keyword values are searched for in the order given in argument list.
@end table

@c -------------------------------------------------------------------------

@node The PrefixKeyVal Class, The ParsedKeyVal Class, The AggregateKeyVal Class, The KeyVal Library
@section The PrefixKeyVal Class
@clindex PrefixKeyVal
@c texi2html: do not split

The @code{PrefixKeyVal} class is a concrete specialization of
@code{KeyVal}.  When keywords are looked using a @code{PrefixKeyVal} a
new keyword is formed by appending the original keyword to a prefix and
then looking up the value in another @code{KeyVal} object.  For example,
suppose the @code{"z"} keyword was sought in a @code{PrefixKeyVal}
object having the prefix @code{"x"}.  The @code{PrefixKeyVal} object
would forward a lookup of @code{"x:z"} to another @code{KeyVal} object.
If keywords are sought that are anchored to the root of the keyword
hierarchy by an initial @code{':'} character, then the prefix is not
used.

@code{PrefixKeyVal} overrides some of the members of @code{KeyVal} and
provides the following constructors:

@table @code
@item PrefixKeyVal(const char* @var{prefix},KeyVal&);
@item PrefixKeyVal(const char* @var{prefix},KeyVal&,int);
@item PrefixKeyVal(const char* @var{prefix},KeyVal&,int,int);
@item PrefixKeyVal(const char* @var{prefix},KeyVal&,int,int,int);
@item PrefixKeyVal(const char* @var{prefix},KeyVal&,int,int,int,int);
These constructors specify the prefix to be used and a @code{KeyVal} object
to which lookup requests are forwarded.  The optional integer arguments are
used to append decimal numbers to @var{prefix}.
@end table

@c -------------------------------------------------------------------------

@node The ParsedKeyVal Class,  , The PrefixKeyVal Class, The KeyVal Library
@section The ParsedKeyVal Class
@clindex ParsedKeyVal
@cindex reading input
@c texi2html: do not split

The @code{ParsedKeyVal} class inherits from @code{KeyVal}.  It permits
users to specify keyword/value associations in a text file.

@menu
* ParsedKeyVal Interface:: The interface to ParsedKeyVal.
* ParsedKeyVal Assignment:: Making keyword/value associations.
* ParsedKeyVal Keyword Grouping:: A shorthand for writing similar keywords.
* ParsedKeyVal Arrays:: A shorthand for expressing arrays.
* ParsedKeyVal Tables:: A shorthand for expressing tables.
* ParsedKeyVal Value Substitution:: A method for substituting values.
* ParsedKeyVal Expression Evaluation:: Simple mathematical expressions.
* ParsedKeyVal Objects:: Objects can be created by giving a class name.
@end menu

@c .........................................................................

@node ParsedKeyVal Interface, ParsedKeyVal Assignment, The ParsedKeyVal Class, The ParsedKeyVal Class
@subsection Interface

These member are provided in addition to those provided in addition
to those member of @code{KeyVal} that are overridden.

@table @code
@item ParsedKeyVal(char* @var{filename})
Construct a @code{ParsedKeyVal} and use the @var{filename} as the name of
the input file.
@item void input(char* @var{filename})
Append additional input files.
@end table

@c .........................................................................

@node ParsedKeyVal Assignment, ParsedKeyVal Keyword Grouping, ParsedKeyVal Interface, The ParsedKeyVal Class
@subsection Assignment

As an example of the use of @code{ParsedKeyVal}, consider the following input:
@example
x_coordinate = 1.0
y_coordinate = 2.0
x_coordinate = 3.0
@end example
Two assignements will be made.  The keyword @code{x_coordinate} will be
associated with the value @code{1.0} and the keyword @code{y_coordinate}
will be assigned to @code{2.0}.  The third line in the above input
will have no effect since @code{x_coordinate} was assigned previously.

@c .........................................................................

@node ParsedKeyVal Keyword Grouping, ParsedKeyVal Arrays, ParsedKeyVal Assignment, The ParsedKeyVal Class
@subsection Keyword Grouping

Lets imagine that we have a program which needs to read in the
characteristics of animals.  There are lots of animals so it might be
nice to catagorize them by their family.  Here is a sample format for
such an input file:
@example
reptile: (
  alligator: (
    legs = 4
    extinct = no
    )
  python: (
    legs = 0
    extinct = no
    )
  )
bird: (
  owl: (
    flys = yes
    extinct = no
    )
  )
@end example

This sample illustrates the use of @var{keyword} @code{=} @var{value}
assignments and the keyword grouping operators @code{(} and @code{)}.
The keywords in this example are
@example
reptile:alligator:legs
reptile:alligator:extinct
reptile:alligator:legs
reptile:python:size
reptile:python:extinct
bird:owl:flys
bird:owl:extinct
@end example

The @code{:}'s occuring in these keywords break the keywords into
smaller logical units called keyword segments.  The sole purpose of this
is to allow persons writing input files to group the input into easy to
read sections.  In the above example there are two main sections, the
reptile section and the bird section.  The reptile section takes the
form @code{reptile} @code{:} @code{(} @var{keyword} @code{=} @var{value}
assignments @code{)}.  Each of the keywords found between the
parentheses has the @code{reptile:} prefix attached to it.  Within each
of these sections further keyword groupings can be used, as many and as
deeply nested as the user wants.

Keyword grouping is also useful when you need many different programs to
read from the same input file.  Each program can be assigned its own
unique section.

@c .........................................................................

@node ParsedKeyVal Arrays, ParsedKeyVal Tables, ParsedKeyVal Keyword Grouping, The ParsedKeyVal Class
@subsection Array Construction

A method of specifying arrays of data would be useful.  One way to
do this would be as follows:
@example
array: (
  0 = 5.4
  1 = 8.9
  2 = 3.7
  )
@end example
The numbers @code{0}, @code{1}, and @code{2} in this example are keyword
segments which serve as indices of @code{array}.  However, this syntax
is somewhat awkward and array construction operators have been provided
to simplify the input for this case.  The following input is equivalent
to the above input:
@example
array = [ 5.4 8.9 3.7 ]
@end example

More complex arrays than this can be imagined.  Suppose an array of
complex numbers is needed.  For example the input
@example
carray: (
  0: ( r = 1.0  i = 0.0 )
  1: ( r = 0.0  i = 1.0 )
  )
@end example
could be written as
@example
carray: [
  (r = 1.0 i = 0.0)
  (r = 0.0 i = 1.0)
  ]
@end example
which looks a bit nicer than the example without array construction
operators.

Furthermore, the array construction operators can be nested in about
every imaginable way.  This allows multidimensional arrays of
complicated data to be represented.

It would be nice to just extend an array that is already defined.  This
feature has not been implemented; however, user demand for it might
result in its implementation.  The operators reserved for this purpose
are @code{+[} and @code{]}.

@c .........................................................................

@node ParsedKeyVal Tables, ParsedKeyVal Value Substitution, ParsedKeyVal Arrays, The ParsedKeyVal Class
@subsection Table Construction

Although the array contstruction operators will suit most requirements
for enumerated lists of data, in some cases the input can still look
ugly.  This can, in some cases, be fixed with the table construction
operators, @code{@{} and @code{@}}.

Suppose a few long vectors of the same length are needed and the data in
the @code{i}th element of each array is related or somehow belong
together.  If the arrays are so long that the width of a page is
exceeded, then data that should be seen next to each other are no longer
adjacent.  The way this problem can be fixed is to arrange the data
vertically side by side rather than horizontally.  The table
construction operators allows the user to achieve this in a very simple
manner.
@example
balls: (
  color    = [  red      blue     red   ]
  diameter = [   12       14       11   ]
  material = [  rubber  vinyl   plastic ]
  bouces   = [  yes      no       no    ]
  coordinate = [[ 0.0  0.0  0.0]
                [ 1.0  2.0 -1.0]
                [ 1.0 -1.0  1.0]]
  )
@end example
can be written
@example
balls: (
  @{ color diameter material bounces     coordinate@}
                  
  @{  red     12    rubber    yes     [ 0.0  0.0  0.0]
     blue    14    vinyl     no      [ 1.0  2.0 -1.0]
     red     11    plastic   no      [ 1.0 -1.0  1.0] @}
  )
@end example
The length and width of the table can be anything the user desires.

@c .........................................................................

@node ParsedKeyVal Value Substitution, ParsedKeyVal Expression Evaluation, ParsedKeyVal Tables, The ParsedKeyVal Class
@subsection Value Substitution

Occasionally, a user may need to repeat some value several times in an
input file.  If the value must be changed, it would be nice to only
change the value in one place.  The value substitution feature of
@code{ParsedKeyVal} always the user to do this.  Any place a value can
occur the user can place a @code{$}.  Following this a keyword must be
given.  This keyword must have been assigned before the attempt is made
to use its value in a value substitution.

Here is an example illustrating most of the variable substition
features:
@example
default:linewidth = 130
testsub: (
  ke: (
    ke_1 = 1
    ke_2 = 2
    ke_3: (
      ke_31 = 31
      ke_32 = 32
      )
    )
  kx = $ke
  r1 = 3.0
  r2 = $r1
  linewidth = $:default:linewidth
  )
@end example
is the same as specifying
@example
testsub: (
  ke: (
    ke_1 = 1
    ke_3: (
      ke_31 = 31
      ke_32 = 32
      )
    ke_2 = 2
    )
  linewidth = 130
  r2 = 3.0
  r1 = 3.0
  kx: (
    ke_1 = 1
    ke_2 = 2
    ke_3: (
      ke_31 = 31
      ke_32 = 32
      )
    )
  )
@end example
It can be seen from this that value substitution can result in entire
keyword segment hierarchies being copied, as well as simple
substitutions.


@c .........................................................................

@node ParsedKeyVal Expression Evaluation, ParsedKeyVal Objects, ParsedKeyVal Value Substitution, The ParsedKeyVal Class
@subsection Expression Evaluation

It is nice to be able to multiply numbers together directly in the input
file.  For example, you may need to change the units on a number and
want to see where exactly the number is coming from.  This motivated the
development of an expression evaluation facility in the
@code{ParsedKeyVal} package.  This facility is still under development,
but some primitive expressions can be evaluated in the current release.

Suppose your program requires several parameters @code{x1}, @code{x2},
and @code{x3}.  Furthermore, suppose that their ratios remain fixed for
all the runs of the program that you desire.  It would be best to
specify some scale factor in the input that would be the only thing that
has to be changed from run to run.  If you don't want to or cannot
modify the program, then this can be done directly with
@code{ParsedKeyVal} as follows
@example
scale = 1.234
x1 = ( $:scale *  1.2 )
x2 = ( $:scale *  9.2 )
x3 = ( $:scale * -2.0 )
@end example
So we see that to the right of the ``@code{=}'' the characters
``@code{(}'' and ``@code{)}'' are the expression construction operators.
This is in contrast to their function when they are to the left of the
``@code{=}'', where they are the keyword grouping operators.

Currently, the expression must be binary and the data is all converted
to double.  If you use the expression construction operators to produce
data that the program expects to be integer, you will certainly get the
wrong answers (unless the desired value happens to be zero).

@c .........................................................................

@node ParsedKeyVal Objects,  , ParsedKeyVal Expression Evaluation, The ParsedKeyVal Class
@subsection Objects

An instance of an object can be can be specified by surrounding it's
classname with the ``@code{<}'' and ``@code{>}'' operators immediately
after the keyword naming the data.  The object must be of a type that
inherits of @code{DescribedClass} and it must have a @code{KeyVal&}
constructor.

A pointer to a single object can be read with multiple keywords by
using value substitution (@pxref{ParsedKeyVal Value Substitution}).
This is accomplished by holding references to all objects once they are
read in.  This means that the user must let the @code{Ref} smart pointer
classes used by all @code{DescribedClass}'s manage the memory for
objects read in by @code{ParsedKeyVal}.  Thus, storage for all read
objects will not be freed until after the @code{ParsedKeyVal} instance
that read the class is deleted.

For example consider the following linked list class:

@example
class A: public DescribedClass @{
  // members needed for described class omitted
  public:
   A(KeyVal&);
   RefA next;
@};
DescribedClass_REF_dec(A);

A::A(KeyVal&keyval)
@{
  next = keyval.describedclassvalue("next");
@}

class B: public A @{
  // members needed for described class omitted
  int bdata;
  public:
   B(KeyVal&);
@};

B::B(KeyVal&keyval):
  A(keyval)
@{
  bdata = keyval.intvalue("bdata");
@}

main()
@{
  RefKeyVal keyval = new ParsedKeyVal("input");
  RefA a1 = keyval->describedclassvalue("a1");
  RefA a2 = keyval->describedclassvalue("a2");
  keyval = new ParsedKeyVal("input");
  RefA a3 = keyval->describedclassvalue("a1");
@}
@end example

This program would construct a linked list from the input below:

@example
a1<A>: (
    next<A>: (
        next<B>: (
            bdata = 4
            next<A>:()
            )
        )
    )
a2 = $:a
@end example

The @code{a1} list would contain two @code{A} objects followed by a
@code{B} object followed by another @code{A} object.  The @code{a2} list
refers to exactly the same object as @code{a1} (not a copy of
@code{a1}).  The @code{a3} list refers to a different list than
@code{a1}, because it is assigned from a new @code{ParsedKeyVal} which
doesn't retain any information read in by the old @code{ParsedKeyVal}
object.
