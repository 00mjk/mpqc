
/** \page develop Developing Code Using SC

In addition to the executables, the Scientific Computing toolkit libraries
and include files can be installed on your machine.  This is described in
the \ref compile section of this manual.

The <tt>sc-config</tt> program can be use to obtain the compilers, compiler
options, and libraries needed to use the SC toolkit from your program.
This utility is discussed below, along with how the SC toolkit must be
initialized in your <tt>main</tt> subroutine.

<ul>
  <li> \ref scconfig
  <li> \ref scinit
</ul>

\subsection scconfig The sc-config Program

The sc-config program returns information about how SC was compiled
and installed.  The following information is available:

<dl>
     <dt><tt>--prefix</tt><dd> The directory where SC is installed.
     <dt><tt>--version</tt><dd> The version of SC.
     <dt><tt>--libs</tt><dd> The libraries and library paths needed to link.
     <dt><tt>--cppflags</tt><dd> The include directories.
     <dt><tt>--cc</tt><dd> The C compiler.
     <dt><tt>--cflags</tt><dd> The C compiler flags.
     <dt><tt>--cxx</tt><dd> The C++ compiler.
     <dt><tt>--cxxflags</tt><dd> The C++ compiler flags.
     <dt><tt>--f77</tt><dd> The FORTRAN 77 compiler.
     <dt><tt>--f77flags</tt><dd> The FORTRAN 77 compiler flags.
</dl>

To use the sc-config program to link your executable to SC, use a
Makefile for GNU make similar to the following:

<pre>
SCCONFIG = /usr/local/mpqc/current/bin/sc-config
CXX := $(shell $(SCCONFIG) --cxx)
CXXFLAGS := $(shell $(SCCONFIG) --cxxflags)
CPPFLAGS := $(shell $(SCCONFIG) --cppflags)
LIBS := $(shell $(SCCONFIG) --libs)

myprog: myprog.o
	$(CXX) $(CXXFLAGS) -o $@ $^ $(LIBS)
</pre>

\subsection scinit Initializing SC

First the execution environment must be initialized using
the ExEnv init member.

<pre>
  ExEnv::init(argc, argv);
</pre>

By default, all output will go to the console stream, cout.  To change
this, use the following code:

<pre>
  ostream *outstream = new ofstream(outputfilename);
  ExEnv::set_out(outstream);
</pre>

MPI is allowed wait until MPI_Init is called to fill in argc and argv, so
you may have to call MPI_Init before you even know that we ready to
construct MPIMessageGrp.  So if an MPIMessageGrp is needed, it is up to the
developer to call MPI_Init to get the argument list for certain MPI
implementations.

<pre>
  MPI_Init(&argc, &argv);
</pre>

When files are read and written, an extension is added to a
basename to construct the file name.  The default is "SC".
To use another basename, make the following call, where
<tt>basename</tt> is a <tt>const char *</tt>:

<pre>
  SCFormIO::set_default_basename(basename);
</pre>

If your job might run in parallel, then make the following
call or the nodes will print redundant information.  The
<tt>myproc</tt> argument is the rank of the called node.

<pre>
  SCFormIO::init_mp(myproc);
</pre>

This segment of code sets up an object object to provide multi-threading:

<pre>
  RefThreadGrp thread = ThreadGrp::initial_threadgrp(argc, argv);
  ThreadGrp::set_default_threadgrp(thread);
  if (thread.nonnull())
    ThreadGrp::set_default_threadgrp(thread);
  else
    thread = ThreadGrp::get_default_threadgrp();
</pre>

This segment of code sets up the message passing object:

<pre>
  RefMessageGrp grp = MessageGrp::initial_messagegrp(argc, argv);
  if (grp.nonnull())
    MessageGrp::set_default_messagegrp(grp);
  else
    grp = MessageGrp::get_default_messagegrp();
</pre>


*/
