
/** \page develop Developing Code Using SC

In addition to the executables, the Scientific Computing toolkit libraries
and include files can be installed on your machine.  This is described in
the \ref compile section of this manual.

The <tt>sc-config</tt> program can be use to obtain the compilers, compiler
options, and libraries needed to use the SC toolkit from your program.
This utility is discussed below, along with how the SC toolkit must be
initialized in your <tt>main</tt> subroutine.

<ul>
  <li> \ref scconfig
  <li> \ref scinit
  <li> \ref devsamp
</ul>

\section scconfig The sc-config Program

The sc-config program returns information about how SC was compiled
and installed.  See \ref sc-config for more information.                        

\section scinit Initializing SC

First the execution environment must be initialized using
the ExEnv init member.

<pre>
  ExEnv::init(argc, argv);
</pre>

By default, all output will go to the console stream, cout.  To change
this, use the following code:

<pre>
  ostream *outstream = new ofstream(outputfilename);
  ExEnv::set_out(outstream);
</pre>

MPI is allowed wait until MPI_Init is called to fill in argc and argv, so
you may have to call MPI_Init before you even know that we ready to
construct MPIMessageGrp.  So if an MPIMessageGrp is needed, it is up to the
developer to call MPI_Init to get the argument list for certain MPI
implementations.

<pre>
  MPI_Init(&argc, &argv);
</pre>

When files are read and written, an extension is added to a
basename to construct the file name.  The default is "SC".
To use another basename, make the following call, where
<tt>basename</tt> is a <tt>const char *</tt>:

<pre>
  SCFormIO::set_default_basename(basename);
</pre>

If your job might run in parallel, then make the following
call or the nodes will print redundant information.  The
<tt>myproc</tt> argument is the rank of the called node.

<pre>
  SCFormIO::init_mp(myproc);
</pre>

This segment of code sets up an object object to provide multi-threading:

<pre>
  RefThreadGrp thread = ThreadGrp::initial_threadgrp(argc, argv);
  ThreadGrp::set_default_threadgrp(thread);
  if (thread.nonnull())
    ThreadGrp::set_default_threadgrp(thread);
  else
    thread = ThreadGrp::get_default_threadgrp();
</pre>

This segment of code sets up the message passing object:

<pre>
  RefMessageGrp grp = MessageGrp::initial_messagegrp(argc, argv);
  if (grp.nonnull())
    MessageGrp::set_default_messagegrp(grp);
  else
    grp = MessageGrp::get_default_messagegrp();
</pre>

\section devsamp MP2 Implementation Example

This section illustrates how to add a new method a new method to MPQC.

\subsection devsampsrc MP2 Implementation Example: Source

This example code illustrates a complete MP2 energy
implementation using the SC Toolkit.  First an MP2 class is
declared and the necesary base class member functions are
provided.  Next a ClassDesc is defined.  Finally, the member
functions are defined.

Note that no main routine is provided.  This is because this file
is designed to be used to extend the functionality of the mpqc
executable.  To generate a new mpqc executable with the new class
available for use, see the \ref devsampmak section.

\include mp2.cc

\subsection devsampmak MP2 Implementation Example: Makefile

This example Makefile demonstrates how to link in a new class to
form a new mpqc executable, here named mp2.  The code is given in
the \ref devsampsrc section.  The \ref scconfig "sc-config command"
is used to obtain information about how the SC toolkit
was compiled and installed.  The library specified with -lmpqc
provides the main routine from mpqc.

\include Makefile

\subsection devsampinp MP2 Implementation Example: Input

This input file can be used with the program illustrated in
the \ref devsampsrc section.  It will compute the MP2 energy
using the new MP2 class.  Note that only the
\ref mpqcoo "object-oriented input format" can be used with
user provided classes.

\include mp2.in

*/
