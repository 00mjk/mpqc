@c -*-texinfo-*-
@node The Ref Library, The Class Library, Top, Top
@chapter The Reference Library
@cindex pointers
@cindex smart pointers
@cindex reference counting
@cindex memory management

It is fairly easy in C++ to create a pointer to an object that actually
references invalid memory.  One common way to do this is to create an
object with @code{new} and store that object's pointer.  Then the
pointer is given to another object's member function as an argument
which keeps a copy of the pointer for future use.  After the member
function returns, the routine that originally created the object
@code{delete}'s it, not knowing that another object has since created a
reference to the object.  The result of using the @code{delete}'ed
object is unpredictable and would likely be a program crash.  It is up
to the programmer to provide the logic necessary to avoid this problem.
The programmer must also deal with the problem of calling to
@code{delete} operator on any @code{new}'ed memory when it is no longer
referenced.

Reference counting is one technique that can be applied to automate
memory management.  In this approach, a count of how many pointers point
to an object is attached to that object.  This count is managed by a
smart pointer class which mimics the behavior of C++ pointers by
providing @code{operator->()}.  This class has a pointer to the
reference counted object and increments the reference count of objects
that are assigned to it while decrementing the counts of the object that
are displaced.  The smart pointer class automatically @code{delete}'s
the object when its reference count drops to zero.

A deficiency of this method is that unreferenced circular lists
are not automatically deleted.  Circular list implementors must
provide a mechanism to detect when the list is dereferenced and
then break the list's circularity to let the automated reference
mechanism finish the work.

The reference library provides @code{cpp} macros and a base class that
can be used to maintain reference counts to objects.  For an
object to be reference counted its class must inherit from
the @code{VRefCount} class.  This adds @code{sizeof(int)} bytes
of overhead per object and makes the destructor virtual (so a vtable
will be added to objects of the class, if there wasn't already a virtual
member in the class).  The reference counts are maintained by
classes created with the @code{cpp} macros @code{REF_dec} and
@code{REF_def}.  These macros take the name of the reference counted
class as the only argument and declare the interface
and define the members of the new Ref class.

@menu
* The VRefCount Class:: The base class for reference counted objects.
* The Ref Macros:: Declare and define reference counted objects.
* Customizing Ref:: Control the degree of error checking.
* A Ref Example:: An example of using the Ref Library.
@end menu

@c -------------------------------------------------------------------------

@node The VRefCount Class, The Ref Macros, The Ref Library, The Ref Library
@section The VRefCount Class
@clindex VRefCount
@c texi2html: do not split

@code{VRefCount} is the base class for all reference counted objects.  If
multiple inheritance is used, @code{VRefCount} must be virtually inherited
from, otherwise references to invalid memory will likely result.

Reference counting information is usually maintained be classes created
by the @code{REF_dec} and @code{REF_def} macros
(@pxref{The Ref Macros}), however this mechanism can be
supplemented or replaced by using the following public interface to
@code{VRefCount}:

@table @code
@item int reference()
Increment the reference count and return the new count.
@item int dereference()
Decrement the reference count and return the new count.
@item int nreference()
Return the reference count.
@item void unmanage()
Turn off the reference counting mechanism for this object.  The
value returned by @code{nreference()} will always be @samp{1} after this is
called.
@item int managed()
Return @samp{1} if the object is managed.  Otherwise return @samp{0}.
@end table

The @code{unmanage()} member is only needed for special cases where
memory management must be turned off.  For example, if a reference
counted object is created on the stack, memory management
mechanisms based on reference counting must be prohibited from deleting it.
The @code{unmanage()} member accomplishes this, but a better solution
would be to allocate the object on the heap with @code{new} and let
a class declared using the @code{REF_dec} macro manage the memory for
the object.

When using a debugger to look at reference counted objects the count is
maintained in the @code{_reference_count_} member.  However, this member
is encoded so that memory overwrites can be sometimes detected.  Thus,
interpretation of @code{_reference_count_} is not straightforward and
will change as the implementation of @code{VRefCount} becomes more
sophisticated.

@c -------------------------------------------------------------------------

@node The Ref Macros, Customizing Ref, The VRefCount Class, The Ref Library
@section The Reference Macros
@mcindex REF_dec
@mcindex REF_def
@c texi2html: do not split

The reference macros are used to declare and define classes for smart
pointers that automatically manage memory for reference counted objects.
The @code{REF_dec} macro takes a class name as an argument and
constructs a new class declaration which is formed by appending the
class name to @code{Ref}.  This macro would usually be invoked in the
same header file that gives the declaration for that reference counted
class.  The implementation of the members for this class are generated
by using the @code{REF_def} which also takes the class name as the
argument.  This should be given in one of the source files relating to
that class and should not be placed in the header file.  The
@code{REF_dec} macro must be followed by a semicolon.
@footnote{Templates would have been much cleaner than macros; however,
until problems with templates in C++ compilers have been resolved,
macros will have to do.  However, template versions of these macros
(@code{template <class T> Ref}) do exist and are provided by
@code{<util/container/ref.h>}.}

For a class @code{T}, the class generated by @code{REF_dec(T)} would
have the following public interface:

@table @code
@item T* operator->() const
  Returns the reference counted object.  The behaviour is undefined if
  the object is null.
@item T* pointer() const
  Returns the reference counted object.
@item operator T*() const
  Returns the reference counted object.  This member is disabled for certain
  buggy C++ compilers.  The @code{pointer()} member should be used instead.
@item T& operator *() const
  Returns a C++ reference to the reference counted object.  The behaviour
  is undefined if the object is null.
@item RefT ()
  Create a reference to a null object.
@item RefT (T*@var{a})
  Create a reference to the object @var{a}.
@item RefT (const RefT &@var{a})
  Create a reference to the object referred to by @var{a}.
@item ~RefT ()
  Delete this reference to the object.  Decrement the object's reference
  count and delete the object if the count is zero.
@item int null() const
  Return @samp{1} if this is a reference to a null object.  Otherwise
  return @samp{0}.
@item int nonnull() const
  Return @code{!null()}.
@item RefT& operator=(const RefT & @var{c})
  Refer to the same object to which @var{c}.
@item RefT& operator=(T* @var{cr})
  Refer to @var{cr}.
@item void assign_pointer(T* @var{cr})
  Refer to @var{cr}.
@item int operator==(const RefT &@var{a}) const
@item int operator!=(const RefT &@var{a}) const
@item int operator==(const T * @var{a}) const
@item int operator!=(const T * @var{a}) const
@item int operator>=(const RefT &@var{a}) const
@item int operator<=(const RefT &@var{a}) const
@item int operator>(const RefT &@var{a}) const
@item int operator<(const RefT &@var{a}) const
  These comparison operations compare the pointer addresses of the
  contained objects.
@item void clear()
  Refer to the null object.
@item void unmanage()
  If this is called, the object's reference could will always be nonzero.
  This effectively removes the object from the reference library's
  memory management mechanism.
@item int manage() const
  Returns 1 if this object is being managed by the Ref memory management
  mechanism.  This is always the case, unless @code{unmanage()} has been
  called.
@end table

Several of these operations can cause a reference to an object to be
replaced by a reference to a different object.  If a reference to a
nonnull object is eliminated, the object's reference count is
decremented and the object is deleted if the reference count becomes
zero.

@c -------------------------------------------------------------------------

@node Customizing Ref, A Ref Example, The Ref Macros, The Ref Library
@section Customizing the Reference Counting Package
@c texi2html: do not split

  The behaviour of the package can be modified with the following five
macros, each of which should be undefined, 0, or 1:

@table @code
@item REF_CHECK_STACK
  If this is 1, referenced objects are checked to see if they
  reside on the stack, in which case storage for the object is not managed,
  if management is enabled.
@item REF_CHECKSUM
  If this is 1, checksums of the reference count are kept
  and checked to see if an object has been overwritten.
@item REF_MANAGE
  If this is 1, the unmanage member is enabled.
@item REF_CHECK_MAX_NREF
  If this is 1, the reference count is checked before
  it is incremented to make sure it isn't too big.
@item REF_CHECK_MIN_NREF
  If this is 1, the reference count is checked before
  it is decremented to make sure it isn't already zero.
@end table

If a macro is undefined, then the behaviour is architecture
dependent---usually, the macro will be set to 1 in this case.
For maximum efficiency and for normal operation after the program is
debugged, compile with all of the above macros defined to zero.
This can also be done by defining @code{REF_OPTIMIZE}.

  An include file can be used to set these options as well.  This has
the advantage that dependency checking will force an automatic
recompile of all affected files if the options change.  The file
@code{<refconfig.h>} will be included if @code{REF_CONFIG} is defined.

  Note that all source code that uses references must be compiled with
the same value for @code{REF_CHECKSUM} and @code{REF_MANAGE}.
Changing these can change the storage layout and the interpretation of
the reference count data.

@c -------------------------------------------------------------------------

@node A Ref Example, , Customizing Ref, The Ref Library
@section A Reference Example
@c texi2html: do not split

This is a simple example of how to manage memory with reference
counts.

@example

#include <util/container/ref.h>

class A: virtual public VRefCount @{
@};
REF_dec(A);

class B: public A @{
@};
REF_dec(B);

REF_def(A);
REF_def(B);

int
main()
@{
  RefA a1(new A);
  RefA a2;

  // Create another reference to the A object pointed to by a1.
  a2 = a1;

  // Make a2 refer to a new A object.
  a2 = new A;

  // a2 was the only reference to the second A object, so setting
  // a2 to the null object will cause the second A object to be
  // deleted.
  a2 = 0;

  RefB b(new B);

  // RefA and RefB are not related by inheritance as are A and B,
  // so `a1 = b' will fail and the following must be used.  This
  // will also cause the first A object to be deleted.
  a1 = b.pointer();

  // The B object will be deleted here because all of the references
  // to it go out of scope and destroyed.
  return 0;
@}

@end example
