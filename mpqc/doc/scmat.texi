@c -*-texinfo-*-
@node The Matrix Library, The Symmetry Library, The KeyVal Library, Top
@chapter The Matrix Library
@cindex matrix operations

The scientific computing matrix library (SCMAT) is designed around a set
of matrix abstractions that permit very general matrix implementations.
This flexibility is needed to support diverse computing environments.
For example, this library must support, at a minimum: simple matrices
that provide efficient matrix computations in a uniprocessor
environment, clusters of processors with enough memory to store all
matrices connected by a relatively slow network (workstations on an
LAN), clusters of processors with enough memory to store all matrices
and a fast interconnect network (a massively parallel machine such as
the Intel Paragon), and clusters of machines that don't have enough
memory to hold entire matrices (only a fast interconnect network would
work well in this case).

The design of SCMAT differs from other object-oriented matrix packages
in two important ways.  First, the matrix classes are abstract base
classes.  No storage layout is defined and virtual function calls must
be used to access individual matrix elements.  This would have a
negative performance impact if users needed to frequently access matrix
elements.  The interface to the matrix classes is hopefully rich enough
to avoid individual matrix element access for any computationally
significant task.  The second major difference is that symmetric
matrices do not inherit from matrices, etc.  The SCMAT user must know
whether a matrix is symmetric at all places it is used if any
performance gain, by virtue of symmetry, is expected.

The primary abstract classes are @code{SCMatrix}, @code{SymmSCMatrix},
@code{DiagSCMatrix}, and @code{SCVector}.  These represent matrices,
symmetric matrices, diagonal matrices, and vectors, respectively.
Several other abstract classes exist in SCMAT.  @code{SCDimension} is
a matrix or vector dimension and can used to create new
matrix or vector object.  @code{SCMatrixKit} is used to create
instances of the above types.  Each of these classes inherits
from @code{SavableState} (@pxref{The State Library})
which inherits from @code{DescribedClass} (@pxref{The Class Library})
which inherits from @code{VRefCount} (@pxref{The Ref Library}).

These abstract classes are specialized into sets of classes.
For example, the locally stored matrix implementation specializes
the abstract classes to @code{LocalSCMatrix}, @code{LocalSymmSCMatrix},
@code{LocalDiagSCMatrix}, @code{LocalSCVector}, @code{LocalSCDimension},
and @code{LocalSCMatrixKit}.  These specializations are all designed
to work with each other.  The @code{LocalSCMatrixKit} can be used to
create @code{LocalSCDimension}'s as well as the other local matrix
and vector types.  The @code{LocalSCMatrix} matrix multiply member
requires that all matrices involved in the multiply are
@code{LocalSCMatrix}'s, otherwise a run-time type violation will
occur.  Similar constraints are placed on other matrix operations
to make the operations as efficient as possible.

Matrix operations can require the creation of matrices not identical to
the original.  It may be desirable in some cases for a routine which has
no knowledge of the matrix implementations to create these matrices.  To
accommodate this, a matrix can be created using members of
@code{SCMatrixKit} or @code{SCDimension}.  Given an @code{SCDimension}
object, a @code{SymmSCMatrix} implementation or a @code{DiagSCMatrix}
implementation object can be created.  Two @code{SCDimension} objects of
identical exact type can be used to create an @code{SCMatrix} (if two
@code{SCDimension} objects of different exact types are used a run time
error will result).  Thus, all matrix implementations must determine the
storage layout of matrices from the one or two @code{SCDimension} used
to create it.

The abstract matrix classes and their derivations are usually not
directly used by SCMAT users.  The most convenient classes to use are
the smart pointer classes @code{RefSCMatrix}, @code{RefSymmSCMatrix},
@code{RefDiagSCMatrix}, @code{RefSCDimension}, and
@code{RefSCMatrixKit}.  These automatically delete matrix objects when
they are no longer needed.  This is through a reference count mechanism
that is supported by the @code{VRefCount} base class.  The smart pointer
classes also have matrix operations such as @code{operator *()},
@code{operator -()}, and @code{operator +()} defined as members for
convenience.  These forward the operations to the contained matrix
object.  The smart pointer classes also simplify creation of matrices by
provided constructors that take @code{RefSCDimension} arguments.  These
initialize the smart pointer to contain a new matrix with a
specialization consistent to that of the @code{RefSCDimension}.
Matrix operations not provided by the smart pointer classes but
present as member in the abstract classes can be accessed with
@code{operator->()}.

If a needed matrix operation is missing, mechanisms exist to add more
general operations.  Operations which only depend on individual elements
of matrices can be provided by user provided specializations of the
@code{SCElementOp} class.  Sometimes we need operations on matrices with
identical dimensions that examine each element in one matrix along with
the corresponding element from the other matrix.  This is accomplished
with @code{SCElementOp2} for two matrices and with @code{SCElementOp3}
for three.

Other features of SCMAT include run-time type facilities and
persistence.  Castdown operations (type conversions from less to more
derived objects) and other run-time type information are provided by the
@code{DescribedClass} base class.  Persistence is provided by
the @code{SavableState} base clase.

The following include files are provided by the matrix library:

@table @file
@item matrix.h
Usually, this is the only include file needed by users of matrices.  Its
main feature is that it declares reference counting pointers to matrix
implementations.

If dimension for a matrix must be created, or a member specific to an
implementation is needed, then that implementation's header file must be
included.

@item elemop.h
This is the next most useful include file.  It defines useful
@code{SCElementOp}, @code{SCElementOp2}, and @code{SCElementOp3}
specializations.

@item abstract.h
This include file contains the declarations for abstract classes that
users do not usually need to see.  These include @code{SCDimension},
@code{SCMatrix}, @code{SymmSCMatrix}, @code{DiagSCMatrix},
@code{SCMatrixKit}.  This file is currently include by @file{matrix.h}
however this may change.

@item block.h
This file declares @code{SCMatrixBlock} and specializations.  It
only need be include by users implementing new @code{SCElementOp}
specializations.

@item blkiter.h
This include file declares the implementations of
@code{SCMatrixBlockIter}.  It only need be include by users implementing
new @code{SCElementOp} specializations.

@item vector3.h
This declares @code{SCVector3} a fast vector of length three.

@item matrix3.h
This declares @code{SCMatrix3}, a fast matrix of dimension three by
three.  It includes @file{vector3.h}.

@item local.h
This include file is the matrix implementation for locally stored
matrices.  These are suitable for use in a uniprocessor environment.
The @code{LocalSCMatrixKit} is the default matrix implementation
returned by the static member @code{SCMatrixKit::default_matrixkit}.
This file usually doesn't need to be included.
@end table

@menu
* The Matrix Reference Classes::  Matrices can be accessed through references.
* The Matrix Classes:: The abstract bases for all matrix implementations.
* The Block Classes::  All matrices ultimately store their data in blocks.
* The Block Iterator Classes::  Iterators provide access to block types.
* The Element Operation Classes:: Classes that process matrix elements.
* The Matrix Element Classes:: These handle element references.
* The Local Matrix Classes::  A locally stored matrix implementation.
* The Replicated Matrix Classes::  A matrix with data replicated on each node.

@end menu

@c ===========================================================================

@node The Matrix Reference Classes, The Matrix Classes, The Matrix Library, The Matrix Library
@section The Matrix Reference Classes

Routines that do not need to use the matrix implementation specific
members or dimension constructors can do all of their work in terms of
references to matrices.  This eliminates dependencies on implementation
header files and helps speed compile time.  The referencing
functionality is essentially the same as that provided by
@file{util/container/ref.h}, however, members have been added to forward
operations to the @code{SCMatrix} pointer.

These provide routines not in the @code{SCMatrix} hierarchy, as well.
For example, the C++ operators @code{*}, @code{-}, and @code{+} are
provided to return a reference to a newly created matrix.  This isn't
necessarily the most efficient way to do things, but it is quite
convenient and useful when efficiency isn't an issue.

@menu
* The RefSCMatrixKit Class:: References to matrix kits.
* The RefSCDimension Class:: References to dimensions.
* The RefSCVector Class:: References to vectors.
* The RefSCMatrix Class:: References to rectangular matrices.
* The RefSymmSCMatrix Class:: References to symmetric matrices.
* The RefDiagSCMatrix Class:: References to diagonal matrices.
@end menu

@c ---------------------------------------------------------------------------

@node The RefSCMatrixKit Class, The RefSCDimension Class, The Matrix Reference Classes, The Matrix Reference Classes
@subsection The RefSCMatrixKit Class
@clindex RefSCMatrixKit

The @code{RefSCMatrixKit} is a @code{SavableState} reference without
any special modifications.

@c ---------------------------------------------------------------------------

@node The RefSCDimension Class, The RefSCVector Class, The RefSCMatrixKit Class, The Matrix Reference Classes
@subsection The RefSCDimension Class
@clindex RefSCDimension

@include RefSCDimension.texi

The public interface to @code{RefSCVector} is
@include RefSCDimension.pub.texi

@c ---------------------------------------------------------------------------

@node The RefSCVector Class, The RefSCMatrix Class, The RefSCDimension Class, The Matrix Reference Classes
@subsection The RefSCVector Class
@clindex RefSCVector

@include RefSCVector.texi

The public interface to @code{RefSCVector} is
@include RefSCVector.pub.texi

@c ---------------------------------------------------------------------------

@node The RefSCMatrix Class, The RefSymmSCMatrix Class, The RefSCVector Class, The Matrix Reference Classes
@subsection The RefSCMatrix Class
@clindex RefSCMatrix

@include RefSCMatrix.texi

The public interface to @code{RefSCMatrix} is
@include RefSCMatrix.pub.texi

@c ---------------------------------------------------------------------------

@node The RefSymmSCMatrix Class, The RefDiagSCMatrix Class, The RefSCMatrix Class, The Matrix Reference Classes
@subsection The RefSymmSCMatrix Class
@clindex RefSymmSCMatrix

@include RefSymmSCMatrix.texi

The public interface to @code{RefSymmSCMatrix} is
@include RefSymmSCMatrix.pub.texi

@c ---------------------------------------------------------------------------

@node The RefDiagSCMatrix Class,  , The RefSymmSCMatrix Class, The Matrix Reference Classes
@subsection The RefDiagSCMatrix Class
@clindex RefDiagSCMatrix

@include RefDiagSCMatrix.texi

The public interface to @code{RefDiagSCMatrix} is
@include RefDiagSCMatrix.pub.texi

@c ===========================================================================

@node The Matrix Classes, The Block Classes, The Matrix Reference Classes, The Matrix Library
@section The Matrix Classes

The @code{SCVector}, @code{SCMatrix}, @code{SymmSCMatrix}, and
@code{DiagSCMatrix} are the abstract classes that all matrix
implementations derive from.

@menu
* The SCMatrixKit Class:: Creates dimensions, matrices and vectors.
* The SCDimension Class:: Determines storage layout of matrices.
* The SCVector Class:: The abstract base for all vectors.
* The SCMatrix Class:: The abstract base for all rectangular matrices.
* The SymmSCMatrix Class:: The abstract base for all symmetric matrices.
* The DiagSCMatrix Class:: The abstract base for all diagonal matrices.
@end menu

@c ---------------------------------------------------------------------------

@node The SCMatrixKit Class, The SCDimension Class, The Matrix Classes, The Matrix Classes
@subsection The SCMatrixKit Class
@clindex SCMatrixKit

@include SCMatrixKit.texi

The public interface to @code{SCMatrixKit} is
@include SCMatrixKit.pub.texi

@c ---------------------------------------------------------------------------

@node The SCDimension Class, The SCVector Class, The SCMatrixKit Class, The Matrix Classes
@subsection The SCDimension Class
@clindex SCDimension

@include SCDimension.texi

The public interface to @code{SCDimension} is
@include SCDimension.pub.texi

@c ---------------------------------------------------------------------------

@node The SCVector Class, The SCMatrix Class, The SCDimension Class, The Matrix Classes
@subsection The SCVector Class
@clindex SCVector

@include SCVector.texi

The public interface to @code{SCVector} is
@include SCVector.pub.texi

@c ---------------------------------------------------------------------------

@node The SCMatrix Class, The SymmSCMatrix Class, The SCVector Class, The Matrix Classes
@subsection The SCMatrix Class
@clindex SCMatrix

@include SCMatrix.texi

The public interface to @code{SCMatrix} is
@include SCMatrix.pub.texi

@c ---------------------------------------------------------------------------

@node The SymmSCMatrix Class, The DiagSCMatrix Class, The SCMatrix Class, The Matrix Classes
@subsection The SymmSCMatrix Class
@clindex SymmSCMatrix

@include SymmSCMatrix.texi

The public interface to @code{SCMatrix} is
@include SymmSCMatrix.pub.texi

@c ---------------------------------------------------------------------------

@node The DiagSCMatrix Class,  , The SymmSCMatrix Class, The Matrix Classes
@subsection The DiagSCMatrix Class
@clindex DiagSCMatrix

@include DiagSCMatrix.texi

The public interface to @code{SCMatrix} is
@include DiagSCMatrix.pub.texi

@c ===========================================================================

@node The Block Classes, The Block Iterator Classes, The Matrix Classes, The Matrix Library
@section The Block Classes

@menu
* The SCMatrixBlock Class:: The abstract base class for all matrix blocks.
* The SCMatrixRectBlock Class:: A rectangular subblock of a matrix.
* The SCMatrixLTriBlock Class:: A lower triangular subblock of a matrix.
* The SCMatrixDiagBlock Class:: A diagonal subblock of a matrix.
* The SCVectorSimpleBlock Class:: A chunk of a vector.
@end menu

@c ---------------------------------------------------------------------------

@node The SCMatrixBlock Class, The SCMatrixRectBlock Class, The Block Classes, The Block Classes
@subsection The SCMatrixBlock Class
@clindex SCMatrixBlock

The @code{SCMatrixBlock} class is the parent of the block classes.  All
of its descendents allow public access to data members, in order to
allow efficient access to data.  Descendents may specify index ranges
with a @var{start} and @var{end} members.  @var{start} members give the
first valid index and the last valid index is one less than the
corresponding @var{end} member.  @code{SCMatrixBlock} is a descendent of
@code{SavableState} (@pxref{The SavableState Class}).  Usually,
reference counted instances of @code{SCMatrixBlock} are used with the
@code{RefSCMatrixBlock}.

@c ---------------------------------------------------------------------------

@node The SCMatrixRectBlock Class, The SCMatrixLTriBlock Class, The SCMatrixBlock Class, The Block Classes
@subsection The SCMatrixRectBlock Class
@clindex SCMatrixRectBlock
@clindex RefSCMatrixRectBlock

The @code{SCMatrixRectBlock} represents a rectangular block of a matrix.
It is a descendant of @code{SCMatrixBlock} (@pxref{The SCMatrixBlock Class}).

The memory layout for @code{SCMatrixRectBlock} is given by:
@example
int block_index = 0;
for (int i=istart;i<iend;i++) @{
  for (int j=jstart;j<jend;j++) @{
    data_index++;
    @}
  @}
@end example

Some useful members of @code{SCMatrixRectBlock} are:
@table @code
@item SCMatrixRectBlock(int @var{istart}, int @var{iend}, int @var{jstart}, int @var{jend})
This initializes all of the data members.
@item SCMatrixRectBlock(StateIn& @var{si})
This constructs an object using state information in @var{si}.
@item virtual ~SCMatrixRectBlock()
This deallocates @code{data}.
@item void save_data_state(StateOut& so)
This stores the state of the object to @code{so}.
@item int istart
The first row index.
@item int jstart
The first column index.
@item int iend
The last row index plus one.
@item int jend
The last column index plus one.
@item double* data
A pointer to the data.  The CTOR and DTOR handle this storage.  The
user should not change or @code{delete} this pointer.
@end table

@c ---------------------------------------------------------------------------

@node The SCMatrixLTriBlock Class, The SCMatrixDiagBlock Class, The SCMatrixRectBlock Class, The Block Classes
@subsection The SCMatrixLTriBlock Class
@clindex SCMatrixLTriBlock
@clindex RefSCMatrixLTriBlock

This class hold a lower triangular block of a matrix.  Symmetric matrices
can be implemented using these.
This class inherits from @code{SCMatrixBlock}
(@pxref{The SCMatrixBlock Class}).

The memory layout for @code{SCMatrixLTriBlock} is as follows:
@example
int block_index = 0;
for (int i=start;i<end;i++) @{
  for (int j=start;j<=i;j++) @{
    block_index++;
    @}
  @}
@end example

The members are:
@table @code
@item SCMatrixLTriBlock(int @var{istart}, int @var{iend})
This initializes all of the data members.
@item SCMatrixLTriBlock(StateIn& @var{si})
This constructs an object using state information in @var{si}.
@item virtual ~SCMatrixLTriBlock()
This deallocates @code{data}.
@item void save_data_state(StateOut& @var{so})
This stores the state of the object to @var{so}.
@item int start
The first row/column index.
@item int end
The last row/column index plus one.
@item double* data
A pointer to the data.  The CTOR and DTOR handle this storage.  The
user should not change or @code{delete} this pointer.
@end table

@c ---------------------------------------------------------------------------

@node The SCMatrixDiagBlock Class, The SCVectorSimpleBlock Class, The SCMatrixLTriBlock Class, The Block Classes
@subsection The SCMatrixDiagBlock Class
@clindex SCMatrixDiagBlock
@clindex RefSCMatrixDiagBlock
This class holds a block of elements from a diagonal matrix.
It inherits from @code{SCMatrixBlock}
(@pxref{The SCMatrixBlock Class}).

The memory layout for @code{SCMatrixDiagBlock} is as follows:
@example
int block_index = 0;
for (i=istart,j=jstart;i<iend;i++,j++) @{
  block_index++;
  @}
@end example

The members are:
@table @code
@item SCMatrixDiagBlock(int @var{istart}, int @var{iend})
This initializes all of the data members.
@item SCMatrixDiagBlock(StateIn& @var{si})
This constructs an object using state information in @var{si}.
@item virtual ~SCMatrixDiagBlock()
This deallocates @code{data}.
@item void save_data_state(StateOut& @var{so})
This stores the state of the object to @var{so}.
@item int start
The first row/column index.
@item int end
The last row/column index plus one.
@item double* data
A pointer to the data.  The CTOR and DTOR handle this storage.  The
user should not change or @code{delete} this pointer.
@end table

@c ---------------------------------------------------------------------------

@node The SCVectorSimpleBlock Class,  , The SCMatrixDiagBlock Class, The Block Classes
@subsection The SCVectorSimpleBlock Class
@clindex SCVectorSimpleBlock
@clindex RefSCVectorSimpleBlock
This class holds a contiguous elements of a vector.
It inherits from @code{SCMatrixBlock}
(@pxref{The SCMatrixBlock Class}).

The memory layout for @code{SCVectorSimpleBlock} is as follows:
@example
int block_index = 0;
for (i=istart;i<iend;i++) @{
  block_index++;
  @}
@end example

The members are:
@table @code
@item SCVectorSimpleBlock(int @var{istart}, int @var{iend})
This initializes all of the data members.
@item SCVectorSimpleBlock(StateIn& @var{si})
This constructs an object using state information in @var{si}.
@item virtual ~SCVectorSimpleBlock()
This deallocates @code{data}.
@item void save_data_state(StateOut& @var{so})
This stores the state of the object to @var{so}.
@item int start
The first row/column index.
@item int end
The last row/column index plus one.
@item double* data
A pointer to the data.  The CTOR and DTOR handle this storage.  The
user should not change or @code{delete} this pointer.
@end table

@c ===========================================================================

@node The Block Iterator Classes, The Element Operation Classes, The Block Classes, The Matrix Library
@section The Block Iterator Classes

Block iterators can be used to determine which matrix elements
are in a block when the exact type of a block is not known.

@code{SCMatrixBlockIter} is the abstract base class for all matrix
and vector block iterators.  It has the following members:
@clindex SCMatrixBlockIter
@table @code
@item SCMatrixBlockIter()
@item virtual ~SCMatrixBlockIter()
@item virtual int i() = 0
@item virtual int j() = 0
@item virtual void set(double) = 0
@item virtual double get() = 0
@item virtual operator int() = 0
@item virtual void operator++() = 0
Only the prefix @code{++} is provided.
@item virtual void reset() = 0
@end table

This abstract base class is implemented by @code{SCMatrixDiagBlockIter},
@code{SCMatrixLTriBlockIter}, @code{SCVectorSimpleBlockIter}, and
@code{SCVectorRectBlockIter}.

@clindex SCMatrixDiagBlockIter
@clindex SCMatrixLTriBlockIter
@clindex SCVectorSimpleBlockIter
@clindex SCVectorRectBlockIter

@c ===========================================================================

@node The Element Operation Classes, The Matrix Element Classes, The Block Iterator Classes, The Matrix Library
@section The Element Operation Classes

@menu
* The SCElementOp Class:: The abstract base class for all element operations.
* The SCRectElementOp Class:: The base class for operations on SCMatrix.
* The SCDiagElementOp Class:: The base class for operations on SCDiagMatrix.
* The SCSymmElementOp Class:: The base class for operations on SCSymmMatrix.
* The SCVectorElementOp Class:: The base class for operations on SCVector.
* The SCElementScale Class:: Scale the elements.
* The SCElementMaxAbs Class:: Find the maximum absolute value of the elements.
* The SCElementAssign Class:: Assign a value to the elements.
* The SCElementShiftDiagonal Class:: Shift the diagonal elements.
@end menu

@c ---------------------------------------------------------------------------

@node The SCElementOp Class, The SCRectElementOp Class, The Element Operation Classes, The Element Operation Classes
@subsection The SCElementOp Class
@clindex SCElementOp
@clindex RefSCElementOp

@code{SCElementOp} is an abstract class that performs operations on the elements
of a matrix or vector.

@table @code
@item SCElementOp()
@item virtual ~SCElementOp()
@item virtual int has_collect()
@itemx virtual void collect(RefSCElementOp&)
If duplicates of @code{SCElementOp} are made then if @code{has_collect}
returns true then collect is called in such a way that each duplicated
@code{SCElementOp} is the argument of @code{collect} once.  The default
return value of @code{has_collect} is 0 and @code{collect}'s default
action is do nothing.
@item virtual void process(SCMatrixBlockIter&) = 0
@item virtual void process(SCMatrixRectBlock*)
@itemx virtual void process(SCMatrixLTriBlock*)
@itemx virtual void process(SCMatrixDiagBlock*)
@end table

@c ---------------------------------------------------------------------------

@node The SCRectElementOp Class, The SCDiagElementOp Class, The SCElementOp Class, The Element Operation Classes
@subsection The SCRectElementOp Class
@clindex SCRectElementOp
@clindex RefSCRectElementOp

@code{SCRectElementOp} is an abstract class that performs operations on the
elements of a rectangular matrix @code{SCMatrix}.  It gives nothing new to
@code{SCElementOp}; its main purpose is type checking.

@c ---------------------------------------------------------------------------

@node The SCDiagElementOp Class, The SCSymmElementOp Class, The SCRectElementOp Class, The Element Operation Classes
@subsection The SCDiagElementOp Class
@clindex SCDiagElementOp
@clindex RefSCDiagElementOp

@code{SCDiagElementOp} is an abstract class that performs operations on the
elements of a diagonal matrix @code{DiagSCMatrix}.  It gives nothing new to
@code{SCElementOp}; its main purpose is type checking.

@c ---------------------------------------------------------------------------

@node The SCSymmElementOp Class, The SCVectorElementOp Class, The SCDiagElementOp Class, The Element Operation Classes
@subsection The SCSymmElementOp Class
@clindex SCSymmElementOp
@clindex RefSCSymmElementOp

@code{SCSymmElementOp} is an abstract class that performs operations on the
elements of a diagonal matrix @code{SymmSCMatrix}.  It gives nothing new to
@code{SCElementOp}; its main purpose is type checking.

@c ---------------------------------------------------------------------------

@node The SCVectorElementOp Class, The SCElementScale Class, The SCSymmElementOp Class, The Element Operation Classes
@subsection The SCVectorElementOp Class
@clindex SCVectorElementOp
@clindex RefSCVectorElementOp

@code{SCVectorElementOp} is an abstract class that performs operations
on the elements of a vector @code{SCVector}.  It gives nothing new to
@code{SCElementOp}; its main purpose is type checking.

@c ---------------------------------------------------------------------------

@node The SCElementScale Class, The SCElementMaxAbs Class, The SCVectorElementOp Class, The Element Operation Classes
@subsection The SCElementScale Class
@clindex SCElementScale
@clindex RefSCElementScale

This multiplies all of the elements in the matrix by the constant given
to the constructor.  It works for all element operations.  Note that the
@code{virtual} inheritance isn't needed for ANSI C++, but the GNU
compiler 2.5.something breaks if it isn't used.  This is perhaps an
abuse of multiple inheritance.  The alternative is four
@code{SCElementScale} classes: @code{SCDiagElementScale}, and so on.
This would be more aesthetic, but I'm too lazy.

@c ---------------------------------------------------------------------------

@node The SCElementMaxAbs Class, The SCElementAssign Class, The SCElementScale Class, The Element Operation Classes
@subsection The SCElementMaxAbs Class
@clindex SCElementMaxAbs
@clindex RefSCElementMaxAbs

This finds the maximum absolute value over all of the elements in the
matrix.  The member @code{result} returns this value.

@c ---------------------------------------------------------------------------

@node The SCElementAssign Class, The SCElementShiftDiagonal Class, The SCElementMaxAbs Class, The Element Operation Classes
@subsection The SCElementAssign Class
@clindex SCElementAssign
@clindex RefSCElementAssign

This assigns the constant given in the constructor to all of the elements
in a matrix.

@c ---------------------------------------------------------------------------

@node The SCElementShiftDiagonal Class,  , The SCElementAssign Class, The Element Operation Classes
@subsection The SCElementShiftDiagonal Class
@clindex SCElementShiftDiagonal
@clindex RefSCElementShiftDiagonal

This is adds the constant given in the constructor to the
diagonal elements of the matrix.

@c ===========================================================================

@node The Matrix Element Classes, The Local Matrix Classes, The Element Operation Classes, The Matrix Library
@section The Matrix Element Classes

It is common for matrix packages to return a reference to a matrix
element @code{double& operator()(int,int)}.  This behavior doesn't leave
matrix packages much flexibility---matrix element must always be at some
fixed position in memory.  However, the syntax of @code{a(i,j) = f(i,j)}
is appealing and for the matrix library to be simply dropped in as a
replacement for others this functionality is needed.  This is the role
of @code{SCMatrixdouble} and @code{SCVectordouble}.

The former being the vector element access return type and the latter
being the matrix element access return type.

Use of @code{SCVectordouble} and @code{SCMatrixdouble} should be
avoided when efficiency is a concern.

@c ===========================================================================

@node The Local Matrix Classes, The Replicated Matrix Classes, The Matrix Element Classes, The Matrix Library
@section The Local Matrix Classes
@clindex LocalSCMatrixKit
@clindex LocalSCDimension
@clindex LocalSCVector
@clindex LocalSCMatrix
@clindex LocalSymmSCMatrix
@clindex LocalDiagSCMatrix
@clindex RefLocalSCDimension

The classes @code{LocalSCMatrixKit}, @code{LocalSCDimension},
@code{LocalSCMatrix}, @code{LocalSymmSCMatrix}, and
@code{LocalDiagSCMatrix} provide an implementation of locally stored
matrices.  These are suitable for use in a uniprocessor environment.

The @code{LocalSCMatrixKit} is the default matrix kit returned
by @code{SCMatrixKit::default_matrixkit()}.

@c ===========================================================================

@node The Replicated Matrix Classes,  , The Local Matrix Classes, The Matrix Library
@section The Replicated Matrix Classes
@clindex ReplSCMatrixKit
@clindex ReplSCDimension
@clindex ReplSCVector
@clindex ReplSCMatrix
@clindex ReplSymmSCMatrix
@clindex ReplDiagSCMatrix

The classes @code{ReplSCMatrixKit}, @code{ReplSCDimension},
@code{ReplSCMatrix}, @code{ReplSymmSCMatrix}, and
@code{ReplDiagSCMatrix} provide an implementation of matrices and
vectors that have all data replicated on each node.
