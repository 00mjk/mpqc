@c -*-texinfo-*-
@node The SavableState Class, , The State Library, The State Library
@section The SavableState Class
@clindex SavableState
@c texi2html: do not split

Classes gain access to @code{SavableState}'s save and restore mechanisms
through inheritance.  Virtual inheritance is recommended, since other classes
in the inheritance hierarchy may also inherit from @code{SavableState},
hopefully virtually as well.

@menu
* SavableState Interface:: The interface for SavableState.
* SavableState Interface::
* SavableState Simple Example::
* SavableState Example with Inheritance::
* SavableState Example with Virtual and Nonvirtual Inheritance::
* SavableState Example with Pointers to SavableStates::
* SavableState Example with Pointers to Data::
@end menu

@c .....................................................................

@node SavableState Interface, , , The SavableState Class
@subsection Interface

The @code{SavableState} class has the following public interface:
@table @code

@item virtual void save_state(StateOut&)
Save the state of the object as specified by the @code{StateOut} object.
This routine saves the state of the object (with includes the
nonvirtual bases), virtual bases, and type information.
The default implementation should be adequate.

@item virtual void save_vbase_state(StateOut&)
This routine must invoke @code{save_data_state} for all
virtually inherited
base classes, including those that are not
direct parents.
@footnote{This is similar to the way C++ constructors work for
virtual base classes.}
The @code{save_data_state} member for the @code{SavableState} and the
@code{DescribedClass} virtual base classes should not
be called.  The implementation provided by
@code{SavableState} can be used when are no other virtually
inherited bases.

@item void save_data_state(StateOut&)
If the class contains any information that is needed
to restore state, or inherits nonvirtually from any class other
than @code{SavableState} and @code{DescribedClass} that has
state information that must be saved, then the class
must declare and implement a
@code{save_data_state} member (i.e. in nearly all cases).

@item @var{CLASSNAME}(StateIn&)
The @code{StateIn&} constructor must be declared and implemented for
all classes.  It must restore the information saved by @code{save_data_state}.

@item void save_object_state(StateOut&)
This can be used for saving state when the exact type of the object is
known for both the save and the restore.  To restore objects saved in
this way the user must directly invoke the object's @code{StateIn&}
constructor.

@item static @var{CLASSNAME}* restore_state(StateIn& @var{si})
This restores objects saved with @code{save_state}.  The exact type of
the next object in @var{si} can be any type publically derived from
@var{CLASSNAME}.

@end table

@c .....................................................................

@node SavableState Simple Example, , , The SavableState Class
@subsection Simple Example

Here is a simple example of the specification of a client, @code{C},
of @code{SavableState}:
@example
class C: virtual public SavableState @{
# define CLASSNAME C
# define HAVE_STATEIN_CTOR
# include <util/state/stated.h>
# include <util/class/classd.h>
  private:
    int i;
  public:
    C(StateIn&);
    void save_data_state(StateOut&);
  @};
@end example

Here is the implementation for the above:
@example
#define CLASSNAME C
#define HAVE_STATEIN_CTOR
#include <util/state/statei.h>
#include <util/class/classi.h>
void* C::_castdown(ClassDesc*cd)
  @{
  void* casts[0];
  return do_castdowns(casts);
  @}
void C::save_data_state(StateOut&so) @{
  so.put(i);
  @}
C::C(StateIn&si): SavableState(si,C::class_desc_) @{
  si.get(i);
  @}
@end example

@c .....................................................................

@node SavableState Example with Inheritance, , , The SavableState Class
@subsection Example with Inheritance

Here is an example of the specification of @code{C},
where @code{C} nonvirtually inherits from another
@code{SavableState} derivative:
@example
class C: public B @{
# define CLASSNAME C
# define HAVE_STATEIN_CTOR
# include <util/state/stated.h>
# include <util/class/classd.h>
  private:
    int i;
  public:
    C(StateIn&);
    void save_data_state(StateOut&);
  @};
@end example

Here is the implementation for the above:
@example
#define CLASSNAME C
#define PARENTS public B
#define HAVE_STATEIN_CTOR
#include <util/state/statei.h>
#include <util/class/classi.h>
void* C::_castdown(ClassDesc*cd)
  @{
  void* casts[] = { B::_castdown(cd) };
  return do_castdowns(casts);
  @}
void C::save_data_state(StateOut&so) @{
  B::save_data_state(so);
  so.put(i);
  @}
C::C(StateIn&si): SavableState(si,C::class_desc_), B(si)  @{
  si.get(i);
  @}
@end example

@c .....................................................................

@node SavableState Example with Virtual and Nonvirtual Inheritance, , , The SavableState Class
@subsection Example with Virtual and Nonvirtual Inheritance

Here is an example of the specification of @code{C},
where @code{C} nonvirtually inherits from another client of
@code{SavableState} as well as virtually inherits from a client
of @code{SavableState}:
@example
class C: public B,
         virtual public E @{
# define CLASSNAME C
# define HAVE_STATEIN_CTOR
# include <util/state/stated.h>
# include <util/class/classd.h>
  private:
    int i;
  public:
    C(StateIn&);
    void save_data_state(StateOut&);
  @};
@end example

Here is the implementation for the above:
@example
#define CLASSNAME C
#define PARENTS public B, virtual public E
#define HAVE_STATEIN_CTOR
#include <util/state/statei.h>
#include <util/class/classi.h>
void* C::_castdown(ClassDesc*cd)
  @{
  void* casts[] = {B::_castdown(cd),E::_castdown(cd)};
  return do_castdowns(casts);
  @}
void C::save_vbase_state(StateOut&sio) @{
  E::save_data_state(sio);
  @}
void C::save_data_state(StateOut&so) @{
  B::save_parent_state(so);
  so.put(i);
  @}
C::C(StateIn&si): SavableState(si,C::class_desc_), B(si), E(si) @{
  si.get(i);
  @}
@end example

@c .....................................................................

@node SavableState Example with Pointers to SavableStates, , , The SavableState Class
@subsection Example with Pointers to SavableStates

Here is an example where @code{C} has data members which are
pointers to derivatives of @code{SavableState}:
@example
class C: @{
# define CLASSNAME C
# define HAVE_STATEIN_CTOR
# include <util/state/stated.h>
# include <util/class/classd.h>
  private:
    A* ap; // A is also a SavableState
  public:
    C(StateIn&);
    void save_data_state(StateOut&);
  @};
@end example

Here is the implementation for the above:
@example
#define CLASSNAME C
#define HAVE_STATEIN_CTOR
#include <util/state/statei.h>
#include <util/class/classi.h>
void* C::_castdown(ClassDesc*cd)
  @{
  void* casts[0];
  return do_castdowns(casts);
  @}
void C::save_data_state(StateOut&so) @{
  so.put(ap);
  @}
C::C(StateIn&si): SavableState(si,C::class_desc_) @{
  ap = A::restore_state(si);
  @}
@end example

@c .....................................................................

@node SavableState Example with Pointers to Data, , , The SavableState Class
@subsection Example with Pointers to Data

Here is an example where @code{C} has data members which are
pointers to data:
@example
class C: virtual public SavableState @{
# define CLASSNAME C
# define HAVE_STATEIN_CTOR
# include <util/state/stated.h>
# include <util/class/classd.h>
  private:
    int vecsize;
    double *vec;
    int n1;
    int n2;
    double **array;
  public:
    C(StateIn&);
    void save_data_state(StateOut&);
  @};
@end example

Here is the implementation for the above:
@example
#define CLASSNAME C
#define HAVE_STATEIN_CTOR
#include <util/state/statei.h>
#include <util/class/classi.h>
void* C::_castdown(ClassDesc*cd)
  @{
  void* casts[0];
  return do_castdowns(casts);
  @}
void C::save_data_state(StateOut&so) @{
  so.put(vecsize);
  so.put(vec,vecsize);

  so.put(n1);
  so.put(n2);
  if (so.putpointer(array)) @{
    for (int i=0; i<n1; i++) @{
      so.put(array[i],n2);
      @}
    @}
  @}
C::C(StateIn&si): SavableState(si,C::class_desc_) @{
  si.get(vecsize);
  si.get(vec);

  si.get(n1);
  si.get(n2);

  int refnum;
  if (refnum = so.getpointer(array)) @{
    array = new double*[n1];
    so.havepointer(refnum,array);
    for (int i=0; i<n1; i++) @{
      si.get(array[i],n2);
      @}
    @}
  @}
@end example
