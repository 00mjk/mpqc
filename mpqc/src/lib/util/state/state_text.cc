//
// state_text.cc
//
// Copyright (C) 1996 Limit Point Systems, Inc.
//
// Author: Curtis Janssen <cljanss@limitpt.com>
// Maintainer: LPS
//
// This file is part of the SC Toolkit.
//
// The SC Toolkit is free software; you can redistribute it and/or modify
// it under the terms of the GNU Library General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.
//
// The SC Toolkit is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Library General Public License for more details.
//
// You should have received a copy of the GNU Library General Public License
// along with the SC Toolkit; see the file COPYING.LIB.  If not, write to
// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
//
// The U.S. Government is granted a limited license as per AL 91-7.
//

#include <stdarg.h>
#include <stdio.h>
#include <util/class/class.h>
#include <util/state/state.h>
#include <util/state/state_ptr.h>
#include <util/state/stateptrSet.h>
#include <util/state/statenumSet.h>
#include <util/state/stateptrImplSet.h>
#include <util/state/statenumImplSet.h>

#include <util/state/classdImplMap.h>

StateOutText::StateOutText() :
  StateOutFile()
{
}

StateOutText::StateOutText(FILE* fp) :
  StateOutFile(fp)
{
}

StateOutText::StateOutText(const char *path, const char * mode) :
  StateOutFile(path,mode)
{
}

StateOutText::~StateOutText()
{
}

StateInText::StateInText() :
  StateInFile(),
  _newlines(0)
{
}

StateInText::StateInText(FILE* fp) :
  StateInFile(fp),
  _newlines(0)
{
}

StateInText::StateInText(const char *path, const char * mode) :
  StateInFile(path,mode),
  _newlines(0)
{
}

StateInText::~StateInText()
{
}

///////////////////////////////////////////////////////////////////////

// no_newline() and its associated _no_newline static variable
// are used to omit the next newline generated by newline() in
// the input/output stream
static int _no_newline = 0;
void
no_newline()
{
  _no_newline = 1;
}
static int _no_array = 0;
void
no_array()
{
  _no_array = 1;
}

///////////////////////////////////////////////////////////////////////

int
StateInText::read(char*s)
{
  if (fscanf(fp_,"%s",s) != 1) {
      cerr << "StateInText::read(char*): failed" << endl;
      abort();
    }
  return strlen(s)+1;
}

int
StateInText::read(int&i)
{
  if (fscanf(fp_,"%d",&i) != 1) {
      cerr << "StateInText::read(int&): failed\n" << endl;
      abort();
    }
  return (sizeof(int));
}

int
StateInText::read(float&f)
{
  if (fscanf(fp_,"%f",&f) != 1) {
      cerr << "StateInText::read(float&): failed" << endl;
      abort();
    }
  return sizeof(float);
}

int
StateInText::read(double&d)
{
  if (fscanf(fp_,"%lf",&d) != 1) {
      cerr << "StateInText::read(double&): failed" << endl;
      abort();
    }
  return sizeof(double);
}

void
StateInText::abort()
{
  cerr << "StateInText aborting at line " << _newlines+1 << " in the input"
       << endl;
  ::abort();
}


///////////////////////////////////////////////////////////////////////

int StateOutText::put(const ClassDesc*cd)
{
  //
  // write out parent info
  if (!_classidmap->contains((ClassDesc*)cd)) {
      putparents(cd);
      fprintf(fp_," version of class %s is %d\n",cd->name(),cd->version());
      fflush(fp_);
      _classidmap->operator[]((ClassDesc*)cd) = _nextclassid++;
    }
  fprintf(fp_,"object of class %s being written\n", cd->name());
  fflush(fp_);
  return 0;
  }
void
StateOutText::putparents(const ClassDesc*cd)
{
  const ParentClasses& parents = cd->parents();

  for (int i=0; i<parents.n(); i++) {
      // the cast is needed to de-const-ify the class descriptor
      ClassDesc*tmp = (ClassDesc*) parents[i].classdesc();
      if (!_classidmap->contains(tmp)) {
          putparents(tmp);
          fprintf(fp_," version of class %s is %d\n",
                  tmp->name(),
                  tmp->version());
          fflush(fp_);
          _classidmap->operator[](tmp) = _nextclassid++;
        }
    }
}
int StateInText::get(const ClassDesc**cd)
{
  const int line_length = 512;
  char line[line_length];

  // if a list of class descriptors exists then read it in
  
  fgets(line,line_length,fp_); _newlines++;
  while (strncmp(line,"object",6)) {
      char name[line_length];
      int version;
      sscanf(line," version of class %s is %d\n",
             name,
             &version);
      ClassDesc* tmp = ClassDesc::name_to_class_desc(name);
      // save the class descriptor and the version
      _cd.add(tmp);
      int position = _cd.iseek(tmp);
      if (_version.length() <= position) {
          _version.reset_length(position + 10);
        }
      _version[position] = version;
      fgets(line,line_length,fp_); _newlines++;
    }

  // get the class name for the object
  char classname[line_length];
  sscanf(line,"object of class %s being written\n", classname);

  // convert the class id into the class descriptor
  *cd = ClassDesc::name_to_class_desc(classname);
  
  return 0;
}

int StateOutText::put(char r)
{
  no_array();
  return StateOut::put(r);
}
int StateInText::get(char&r)
{
  no_array();
  return StateIn::get(r);
}

int StateOutText::put(int r)
{
  no_array();
  return StateOut::put(r);
}
int StateInText::get(int&r)
{
  no_array();
  return StateIn::get(r);
}

int StateOutText::put(float r)
{
  no_array();
  return StateOut::put(r);
}
int StateInText::get(float&r)
{
  no_array();
  return StateIn::get(r);
}

int StateOutText::put(double r)
{
  no_array();
  return StateOut::put(r);
}
int StateInText::get(double&r)
{
  no_array();
  return StateIn::get(r);
}

int StateOutText::put(char*s,int size)
{
  if (!s) size = 0;
  if (putpointer((void*)s)) {
      no_newline(); put(size);
      int result = put_array_char(s,size);
      return result;
    }
  return 0;
}
int StateInText::get(char*&s)
{
  int objnum;
  if (objnum = getpointer((void**)&s)) {
    int size; no_newline(); get(size);
    if (size) {
      s = new char[size];
      havepointer(objnum,(void*)s);
      int result = get_array_char(s,size);
      return result;
      }
    else s = 0;
    }
  return 0;
}

int StateOutText::put(int*s,int size)
{
  if (!s) size = 0;
  if (putpointer((void*)s)) {
      no_newline(); put(size);
      int result = put_array_int(s,size);
      return result;
    }
  return 0;
}
int StateInText::get(int*&s)
{
  int objnum;
  if (objnum = getpointer((void**)&s)) {
    int size; no_newline(); get(size);
    if (size) {
      s = new int[size];
      havepointer(objnum,(void*)s);
      int result = get_array_int(s,size);
      return result;
      }
    else s = 0;
    }
  return 0;
}

int StateOutText::put(float*s,int size)
{
  if (!s) size = 0;
  if (putpointer((void*)s)) {
      no_newline(); put(size);
      int result = put_array_float(s,size);
      return result;
    }
  return 0;
}
int StateInText::get(float*&s)
{
  int objnum;
  if (objnum = getpointer((void**)&s)) {
    int size; no_newline(); get(size);
    if (size) {
      s = new float[size];
      havepointer(objnum,(void*)s);
      int result = get_array_float(s,size);
      return result;
      }
    else s = 0;
    }
  return 0;
}

int StateOutText::put(double*s,int size)
{
  if (!s) size = 0;
  if (putpointer((void*)s)) {
      no_newline(); put(size);
      int result = put_array_double(s,size);
      return result;
    }
  return 0;
}
int StateInText::get(double*&s)
{
  int objnum;
  if (objnum = getpointer((void**)&s)) {
    int size; no_newline(); get(size);
    if (size) {
      s = new double[size];
      havepointer(objnum,(void*)s);
      int result = get_array_double(s,size);
      return result;
      }
    else s = 0;
    }
  return 0;
}

int StateOutText::putpointer(void*p)
{
  if (p == 0) {
      fprintf(fp_,"reference to null\n");
      fflush(fp_);
      return 0;
    }
  StateDataPtr dp(p);
  Pix ind = (ps_?ps_->seek(dp):0);
  if (ind == 0) {
      if (ps_) {
          dp.assign_num(next_pointer_number++);
          ps_->add(dp);
        }
      fprintf(fp_,"writing object %d\n",dp.num());
      fflush(fp_);
      return 1;
    }
  else {
      fprintf(fp_,"reference to object %d\n",(*this->ps_)(ind).num());
      fflush(fp_);
      return 0;
    }
}
int StateInText::getpointer(void**p)
{
  const int line_length = 512;
  char line[line_length];

  fgets(line,line_length,fp_);
  _newlines++;

  if (!strcmp("reference to null\n",line)) {
      *p = 0;
      return 0;
    }
  else if (!strncmp("writing",line,7)) {
      int refnum;
      sscanf(line,"writing object %d\n",&refnum);
      StateDataNum num(refnum);
      *p = 0;
      return refnum;
    }
  else if (!strncmp("reference",line,9)) {
      int refnum;
      sscanf(line,"reference to object %d\n",&refnum);
      StateDataNum num(refnum);
      Pix ind = ps_->seek(num);
      *p = ((*this->ps_)(ind)).ptr();
      return 0;
    }
  else {
      cerr << "StateInText: couldn't find a reference object" << endl;
      abort();
    }

  return -1;
}

void
StateOutText::start_array()
{
  if (!_no_array) { putc(' ',fp_); putc('<',fp_); }
}
void
StateInText::start_array()
{
  if (!_no_array) {
      if ((getc(fp_) != ' ') || (getc(fp_) != '<')) {
          cerr << "StateInText: expected a \" <\"" << endl;
          abort();
        }
    }
}

void
StateOutText::end_array()
{
  if (!_no_array) {
      putc(' ',fp_); putc('>',fp_);
    }
  else {
      _no_array = 0;
    }
}
void
StateInText::end_array()
{
  if (!_no_array) {
      if ((getc(fp_) != ' ') || (getc(fp_) != '>')) {
          cerr << "StateInText: expected a \"> \"" << endl;
          abort();
        }
    }
  else {
      _no_array = 0;
    }
}

void
StateOutText::newline()
{
  if (_no_newline) {
      _no_newline = 0;
      return;
    }
  fprintf(fp_,"\n");
  fflush(fp_);
}
void
StateInText::newline()
{
  if (_no_newline) {
      _no_newline = 0;
      return;
    }
  if (getc(fp_) != '\n') {
      cerr << "StateInText: expected newline" << endl;
      abort();
    }
  _newlines++;
}

void
StateOutText::comment(const char* fmt,...)
{
  va_list args;

  va_start(args, fmt);
  fprintf(fp_, "%% ");
  vfprintf(fp_, fmt, args);
  fprintf(fp_, "\n");
  fflush(fp_);
  va_end(args);
}
void
StateInText::comment()
{
  int ch;
  if (getc(fp_) != '%' || getc(fp_) != ' ') {
      cerr << "StateInText: couldn't find beginning of comment" << endl;
      abort();
    }
  while((ch = getc(fp_)) != '\n') {
      if (ch == EOF) {
          cerr << "StateInText: couldn't find end of comment" << endl;
          abort();
        }
    }
}

///////////////////////////////////////////////////////////////////////

int StateOutText::putstring(char*s)
{
  if (putpointer((void*)s)) {
      if (s) {
	  int size = strlen(s);
	  no_newline(); put(size);
          int result = 0;
          if (size) {
              result = put_array_char(s,size);
            }
          return result;
	}
      else {
	  put((int)0);
	}
    }
  return 0;
}
int StateInText::getstring(char*&s)
{
  int objnum;
  if (objnum = getpointer((void**)&s)) {
      int size;
      no_newline(); get(size);
      if (size) {
	  s = new char[size+1];
          s[size] = '\0';
	  havepointer(objnum,s);
          int result = 0;
          if (size) {
              result = get_array_char(s,size);
            }
          return result;
	}
      else {
	  s = 0;
	}
    }
  return 0;
}

int StateOutText::put_array_char(const char*d,int size)
{
  start_array();
  int nwrit=size+1;
  for (int i=0; i<size; i++) { putc(d[i],fp_); }
  end_array();
  newline();
  return nwrit;
}
int StateInText::get_array_char(char*d,int size)
{
  start_array();
  int ch;
  for (int i=0; i<size; i++) {
      ch = getc(fp_);
      if (ch == EOF) {
          cerr << "StateInText::get_array_char: EOF while reading array"
               << endl;
          abort();
        }
      d[i] = ch;
    }
  end_array();
  newline();
  return size+1;
}

int StateOutText::put_array_int(const int*d,int size)
{
  start_array();
  int nwrit=0;
  for (int i=0; i<size; i++) nwrit += fprintf(fp_," %d",d[i]);
  fflush(fp_);
  end_array();
  newline();
  return nwrit;
}
int StateInText::get_array_int(int*d,int size)
{
  start_array();
  int nread,tnread=0;
  for (int i=0; i<size; i++) {
      nread=read(d[i]);
      tnread += nread;
    }
  end_array();
  newline();
  return tnread;
}

int StateOutText::put_array_float(const float*d,int size)
{
  start_array();
  int nwrit=0;
  for (int i=0; i<size; i++) nwrit += fprintf(fp_," %20.15e",d[i]);
  fflush(fp_);
  end_array();
  newline();
  return nwrit;
}
int StateInText::get_array_float(float*d,int size)
{
  start_array();
  int nread,tnread=0;
  for (int i=0; i<size; i++) {
      nread=read(d[i]);
      tnread += nread;
    }
  end_array();
  newline();
  return tnread;
}

int StateOutText::put_array_double(const double*d,int size)
{
  start_array();
  int nwrit=0;
  for (int i=0; i<size; i++) nwrit += fprintf(fp_," %20.15e",d[i]);
  fflush(fp_);
  end_array();
  newline();
  return nwrit;
}
int StateInText::get_array_double(double*d,int size)
{
  start_array();
  int nread,tnread=0;
  for (int i=0; i<size; i++) {
      nread=read(d[i]);
      tnread += nread;
    }
  end_array();
  newline();
  return tnread;
}

/////////////////////////////////////////////////////////////////////////////

// Local Variables:
// mode: c++
// c-file-style: "CLJ"
// End:
