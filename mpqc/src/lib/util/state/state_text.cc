
#include <stdarg.h>
#include <stdio.h>
#include <util/class/class.h>
#include "state.h"
#include "state_ptr.h"
#include "stateptrSet.h"
#include "statenumSet.h"
#include "stateptrImplSet.h"
#include "statenumImplSet.h"

#include "classdImplMap.h"

StateOutText::StateOutText() :
  StateOutFile()
{
}

StateOutText::StateOutText(FILE* fp) :
  StateOutFile(fp)
{
}

StateOutText::StateOutText(const char *path, const char * mode) :
  StateOutFile(path,mode)
{
}

StateOutText::~StateOutText()
{
}

StateInText::StateInText() :
  StateInFile(),
  _newlines(0)
{
}

StateInText::StateInText(FILE* fp) :
  StateInFile(fp),
  _newlines(0)
{
}

StateInText::StateInText(const char *path, const char * mode) :
  StateInFile(path,mode),
  _newlines(0)
{
}

StateInText::~StateInText()
{
}

///////////////////////////////////////////////////////////////////////

// no_newline() and its associated _no_newline static variable
// are used to omit the next newline generated by newline() in
// the input/output stream
static int _no_newline = 0;
void
no_newline()
{
  _no_newline = 1;
}
static int _no_array = 0;
void
no_array()
{
  _no_array = 1;
}

///////////////////////////////////////////////////////////////////////

void
StateInText::read(char*s)
{
  if (fscanf(fp_,"%s",s) != 1) {
      fprintf(stderr,"StateInText::read(char*): failed\n");
      abort();
    }
}

void
StateInText::read(int&i)
{
  if (fscanf(fp_,"%d",&i) != 1) {
      fprintf(stderr,"StateInText::read(int&): failed\n");
      abort();
    }
}

void
StateInText::read(float&f)
{
  if (fscanf(fp_,"%f",&f) != 1) {
      fprintf(stderr,"StateInText::read(float&): failed\n");
      abort();
    }
}

void
StateInText::read(double&d)
{
  if (fscanf(fp_,"%lf",&d) != 1) {
      fprintf(stderr,"StateInText::read(double&): failed\n");
      abort();
    }
}

void
StateInText::abort()
{
  fprintf(stderr,"StateInText aborting at line %d in the input\n",_newlines+1);
  ::abort();
}


///////////////////////////////////////////////////////////////////////

// int
// StateOutText::put(const ClassDesc* cd)
// {
//   comment("class description for \"%s\"", cd->name());
//   int result = StateOut::put(cd);
//   comment("end of class description\n");
//   return result;
// }
// int
// StateInText::get(const ClassDesc**cd)
// {
//   comment();
//   int result = StateIn::get(cd);
//   comment();
//   return result;
// }
int StateOutText::put(const ClassDesc*cd)
{
  //
  // write out parent info
  if (!_classidmap->contains((ClassDesc*)cd)) {
      putparents(cd);
      fprintf(fp_," version of class %s is %d\n",cd->name(),cd->version());
      _classidmap->operator[]((ClassDesc*)cd) = _nextclassid++;
    }
  fprintf(fp_,"object of class %s being written\n", cd->name());
  return 0;
  }
void
StateOutText::putparents(const ClassDesc*cd)
{
  ParentClasses& parents = cd->parents();

  for (int i=0; i<parents.n(); i++) {
      // the cast is needed to de-const-ify the class descriptor
      ClassDesc*tmp = (ClassDesc*) parents[i].classdesc();
      if (!_classidmap->contains(tmp)) {
          putparents(tmp);
          fprintf(fp_," version of class %s is %d\n",
                  tmp->name(),
                  tmp->version());
          _classidmap->operator[](tmp) = _nextclassid++;
        }
    }
}
int StateInText::get(const ClassDesc**cd)
{
  const int line_length = 512;
  char line[line_length];

  // if a list of class descriptors exists then read it in
  
  fgets(line,line_length,fp_); _newlines++;
  while (strncmp(line,"object",6)) {
      char name[line_length];
      int version;
      sscanf(line," version of class %s is %d\n",
             name,
             &version);
      const ClassDesc* tmp = ClassDesc::name_to_class_desc(name);
      // save the class descriptor and the version
      _cd.add(tmp);
      _version.add(version);
      fgets(line,line_length,fp_); _newlines++;
    };

  // get the class name for the object
  char classname[line_length];
  sscanf(line,"object of class %s being written\n", classname);

  // convert the class id into the class descriptor
  *cd = ClassDesc::name_to_class_desc(classname);
  
  return 0;
}

int StateOutText::put(char r)
{
  no_array();
  return StateOut::put(r);
}
int StateInText::get(char&r)
{
  no_array();
  return StateIn::get(r);
}

int StateOutText::put(int r)
{
  no_array();
  return StateOut::put(r);
}
int StateInText::get(int&r)
{
  no_array();
  return StateIn::get(r);
}

int StateOutText::put(float r)
{
  no_array();
  return StateOut::put(r);
}
int StateInText::get(float&r)
{
  no_array();
  return StateIn::get(r);
}

int StateOutText::put(double r)
{
  no_array();
  return StateOut::put(r);
}
int StateInText::get(double&r)
{
  no_array();
  return StateIn::get(r);
}

int StateOutText::put(char*s,int size)
{
  if (!s) size = 0;
  if (putpointer((void*)s)) {
      no_newline(); put(size);
      //start_array();
      int result = put_array_char(s,size);
      //end_array();
      //newline();
      return result;
    }
  return 0;
}
int StateInText::get(char*&s)
{
  int objnum;
  if (objnum = getpointer((void**)&s)) {
    int size; no_newline(); get(size);
    if (size) {
      s = new char[size];
      havepointer(objnum,(void*)s);
      //start_array();
      int result = get_array_char(s,size);
      //end_array();
      //newline();
      return result;
      }
    else s = 0;
    }
  return 0;
}

int StateOutText::put(int*s,int size)
{
  if (!s) size = 0;
  if (putpointer((void*)s)) {
      no_newline(); put(size);
      //start_array();
      int result = put_array_int(s,size);
      //end_array();
      //newline();
      return result;
    }
  return 0;
}
int StateInText::get(int*&s)
{
  int objnum;
  if (objnum = getpointer((void**)&s)) {
    int size; no_newline(); get(size);
    if (size) {
      s = new int[size];
      havepointer(objnum,(void*)s);
      //start_array();
      int result = get_array_int(s,size);
      //end_array();
      //newline();
      return result;
      }
    else s = 0;
    }
  return 0;
}

int StateOutText::put(float*s,int size)
{
  if (!s) size = 0;
  if (putpointer((void*)s)) {
      no_newline(); put(size);
      //start_array();
      int result = put_array_float(s,size);
      //end_array();
      //newline();
      return result;
    }
  return 0;
}
int StateInText::get(float*&s)
{
  int objnum;
  if (objnum = getpointer((void**)&s)) {
    int size; no_newline(); get(size);
    if (size) {
      s = new float[size];
      havepointer(objnum,(void*)s);
      //start_array();
      int result = get_array_float(s,size);
      //end_array();
      //newline();
      return result;
      }
    else s = 0;
    }
  return 0;
}

int StateOutText::put(double*s,int size)
{
  if (!s) size = 0;
  if (putpointer((void*)s)) {
      no_newline(); put(size);
      //start_array();
      int result = put_array_double(s,size);
      //end_array();
      //newline();
      return result;
    }
  return 0;
}
int StateInText::get(double*&s)
{
  int objnum;
  if (objnum = getpointer((void**)&s)) {
    int size; no_newline(); get(size);
    if (size) {
      s = new double[size];
      havepointer(objnum,(void*)s);
      //start_array();
      int result = get_array_double(s,size);
      //end_array();
      //newline();
      return result;
      }
    else s = 0;
    }
  return 0;
}

// int StateOutText::put(int*r,int s)
// {
//   start_array();
//   StateOut::put(r,s);
//   end_array();
//   newline();
// }
// int StateInText::get(int*&r)
// {
//   start_array();
//   StateIn::get(r);
//   end_array();
//   newline();
// }
// 
// int StateOutText::put(float*r,int s)
// {
//   start_array();
//   StateOut::put(r,s);
//   end_array();
//   newline();
// }
// int StateInText::get(float*&r)
// {
//   start_array();
//   StateIn::get(r);
//   end_array();
//   newline();
// }
// 
// int StateOutText::put(double*r,int s)
// {
//   start_array();
//   StateOut::put(r,s);
//   end_array();
//   newline();
// }
// int StateInText::get(double*&r)
// {
//   start_array();
//   StateIn::get(r);
//   end_array();
//   newline();
// }

int StateOutText::putpointer(void*p)
{
  if (p == 0) {
      fprintf(fp_,"reference to null\n");
      return 0;
    }
  StateDataPtr dp(p);
  Pix ind = ps_->seek(dp);
  //printf("StateOut::putpointer: ind = %d for 0x%x\n",(int)ind,p);
  if (ind == 0) {
      ind = ps_->add(dp);
      fprintf(fp_,"writing object %d\n",int(ind));
      return 1;
    }
  else {
      fprintf(fp_,"reference to object %d\n",int(ind));
      return 0;
    }
}
int StateInText::getpointer(void**p)
{
  const int line_length = 512;
  char line[line_length];

  fgets(line,line_length,fp_);
  _newlines++;

  if (!strcmp("reference to null\n",line)) {
      *p = 0;
      return 0;
    }
  else if (!strncmp("writing",line,7)) {
      int refnum;
      sscanf(line,"writing object %d\n",&refnum);
      StateDataNum num(refnum);
      Pix ind = ps_->seek(num);
      *p = 0;
      return refnum;
    }
  else if (!strncmp("reference",line,9)) {
      int refnum;
      sscanf(line,"reference to object %d\n",&refnum);
      StateDataNum num(refnum);
      Pix ind = ps_->seek(num);
      *p = ((*ps_)(ind)).ptr();
      return 0;
    }
  else {
      fprintf(stderr,"StateInText: couldn't find a reference object\n");
      abort();
    }

}

void
StateOutText::start_array()
{
  if (!_no_array) { putc(' ',fp_); putc('<',fp_); }
}
void
StateInText::start_array()
{
  if (!_no_array) {
      if ((getc(fp_) != ' ') || (getc(fp_) != '<')) {
          fprintf(stderr,"StateInText: expected a \" <\"\n");
          abort();
        }
    }
}

void
StateOutText::end_array()
{
  if (!_no_array) {
      putc(' ',fp_); putc('>',fp_);
    }
  else {
      _no_array = 0;
    }
}
void
StateInText::end_array()
{
  if (!_no_array) {
      if ((getc(fp_) != ' ') || (getc(fp_) != '>')) {
          fprintf(stderr,"StateInText: expected a \"> \"\n");
          abort();
        }
    }
  else {
      _no_array = 0;
    }
}

void
StateOutText::newline()
{
  if (_no_newline) {
      _no_newline = 0;
      return;
    }
  fprintf(fp_,"\n");
}
void
StateInText::newline()
{
  if (_no_newline) {
      _no_newline = 0;
      return;
    }
  if (getc(fp_) != '\n') {
      fprintf(stderr,"StateInText: expected newline\n");
      abort();
    }
  _newlines++;
}

void
StateOutText::comment(const char* fmt,...)
{
  va_list args;

  va_start(args, fmt);
  fprintf(fp_, "%% ");
  vfprintf(fp_, fmt, args);
  fprintf(fp_, "\n");
  va_end(args);
}
void
StateInText::comment()
{
  int ch;
  if (getc(fp_) != '%' || getc(fp_) != ' ') {
      fprintf(stderr,"StateInText: couldn't find beginning of comment\n");
      abort();
    }
  while((ch = getc(fp_)) != '\n') {
      if (ch == EOF) {
          fprintf(stderr,"StateInText: couldn't find end of comment\n");
          abort();
        }
    }
}

///////////////////////////////////////////////////////////////////////

int StateOutText::putstring(char*s)
{
  if (putpointer((void*)s)) {
      if (s) {
	  int size = strlen(s);
	  no_newline(); put(size);
          int result = 0;
          if (size) {
              result = put_array_char(s,size);
            }
          return result;
	}
      else {
	  put((int)0);
	}
    }
  return 0;
}
int StateInText::getstring(char*&s)
{
  int objnum;
  if (objnum = getpointer((void**)&s)) {
      int size;
      no_newline(); get(size);
      if (size) {
	  s = new char[size+1];
          s[size] = '\0';
	  havepointer(objnum,s);
          int result = 0;
          if (size) {
              result = get_array_char(s,size);
            }
          return result;
	}
      else {
	  s = 0;
	}
    }
  return 0;
}

int StateOutText::put_array_char(const char*d,int size)
{
  start_array();
  int nwrit=size+1;
  for (int i=0; i<size; i++) { putc(d[i],fp_); }
  end_array();
  newline();
  return nwrit;
}
int StateInText::get_array_char(char*d,int size)
{
  start_array();
  int ch;
  for (int i=0; i<size; i++) {
      ch = getc(fp_);
      if (ch == EOF) {
          fprintf(stderr,"StateInText::get_array_char:"
                  "EOF while reading array\n");
          abort();
        }
      d[i] = ch;
    }
  end_array();
  newline();
  return size+1;
}

int StateOutText::put_array_int(const int*d,int size)
{
  start_array();
  int nwrit=0;
  for (int i=0; i<size; i++) nwrit += fprintf(fp_," %d",d[i]);
  end_array();
  newline();
  return nwrit;
}
int StateInText::get_array_int(int*d,int size)
{
  start_array();
  int nread,tnread=0;
  for (int i=0; i<size; i++) {
      read(d[i]);
      tnread += nread;
    }
  end_array();
  newline();
  return tnread;
}

int StateOutText::put_array_float(const float*d,int size)
{
  start_array();
  int nwrit=0;
  for (int i=0; i<size; i++) nwrit += fprintf(fp_," %f",d[i]);
  end_array();
  newline();
  return nwrit;
}
int StateInText::get_array_float(float*d,int size)
{
  start_array();
  int nread,tnread;
  for (int i=0; i<size; i++) {
      read(d[i]);
      tnread += nread;
    }
  end_array();
  newline();
  return tnread;
}

int StateOutText::put_array_double(const double*d,int size)
{
  start_array();
  int nwrit=0;
  for (int i=0; i<size; i++) nwrit += fprintf(fp_," %f",d[i]);
  end_array();
  newline();
  return nwrit;
}
int StateInText::get_array_double(double*d,int size)
{
  start_array();
  int nread,tnread=0;
  for (int i=0; i<size; i++) {
      read(d[i]);
      tnread += nread;
    }
  end_array();
  newline();
  return tnread;
}
