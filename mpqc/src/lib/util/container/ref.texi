@c -*-texinfo-*-
@node The Ref Library, The VRefCount, , Top
@chapter The Reference Library
@cindex Ref Library

The Reference Library provides @code{cpp} macros and a base class that
can be used to maintain reference counts to objects.  For an
object to be reference counted its class must inherit from
the @code{VRefCount} class.  This adds @code{sizeof(int)} bytes
of overhead per object and makes the destructor virtual (so a vtable
will be added to objects of the class, if there wasn't already a virtual
member in the class).  The reference counts are maintained by
classes created with the @code{cpp} macros @code{REF_dec} and
@code{REF_def}.  These macros take the name of the reference counted
class as the only argument and, respectively, declare the interface
and define the members of the new Ref class.


@menu
* The VRefCount Class:: The base class for reference counted objects.
* The Ref Macros:: Declare and define reference counted objects.
* A Ref Example:: An example of using the Ref Library.
@end menu

@c -------------------------------------------------------------------------

@node The VRefCount Class, The Ref Macros, The Ref Library, The Ref Library
@section The VRefCount Class
@clindex VRefCount
@c texi2html: do not split

@code{VRefCount} is the base class for all reference counted objects.  If
multiple inheritance is used, @code{VRefCount} must be virtually inherited
from, otherwise references to invalid memory will likely result.

Reference counting information is usually maintained be classes created
by the @code{REF_dec} and @code{REF_def} macros
(@pxref{The Ref Macros}), however this mechanism can be
supplemented or replaced by using the following public interface to
@code{VRefCount}:

@table @code
@item int reference()
Increment the reference count and return the new count.
@item int dereference()
Decrement the reference count and return the new count.
@item int nreference()
Return the reference count.
@item void unmanage()
Turn off the reference counting mechanism for this object.  The
value returned by @code{nreference()} will always be @samp{1} after this is
called.
@item int managed()
Return @samp{1} if the object is managed.  Otherwise return @samp{0}.
@end table

The @code{unmanage()} member is only needed for special cases where
memory management must be turned off.  For example, if a reference
counted object is created on the stack, memory management
mechanism based on reference counting must be prohibited from deleting it.
The @code{unmanage()} member accomplishes this, but a better solution
would be to alloc the object on the heap with @code{new} and let
a class declared using the @code{REF_dec} macro manage the memory for
the object.

When using a debugger to look at reference counted objects the count is
maintained in the @code{_reference_count_} member.  However, this member
is encoded so that memory overwrites can be sometimes detected.  Thus,
interpretation of @code{_reference_count_} is not straightforward and
will change as the implementation of @code{VRefCount} becomes more
sophisticated.

@c -------------------------------------------------------------------------

@node The Ref Macros, A Ref Example, The VRefCount Class, The Ref Library
@section The Reference Macros
@mcindex REF_dec
@mcindex REF_def
@c texi2html: do not split

The Reference Macros are used to declare and define classes that
automatically manage memory for reference counted objects.  The
@code{REF_dec} macro takes a class name as an argument and constructs
a new class declaration with a formed by appending the class name
to @code{Ref}.  This macro would usually be invoking in the header
file that gives the declaration for that reference counted class.
The implementation of the members for this class are generated by
using the @code{REF_def} which also takes the class name as the
argument.  This should be given in one of the sources files relating
to that class and should not be placed in the header file.  The
@code{REF_dec} macro must be followed by a semicolon.
@footnote{Templates would have been much cleaner than macros; however,
until problems with templates in C++ compilers have been resolved,
macros will have to do}

For a class @code{T}, the class generated by @code{REF_dec(T);} would
have the following public interface:

@table @code
@item T* operator->() const
  Returns the reference counted object.  The behaviour is undefined if
  the object is null.
@item T* pointer() const
  Returns the reference counted object.
@item operator T*() const
  Returns the reference counted object.  This member is disabled for certain
  buggy C++ compilers.  The @code{pointer()} member should be used instead.
@item T& operator *() const
  Returns a C++ reference to the reference counted object.  The behaviour
  is undefined if the object is null.
@item RefT ()
  Create a reference to a null object.
@item RefT (T*a)
  Create a reference to the object @var{a}.
@item RefT (const RefT &a)
  Create a reference to the object referred to by @var{a}.
@item ~RefT ()
  Delete this reference to the object.  Decrement the object's reference
  count and delete the object if the count is zero.
@item int null() const
  Return @samp{1} if this is a reference to a null object.  Otherwise
  return @samp{0}.
@item int nonnull() const
  Return @code{!null()}.
@item RefT& operator=(const RefT & c)
  Assign the refence counted object to be the same object that
  @var{c} contains.  If a nonnull object is currently referred to
  its reference count is decremented and it is deleted if necessary.
@item RefT& operator=(T* cr)
  Assign the refence counted object to @var{cr}.
  If a nonnull object is currently referred to
  its reference count is decremented and it is deleted if necessary.
@item void assign_pointer(T* cr)
  Like the above @code{operator=(T*)}.
@item int operator==(const RefT &a) const
@item int operator!=(const RefT &a) const
@item int operator==(const T * a) const
@item int operator!=(const T * a) const
@item int operator>=(const RefT &a) const
@item int operator<=(const RefT &a) const
@item int operator>(const RefT &a) const
@item int operator<(const RefT &a) const
  These comparison operations compare the pointer addresses of the
  contained objects.
@item void clear()
  Sets the contained object to the null object.
@end table

@c -------------------------------------------------------------------------

@node A Ref Example, , The Ref Macros, The Ref Library
@section A Reference Example
@c texi2html: do not split

This is a simple example of how to manage memory with reference
counts.

@example

#include <util/container/ref.h>

class A: virtual public VRefCount {
};
REF_dec(A);

class B: public A {
};
REF_dec(B);

REF_def(A);
REF_def(B);

int
main()
{
  RefA a1(new A);
  RefA a2;

  // Create another reference to the A object pointed to by a1.
  a2 = a1;

  // Make a2 refer to a new A object.
  a2 = new A;

  // a2 was the only reference to the second A object, so setting
  // a2 to the null object will cause the second A object to be
  // deleted.
  a2 = 0;

  RefB b(new B);

  // RefA and RefB are not related by inheritance as are A and B,
  // so `a1 = b' will fail and the following must be used.  This
  // will also cause the first A object to be deleted.
  a1 = b.pointer();

  // The B object will be deleted here because all of the references
  // to it go out of scope and destroyed.
  return 0;
}

@end example
