
\chapter{The Described Class Library}
\index{metainformation}
\index{cast operations}

The class library provides abstract base classes, macros,
and include files that collectively provide a mechanism that
allows programmers to retrieve information about a class'
name; parents; and void, \clsnmref{StateIn}\srccd{\&}, and
\clsnmref{KeyVal}\srccd{\&} constructors.  Also, a castdown
mechanism is provided.

\subsection{Using \clsnm{DescribedClass}}
\index{CLASSNAME}
\index{PARENTS}
\index{HAVE\_CTOR}
\index{HAVE\_KEYVAL\_CTOR}
\index{HAVE\_STATEIN\_CTOR}

The special nature of described classes requires that the base class,
\clsnmref{DescribedClass}, cannot provide everything needed.  To assist the
user in setting up described classes several include files are provided.
To use these include files, the programmer must define some \exenm{cpp}
macros and, within the body of the class declaration,
include \filnm{util/class/classd.h} for concrete classes and
\filnm{util/class/classda.h} for abstract classes.  Include files
are also provided for implementing all but one of the member functions
needed by each \clsnmref{DescribedClass} descendant.  These are
\filnm{util/class/classi.h} for concrete classes and
\filnm{util/class/classia.h} for abstract classes.

Each of these include files examines several \srccd{cpp}
macros to correctly set up the class declarations and definitions.
All of the macros are automatically
\srccd{undef}'ed by each of the include files.
The macros are:

\begin{description}
\item[\srccd{CLASSNAME}]
  The name of the class.
\item[\srccd{PARENTS}]
  The parents of the class exactly as they appear in the class
  declaration.  For example \srccd{public A, private B, virtual Z},
  without quotes.  The order, access specification, and virtualness
  must be correct or the castdown mechanism could cause erratic behavior.
  This is only needed for the implementation include file.  It should
  not be set for the declaration include file.
\item[\srccd{HAVE\_CTOR}]
  This should be defined if the programmer (or compiler) has provided
  a constructor for the class taking no arguments.
\item[\srccd{HAVE\_KEYVAL\_CTOR}]
  This should be defined if the programmer has provided
  a constructor for the class taking a \clsnmref{KeyVal}\srccd{\&} argument.
  This is useful if objects of this type need to be read from
  an input file.
\item[\srccd{HAVE\_STATEIN\_CTOR}]
  This should be defined if the programmer has provided
  a constructor taking a \clsnm{StateIn}\srccd{\&} arguments.
  This is necessary if objects of this type are to be saved and
  restored.
\end{description}

A class declaration would look like:

\begin{alltt}
class A: virtual public \clsnmref{DescribedClass} \{
#  define CLASSNAME A
#  define HAVE_CTOR
#  include <util/class/classd.h>
\};
\end{alltt}

The source file implementing the members of \clsnm{A} would follow a
similar procedure to define \clsnm{A}'s members.  For example:

\begin{alltt}
#define CLASSNAME A
#define PARENTS virtual public \clsnmref{DescribedClass}
#define HAVE_CTOR
#include <util/class/classi.h>
\end{alltt}

The \srccd{\_castdown} operation must be implemented by the user.
It is very simple to write, but small errors can lead to difficult
to find bugs.  For the example above, the \srccd{\_castdown} operator for
class \srccd{A} would look like:

\begin{alltt}
A::_castdown(const \clsnmref{ClassDesc}*cd)
\{
  void* casts[] =  \{ \clsnmref{DescribedClass}::_castdown(cd) \};
  return do_castdowns(casts,cd);
\}
\end{alltt}

The cast array contains the results of attempting to call
\srccd{\_castdown} for each of the parent classes.  The order and
number of the castings must match those given by the \srccd{PARENTS}
macro.  Most of the work involved in doing a castdown has been
moved into the helper function \srccd{do\_castdowns}, which is
implemented by the provided include files.

\subsection{The \clsnm{DCRef} Macros}
\index{DescribedClass\_REF\_dec}
\index{DescribedClass\_REF\_def}

Some C++ compilers don't handle class templates very well so
\exenm{cpp} macros have been provided to define smart
pointers to \clsnmref{DescribedClass} derivatives.
\srccd{REF\_dec} and \srccd{REF\_def}.  These macros take the
name of the \clsnmref{DescribedClass} class as the only
argument and declare the interface and define the members of
the new \clsnmref{DCRef} class.  The
\srccd{DescribedClass\_REF\_dec} macro takes a class name as
an argument and constructs a new class declaration which is
formed by appending the class name to \srccd{Ref}.  This
macro would usually be invoked in the same header file that
gives the declaration for that reference counted class.  The
implementation of the members for this class are generated
by using the \srccd{DescribedClass\_REF\_def} which also
takes the class name as the argument.  This should be given
in one of the source files relating to that class and should
not be placed in the header file.  The
\srccd{DescribedClass\_REF\_dec} macro must be followed by a
semicolon.

\section{Using \clsnm{DCRef}}
\index{DCRef}

Following is an example of the use of \clsnmref{DCRef}.
Note that inheritance from \clsnmref{VRefCount}
is unnecessary, since \clsnmref{DescribedClass} already is a
\clsnmref{VRefCount} descendant.

\begin{alltt}
#include <util/class/class.h>

class A: virtual public \clsnmref{DescribedClass} \{
 // all the stuff needed for a DescribedClass omitted
\};
DescribedClass_REF_dec(A);

class B: public A \{
 // all the stuff needed for a DescribedClass omitted
\};
DescribedClass_REF_dec(B);

DescribedClass_REF_def(A);
DescribedClass_REF_def(B);

int
main()
\{
  RefA a1(new B);
  RefB b1;

  // a1 and b1 will refer to the same object
  b1 = a1;

  RefA a2(new A)
  RefB b2;

  // b2 will refer to null since a2 does not refer to a B type object.
  b2 = a2;

  return 0;
\}

\end{alltt}
