
/**@name The Described Class Library

The class library provides abstract base classes, macros,
and include files that collectively provide a mechanism that
allows programmers to retrieve information about a class'
name; parents; and void, StateIn\srccd{\&}, and
KeyVal\srccd{\&} constructors.  Also, a castdown
mechanism is provided.

*/

//@{

/**@name Using DescribedClass

The special nature of described classes requires that the base class,
DescribedClass, cannot provide everything needed.  To assist the user in
setting up described classes several include files are provided.  To use
these include files, the programmer must define some cpp macros and, within
the body of the class declaration, include util/class/classd.h for concrete
classes and util/class/classda.h for abstract classes.  Include files are
also provided for implementing all but one of the member functions needed
by each DescribedClass descendant.  These are util/class/classi.h for
concrete classes and util/class/classia.h for abstract classes.

Each of these include files examines several cpp
macros to correctly set up the class declarations and definitions.
All of the macros are automatically
undef'ed by each of the include files.
The macros are:

\begin{description}
\item[CLASSNAME]
  The name of the class.
\item[PARENTS]
  The parents of the class exactly as they appear in the class
  declaration.  For example: "public A, private B, virtual Z",
  without quotes.  The order, access specification, and virtualness
  must be correct or the castdown mechanism could cause erratic behavior.
  This is only needed for the implementation include file.  It should
  not be set for the declaration include file.
\item[HAVE_CTOR]
  This should be defined if the programmer (or compiler) has provided
  a constructor for the class taking no arguments.
\item[HAVE_KEYVAL_CTOR]
  This should be defined if the programmer has provided
  a constructor for the class taking a KeyVal& argument.
  This is useful if objects of this type need to be read from
  an input file.
\item[HAVE_STATEIN_CTOR]
  This should be defined if the programmer has provided
  a constructor taking a StateIn& arguments.
  This is necessary if objects of this type are to be saved and
  restored.
\end{description}

A class declaration would look like:

\begin{verbatim}
class A: virtual public DescribedClass {
#  define CLASSNAME A
#  define HAVE_CTOR
#  include <util/class/classd.h>
};
\end{verbatim}

The source file implementing the members of A would follow a
similar procedure to define A's members.  For example:

\begin{verbatim}
#define CLASSNAME A
#define PARENTS virtual public DescribedClass
#define HAVE_CTOR
#include <util/class/classi.h>
\end{verbatim}

The _castdown operation must be implemented by the user.
It is very simple to write, but small errors can lead to difficult
to find bugs.  For the example above, the _castdown operator for
class A would look like:

\begin{verbatim}
A::_castdown(const ClassDesc*cd)
{
  void* casts[] =  { DescribedClass::_castdown(cd) };
  return do_castdowns(casts,cd);
}
\end{verbatim}

The cast array contains the results of attempting to call
_castdown for each of the parent classes.  The order and
number of the castings must match those given by the PARENTS
macro.  Most of the work involved in doing a castdown has been
moved into the helper function do_castdowns, which is
implemented by the provided include files.

*/

/**@name The DCRef Macros

Some C++ compilers don't handle class templates very well so cpp macros
have been provided to define smart pointers to DescribedClass derivatives.
REF_dec and REF_def.  These macros take the name of the DescribedClass
class as the only argument and declare the interface and define the members
of the new DCRef class.  The DescribedClass_REF_dec macro takes a class
name as an argument and constructs a new class declaration which is formed
by appending the class name to Ref.  This macro would usually be invoked in
the same header file that gives the declaration for that reference counted
class.  The implementation of the members for this class are generated by
using the DescribedClass_REF_def which also takes the class name as the
argument.  This should be given in one of the source files relating to that
class and should not be placed in the header file.  The
DescribedClass_REF_dec macro must be followed by a semicolon.

*/

/**@name Using DCRef

Following is an example of the use of DCRef.  Note that inheritance from
VRefCount is unnecessary, since DescribedClass already is a VRefCount
descendant.

\begin{verbatim}
#include <util/class/class.h>

class A: virtual public DescribedClass {
 // all the stuff needed for a DescribedClass omitted
};
DescribedClass_REF_dec(A);

class B: public A {
 // all the stuff needed for a DescribedClass omitted
};
DescribedClass_REF_dec(B);

DescribedClass_REF_def(A);
DescribedClass_REF_def(B);

int
main()
{
  RefA a1(new B);
  RefB b1;

  // a1 and b1 will refer to the same object
  b1 = a1;

  RefA a2(new A)
  RefB b2;

  // b2 will refer to null since a2 does not refer to a B type object.
  b2 = a2;

  return 0;
}

\end{verbatim}

*/

//@}
