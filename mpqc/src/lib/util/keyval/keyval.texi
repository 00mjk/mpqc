@c -*-texinfo-*-
@node The KeyVal Library, The KeyVal Class, , Top
@chapter The KeyVal Library
@cindex KeyVal Library

The @code{KeyVal} class provides a means for users to associate keywords
with values.  The package is flexible enough to allow complex structures
and arrays to be read from an input file.  Classes which are descendants
of @code{DescribedClass} (@pxref{The DescribedClass Class}) and have a
@code{KeyVal} constructor can be given in the input and read in with a
single C++ statement.

@menu
* The KeyVal Class:: The abstract base class for keyword/value associations.
* The ParsedKeyVal Class:: A KeyVal implementation for human readable input.
@end menu

@c -------------------------------------------------------------------------

@node The KeyVal Class, , The KeyVal Library, The KeyVal Library
@section The KeyVal Class
@clindex KeyVal
@c texi2html: do not split

The @code{KeyVal} class is designed to simplify the process of allowing
a user to specify keyword/value associations to a C++ program.  A
flexible input style and ease of use for the programmer is achieved with
this method.  Keywords are represented by 0 terminated character arrays.
The keywords are organized hierarchially, in a manner similar to the way
that many file systems are organized.  One character is special,
'@code{:}', which is used to separate the various hierarchial labels,
which are referred to as ``segments'', in the keyword.

A convention for specifying arrays is provided by @code{KeyVal}.  Each
index of the array is given by appending a segment containing the
character representation of the index.  Thus, @code{array:3:4} would be
a the keyword corresponding to third row and fourth column of
@code{array}.

To allow the @code{KeyVal} class to have associations that can represent
data for classes, the keyword can be associated with a class as well as
a value.  This permits polymorphic data to be unambiguously represented
by keyword/value associations.  Most use of @code{KeyVal} need not be
concerned with this.

@menu
* KeyVal Interface:: The interface to the KeyVal class.
* KeyVal Errors:: Errors codes used by the KeyVal class.
@end menu

@c .........................................................................

@node KeyVal Interface, , , The KeyVal Class
@subsection Interface

The public interface to @code{KeyVal} is:
@table @code
@item virtual const char*  value(char*)=0
Return the value associated with the keyword.  The
value may be invalid after another @code{KeyVal} member,
other than @code{error}, is called.
See @code{pcharvalue} for a member which returns a copy
of the value.

@item virtual const char*  classname(char*)=0
Return the class name associated with the keyword.  The
name may be invalid after another @code{KeyVal} member,
other than @code{error}, is called.

@item virtual int exists(char*)
This takes as its only argument a keyword.
Returns 1 if the keyword has a value and 0 otherwise.

@item double doublevalue(char*)
Returns the double precision floating point value of the keyword argument.

@item float floatvalue(char*)
Returns the single precision floating point value of the keyword argument.

@item char charvalue(char*)
Returns the character value of the keyword argument.

@item int intvalue(char*)
Returns the integer value of the keyword argument.

@item char* pcharvalue(char*)
Returns the a copy of the string representation of the keyword's value.
Storage for the copy is obtained with new.

@item virtual KeyValError error()
Return the current error condition.

@item virtual char* errormsg()
Return a textual representation of the current error.

@item virtual char* errormsg(KeyValError @var{err})
Return a textual representation of @var{err}.

@item virtual int count(char*)
If the value of a keyword is an array, then return its length.
@end table

Each of the members taking a keyword for an argument can have up to two
(one for @code{count}) more integers following the keyword in the
argument list.  These are intepreted as array indices and result in
segments being appending to the keyword.  The segments correspond to the
decimal representation of the indices.

The protected interface is:
@table @code
@item void seterror(KeyValError)
Set the current error condition.
@end table

@c .........................................................................

@node KeyVal Errors, , , The KeyVal Class
@subsection Error Conditions

Errors are specified by the @code{KeyVal}@code{::}@code{KeyValError}
enum.  The possibilities for @code{KeyValError} are:
@table @code
@item OK
No problem.
@item HasNoValue
The keyword has no value.
@item WrongType
The datum is not of the appropiate type.
@item UnknownKeyword
The keyword was not found.
@item OperationFailed
The requested operation failed.
@end table

@c -------------------------------------------------------------------------

@node The ParsedKeyVal Class, , , The KeyVal Library
@section The ParsedKeyVal Class
@clindex ParsedKeyVal
@c texi2html: do not split

The @code{ParsedKeyVal} class inherits from @code{KeyVal}.  It permits
users to specify keyword/value associations in a text file.

@menu
* ParsedKeyVal Interface:: The interface to ParsedKeyVal.
* ParsedKeyVal Assignment:: Making keyword/value associations.
* ParsedKeyVal Keyword Grouping:: A shorthand for writing similar keywords.
* ParsedKeyVal Arrays:: A shorthand for expressing arrays.
* ParsedKeyVal Tables:: A shorthand for expressing tables.
* ParsedKeyVal Value Substitution:: A method for substituting values.
* ParsedKeyVal Expression Evaluation:: Simple mathematical expressions.
* ParsedKeyVal Objects:: Objects can be created by giving a class name.
@end menu

@c .........................................................................

@node ParsedKeyVal Interface, , , The ParsedKeyVal Class
@subsection Interface

These member are provided in addition to those provided in addition
to those member of @code{KeyVal} that are overridden.

@table @code
@item ParsedKeyVal(char* @var{filename})
Construct a @code{ParsedKeyVal} and use the @var{filename} as the name of
the input file.
@item void input(char* @var{filename})
Append additional input files.
@end table

@c .........................................................................

@node ParsedKeyVal Assignment, , , The ParsedKeyVal Class
@subsection Assignment

As an example of the use of @code{ParsedKeyVal}, consider the following input:
@example
x_coordinate = 1.0
y_coordinate = 2.0
x_coordinate = 3.0
@end example
Two assignements will be made.  The keyword @code{x_coordinate} will be
associated with the value @code{1.0} and the keyword @code{y_coordinate}
will be assigned to @code{2.0}.  The third line in the above input
will have no effect since @code{x_coordinate} was assigned previously.

@c .........................................................................

@node ParsedKeyVal Keyword Grouping, , , The ParsedKeyVal Class
@subsection Keyword Grouping

Lets imagine that we have a program which needs to read in the
characteristics of animals.  There are lots of animals so it might be
nice to catagorize them by their family.  Here is a sample format for
such an input file:
@example
reptile: (
  alligator: (
    legs = 4
    extinct = no
    )
  python: (
    legs = 0
    extinct = no
    )
  )
bird: (
  owl: (
    flys = yes
    extinct = no
    )
  )
@end example

This sample illustrates the use of @var{keyword} @code{=} @var{value}
assignments and the keyword grouping operators @code{(} and @code{)}.
The keywords in this example are
@example
reptile:alligator:legs
reptile:alligator:extinct
reptile:alligator:legs
reptile:python:size
reptile:python:extinct
bird:owl:flys
bird:owl:extinct
@end example

The @code{:}'s occuring in these keywords break the keywords into
smaller logical units called keyword segments.  The sole purpose of this
is to allow persons writing input files to group the input into easy to
read sections.  In the above example there are two main sections, the
reptile section and the bird section.  The reptile section takes the
form @code{reptile} @code{:} @code{(} @var{keyword} @code{=} @var{value}
assignments @code{)}.  Each of the keywords found between the
parentheses has the @code{reptile:} prefix attached to it.  Within each
of these sections further keyword groupings can be used, as many and as
deeply nested as the user wants.

Keyword grouping is also useful when you need many different programs to
read from the same input file.  Each program can be assigned its own
unique section.

@c .........................................................................

@node ParsedKeyVal Arrays, , , The ParsedKeyVal Class
@subsection Array Construction

A method of specifying arrays of data would be useful.  One way to
do this would be as follows:
@example
array: (
  0 = 5.4
  1 = 8.9
  2 = 3.7
  )
@end example
The numbers @code{0}, @code{1}, and @code{2} in this example are keyword
segments which serve as indices of @code{array}.  However, this syntax
is somewhat awkward and array construction operators have been provided
to simplify the input for this case.  The following input is equivalent
to the above input:
@example
array = [ 5.4 8.9 3.7 ]
@end example

More complex arrays than this can be imagined.  Suppose an array of
complex numbers is needed.  For example the input
@example
carray: (
  0: ( r = 1.0  i = 0.0 )
  1: ( r = 0.0  i = 1.0 )
  )
@end example
could be written as
@example
carray: [
  (r = 1.0 i = 0.0)
  (r = 0.0 i = 1.0)
  ]
@end example
which looks a bit nicer than the example without array construction
operators.

Furthermore, the array construction operators can be nested in about
every imaginable way.  This allows multidimensional arrays of
complicated data to be represented.

It would be nice to just extend an array that is already defined.  This
feature has not been implemented; however, user demand for it might
result in its implementation.  The operators reserved for this purpose
are @code{+[} and @code{]}.

@c .........................................................................

@node ParsedKeyVal Tables, , , The ParsedKeyVal Class
@subsection Table Construction

Although the array contstruction operators will suit most requirements
for enumerated lists of data, in some cases the input can still look
ugly.  This can, in some cases, be fixed with the table construction
operators, @code{@{} and @code{@}}.

Suppose a few long vectors of the same length are needed and the data in
the @code{i}th element of each array is related or somehow belong
together.  If the arrays are so long that the width of a page is
exceeded, then data that should be seen next to each other are no longer
adjacent.  The way this problem can be fixed is to arrange the data
vertically side by side rather than horizontally.  The table
construction operators allows the user to achieve this in a very simple
manner.
@example
balls: (
  color    = [  red      blue     red   ]
  diameter = [   12       14       11   ]
  material = [  rubber  vinyl   plastic ]
  bouces   = [  yes      no       no    ]
  coordinate = [[ 0.0  0.0  0.0]
                [ 1.0  2.0 -1.0]
                [ 1.0 -1.0  1.0]]
  )
@end example
can be written
@example
balls: (
  @{ color diameter material bounces     coordinate@}
                  
  @{  red     12    rubber    yes     [ 0.0  0.0  0.0]
     blue    14    vinyl     no      [ 1.0  2.0 -1.0]
     red     11    plastic   no      [ 1.0 -1.0  1.0] @}
  )
@end example
The length and width of the table can be anything the user desires.

@c .........................................................................

@node ParsedKeyVal Value Substitution, , , The ParsedKeyVal Class
@subsection Value Substitution

Occasionally, a user may need to repeat some value several times in an
input file.  If the value must be changed, it would be nice to only
change the value in one place.  The value substitution feature of
@code{ParsedKeyVal} always the user to do this.  Any place a value can
occur the user can place a @code{$}.  Following this a keyword must be
given.  This keyword must have been assigned before the attempt is made
to use its value in a value substitution.

Here is an example illustrating most of the variable substition
features:
@example
default:linewidth = 130
testsub: (
  ke: (
    ke_1 = 1
    ke_2 = 2
    ke_3: (
      ke_31 = 31
      ke_32 = 32
      )
    )
  kx = $ke
  r1 = 3.0
  r2 = $r1
  linewidth = $:default:linewidth
  )
@end example
is the same as specifying
@example
testsub: (
  ke: (
    ke_1 = 1
    ke_3: (
      ke_31 = 31
      ke_32 = 32
      )
    ke_2 = 2
    )
  linewidth = 130
  r2 = 3.0
  r1 = 3.0
  kx: (
    ke_1 = 1
    ke_2 = 2
    ke_3: (
      ke_31 = 31
      ke_32 = 32
      )
    )
  )
@end example
It can be seen from this that value substitution can result in entire
keyword segment hierarchies being copied, as well as simple
substitutions.


@c .........................................................................

@node ParsedKeyVal Expression Evaluation, , , The ParsedKeyVal Class
@subsection Expression Evaluation

It is nice to be able to multiply numbers together directly in the input
file.  For example, you may need to change the units on a number and
want to see where exactly the number is coming from.  This motivated the
development of an expression evaluation facility in the
@code{ParsedKeyVal} package.  This facility is still under development,
but some primitive expressions can be evaluated in the current release.

Suppose your program requires several parameters @code{x1}, @code{x2},
and @code{x3}.  Furthermore, suppose that their ratios remain fixed for
all the runs of the program that you desire.  It would be best to
specify some scale factor in the input that would be the only thing that
has to be changed from run to run.  If you don't want to or cannot
modify the program, then this can be done directly with
@code{ParsedKeyVal} as follows
@example
scale = 1.234
x1 = ( $:scale *  1.2 )
x2 = ( $:scale *  9.2 )
x3 = ( $:scale * -2.0 )
@end example
So we see that to the right of the ``@code{=}'' the characters
``@code{(}'' and ``@code{)}'' are the expression construction operators.
This is in contrast to their function when they are to the left of the
``@code{=}'', where they are the keyword grouping operators.

Currently, the expression must be binary and the data is all converted
to double.  If you use the expression construction operators to produce
data that the program expects to be integer, you will certainly get the
wrong answers (unless the desired value happens to be zero).

@c .........................................................................

@node ParsedKeyVal Objects, , , The ParsedKeyVal Class
@subsection Objects

An instance of a descendant of @code{DescribedClass} can be can be
specified by surrounding it with the ``@code{<}'' and ``@code{>}''
operators immediately after the keyword naming the data.

A pointer to a single object can be read with free multiple keywords by
using value substitution (@pxref{ParsedKeyVal Value Substitution}).
This is accomplished by holding references to all objects once they are
read in.  This means that the user must let the @code{Ref} smart pointer
classes used by all @code{DescribedClass}'s manage the memory for
objects read in by @code{ParsedKeyVal}.  Thus, storage for all read
objects will not be freed until after the @code{ParsedKeyVal} instance
that read the class is deleted.
