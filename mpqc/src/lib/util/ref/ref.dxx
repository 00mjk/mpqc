
/**@name The Reference Library

It is fairly easy in C++ to create a pointer to an object that
actually references invalid memory.  One common way to do this
is to create an object with new and store that
object's pointer.  Then the pointer is given to another
object's member function as an argument which keeps a copy of
the pointer for future use.  After the member function
returns, the routine that originally created the object
delete's it, not knowing that another object has since
created a reference to the object.  The result of using the
delete'ed object is unpredictable and would likely be
a program crash.  It is up to the programmer to provide the
logic necessary to avoid this problem.  The programmer must
also deal with the problem of calling to delete
operator on any new'ed memory when it is no longer
referenced.

Reference counting is one technique that can be applied to
automate memory management.  In this approach, a count of how
many pointers point to an object is attached to that object.
This count is managed by a smart pointer class which mimics
the behavior of C++ pointers by providing
#operator->()#.  This class has a pointer to the
reference counted object and increments the reference count of
objects when they are assigned to it while decrementing the
counts of the objects that are displaced by these assigments.
The smart pointer class automatically delete's the
object when its reference count drops to zero.

A deficiency of this method is that unreferenced circular
lists are not automatically deleted.  Circular list
implementors must provide a mechanism to detect when the list
is dereferenced and then break the list's circularity to let
the automated reference mechanism finish the work.

The reference library provides smart pointers and a base class that
can be used to maintain reference counts to objects.  For an
object to be reference counted its class must inherit from
the VRefCount class.  This adds #sizeof(int)# bytes
of overhead per object and makes the destructor virtual (so a vtable
will be added to objects of the class, if there wasn't already a virtual
member in the class).

The smart pointers that maintain the reference counts are
provided by the Ref class template.  Users of
compilers that have problems with class templates can instead
use classes created with the cpp macros REF\_dec and
REF\_def.  These macros take the name of the reference counted
class as the only argument and declare the interface
and define the members of the new Ref class.
The REF\_dec macro takes a class name as an argument and
constructs a new class declaration which is formed by appending the
class name to Ref.  This macro would usually be invoked in the
same header file that gives the declaration for that reference counted
class.  The implementation of the members for this class are generated
by using the REF\_def which also takes the class name as the
argument.  This should be given in one of the source files relating to
that class and should not be placed in the header file.  The
REF\_dec macro must be followed by a semicolon.

*/

//@{

/**@name Customizing the Reference Counting Package

  The behaviour of the package can be modified at compile time
with the following five macros, each of which should be undefined, 0, or 1:

\begin{description}
\item[REF\_CHECK\_STACK]
  If this is 1, referenced objects are checked to see if they
  reside on the stack, in which case storage for the object is not managed,
  if management is enabled.
\item[REF\_CHECKSUM]
  If this is 1, checksums of the reference count are kept
  and checked to see if an object has been overwritten.
\item[REF\_MANAGE]
  If this is 1, the unmanage member is enabled.
\item[REF\_CHECK\_MAX\_NREF]
  If this is 1, the reference count is checked before
  it is incremented to make sure it isn't too big.
\item[REF\_CHECK\_MIN\_NREF]
  If this is 1, the reference count is checked before
  it is decremented to make sure it isn't already zero.
\end{description}

If a macro is undefined, then the behaviour is architecture
dependent---usually, the macro will be set to 1 in this case.
For maximum efficiency and for normal operation after the program is
debugged, compile with all of the above macros defined to zero.
This can also be done by defining REF\_OPTIMIZE.

  An include file can be used to set these options as well.  This has
the advantage that dependency checking will force an automatic
recompile of all affected files if the options change.  This is done
in the file scconfig.h, which is produced by the automated configuration
procedure.

  Note that all source code that uses references must be compiled with
the same value for REF\_CHECKSUM and REF\_MANAGE.
Changing these can change the storage layout and the interpretation of
the reference count data.

*/

/**@name A Reference Example

Following is a simple example of how to manage memory with reference
counts.

\begin{verbatim}
#include <util/container/ref.h>

class A: virtual public VRefCount {
};
REF_dec(A);

class B: public A {
};
REF_dec(B);

REF_def(A);
REF_def(B);

int
main()
{
  RefA a1(new A);
  RefA a2;

  // Create another reference to the A object pointed to by a1.
  a2 = a1;

  // Make a2 refer to a new A object.
  a2 = new A;

  // a2 was the only reference to the second A object, so setting
  // a2 to the null object will cause the second A object to be
  // deleted.
  a2 = 0;

  RefB b(new B);

  // RefA and RefB are not related by inheritance as are A and B,
  // so `a1 = b' will fail and the following must be used.  This
  // will also cause the first A object to be deleted.
  a1 = b.pointer();

  // The B object will be deleted here because all of the references
  // to it go out of scope and destroyed.
  return 0;
}
\end{verbatim}

*/

//@}

 */
