\documentstyle{web}
\begin{document}

@* Debugger control.  This package can arrange to start
up the debugger over the calling process.  You must
first call |debug_init|.  The debugger can then be
invoked {\it via} the entry |debug_start|.
|debug_init| also arranges to catch bus errors and
segmentation violations, and will start up the debugger
when one is caught.

Here is a banner giving the version number.
@c 
private char *rcsid = "$Id$";

@ Here is how this is to be used from |C|.  You must
call |debug_init| somewhere in your main program,
preferably early.  The string argument to |debug_init|
is the name of the executable file being debugged.
|debug_init| will arrange to catch various bad
signals---bus error and the like.  Instead of aborting,
as is the default behaviour, the |debug| package will
start up |dbxtool| over the offending process.  Among
the signals the package catches is the |HUP| signal.
Thus, if your process has run amok, you can go to
another window and type the shell command ``kill -HUP
{\it pid}'' which will cause your process (with process
id {\it pid}) to start a debugger over itself.

Another feature of |debug_init| is that if the
environment variable |DEBUGGING| is set, then a
debugger is started up at |debug_init| time.

@<Usage example.@> =
main (argc, argv)
int argc;
char **argv;
{
  debug_init (argv[0]); @/
  @<$\ldots$ other code.@>;
}

@ After this, any time that you detect an error, you
can start up the debugger yourself. The |debug_start|
routine takes a string as its single argument,
providing a string to be printed indicating from where
the debugger was invoked.  I usually give |banner| as
this string.  @<Usage example.@>= { if (trouble)
debug_start(banner);@/ if (other_trouble) debug_start
("Trouble"); }

@ Another use of the package is through my own version
of |"assert.h"|.  The usual behaviour of |assert| is to
|abort| on assertion failures.  My slightly modified
version instead calls |debug_start|.  Here is an
example where |assert| is used for range checking on
the variable |i|.

@<Usage example.@>=
#include "assert.h"
foo(i)
int i;
{
  assert (i > 0 && i < 100);@/
  @<$\ldots$ other code.@>;
}

@ This was just used in the usage example.
@<$\ldots$ other code.@>= {}

@* Administrivia.
My personal miscellaney of definitions.  

@d private=static
@d public=
@f private static
@f public static


@ Fix up some lint gripes.
@d Printf=(void) printf@
char *sprintf();
char *getenv();

@ Forward declarations.
@c
private int local_node;
private int debug_node;

@ We'll need these include files.
@c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>



@* The code.
We'll start with an  outline of the program.  
Compilation of the usage example section
is inhibited.
@c
@<Outer block declarations.@> @;@/
@<Support routines.@> @;@/
@<Public entry points.@> @;@/
#if 0
@<Usage example.@> @;@/
#endif

@ This routine |debug_init| takes the name of the
current object file (|argv[0]|) as its only argument, and
does several things. First, it squirrels away a copy
of the executable, since we'll need it later if we
actually need to fire up the debugger.
Next, it declares |handler| as the handler for
several signals.  These are signals that normally
cause the process to die, but |handler| will
fire up the debugger instead.

Finally, |debug_init| checks the environment variable
|DEBUGGING|.  If this is non-null, then we fork a
debugger at this point.

@<Public...@>= 
public debug_init(nm)
char *nm; 
{
    char *strcpy();
    (void) strcpy (name, nm);@/
#ifdef SIGBUS
    (void) signal (SIGBUS, handler);
#endif
    (void) signal (SIGSEGV, handler);
    (void) signal (SIGFPE, handler);
    (void) signal (SIGQUIT, handler);
    (void) signal (SIGINT, handler);
    (void) signal (SIGHUP, handler);@/
    if (getenv("DEBUGGING") && !debugger_running) debug_fork(nm);
    debug_node = -1;
    local_node = mynode0();
}

@ If multiple nodes have exceptions, it is nice to have a selected
node fork the debugger and let the rest sleep.  Given the
node number this will select only the given node for debugging.
If the given node number is |-1|, then all nodes are selected.
This is the default as set up by |debug_init|.  This routine
must be called after |debug_init|.

@<Public...@>=
public debug_on_node(node_number)
int node_number;
{
  debug_node = node_number;
}

@ This is where we squirrel away  the name of the executable.
@<Outer...@>=
private char name[128];

@ $\ldots$ and we need the signal defs.
@<Outer...@>=
#include <signal.h>

@ Here is a {\sc Fortran}-callable version.
Ironically, in {\sc Fortran}, we could
dispense with the required argument, since we can
get |argv[0]| with the |getarg| routine. 
@<Public...@>=
public debug_init_(n)
char *n;
{
  char *src = n;
  char *dst = name;
  while (*src && *src != ' ') *dst++ = *src++;
  *dst = 0;
  debug_init (name);
}


@  This  public routine |debug_start|,
first calls |breakpoint|, where |dbx|
has set a breakpoint if we are run from the debugger.  After
|breakpoint| returns, then we start up a debugger, if one is not
already running.

@<Public...@>=
public debug_start(s) char *s; {
    breakpoint();
    if ((local_node == debug_node) || (debug_node == -1)) {
      if (!debugger_running) debug_fork(s);
      }
    else {
      printf("exception on node %d -- sleeping\n",local_node);
      for (;;) sleep(3600);
      }
}
@ A {\sc Fortran} callable version.
@<Public...@>=
public debug_start_(s) char *s; {
    debug_start(s);
}


@ The |breakpoint| routine is just a place for the 
debugger to put a breakpoint.  If we generate an exception
while in the debugger, we want to avoid recursively starting
up a new one.  This is accomplished by calling the
routine |breakpoint| before starting up a new debugger.  If
we already have a debugger running, then it has
set a breakpoint here (from the dbx init file).
@<Support...@>=
private void breakpoint()
{
    return;
}

@ Here, we fork off a debugger over the current process.
The only argument is a string to be printed out indicating
who started up the debugger.
@<Support...@>=
private void debug_fork(s) char *s;{
    char initfile[128];
#if defined(I860)||defined(NCUBE)
    Printf ("Exiting on node %d because of \"%s\"...\n",
            local_node, s);@/
   exit(1);
#else
    Printf ("Forking a debugger on node %d because of \"%s\"...\n",
            local_node, s);@/
@.Forking a debugger...@>
    @<Create init file, leave file name in |initfile|.@>;@/
    @<Set files to close-on-exec.@>;@/
    @<Fork and wait for the debugger.@>;@/
    breakpoint();
#endif
}

@ We require an init file for |dbxtool|  to come up right.
After we fork off the debugger over ourselves, we'll wait for
the variable |debugger_running| to become non-zero. 
 We'll have the |dbx| init
file set it to one.  It his way, the proces to be debugged can
detect that the debugger is operational.  If we, instead, just 
proceeded with the computation, we might get quite far before the 
debugger could assert control.

We also set a breakpoint in the routine |breakpoint|, and before
anybody starts up a new debugger, we first call |breakpoint|.  In
this way we avoid recursive debuggers.

@<Create init file, leave file name in |initfile|.@>=
{
  FILE *ifile;
  char *strcpy(), *mktemp();

  (void) strcpy(initfile, "dbginit.XXXXXX");
  (void) mktemp(initfile);
  ifile = fopen (initfile, "w");
  (void) fprintf (ifile, "ignore TERM\n");
  (void) fprintf (ifile, "stop in breakpoint\n");
  (void) fprintf (ifile, "set debugger_running = 1\n");
  (void) fprintf (ifile, "cont\n");
  (void) fclose (ifile);
}

@  |stdin|, {\it etc.}, should be set to close-on-exec.
I don't really understand exactly why, but the debugger
works poorly otherwise.

@<Set files to close-on-exec.@>=
{
  fcntl(0, F_SETFD, 1);
  fcntl(1, F_SETFD, 1);
  fcntl(2, F_SETFD, 1);
}

@ For the above to work, we need this include file.
@<Outer...@>=
#include <fcntl.h>
#ifdef RS6000
#define F_SETFD 2
#endif

@ We fork off the debugger with the |system| routine, appending
an ampersand to the command line.  We them wait for the debugger
to start up. We do this by waiting for the variable |debugger_running|
to become one.  This works because the |dbxtool|
init file sets |debugger_running| to 1.

@<Fork and wait for the debugger.@>=
{
  int pid = getpid();
  char cmdstr[128];
  /* (void) sprintf (cmdstr, "/usr/sbin/cvd -pid %d &",  pid); */
  /* (void) sprintf (cmdstr, "xterm -e dbx -p %d -c %s &",pid,initfile); */
  (void) sprintf (cmdstr, "edge -p %d &",pid);
  {
    (void) system (cmdstr);
    printf ("forking \"%s\"\n",cmdstr);
    printf ("Waiting for debugger....\n"); fflush(stdout);
    @.Waiting for debugger...@>
    while (!debugger_running) ;
  }
  printf ("Continuing.\n");
@.Continuing.@>
}

@ Declare and initialize |debugger_running|.
@<Outer...@>=
private int debugger_running = 0;

@ The |handler| job is just to   catch signals, start 
up the debugger.
@<Support...@>=
#if !( defined(RS6000) && defined(STANFORD) )
private void handler(sig, code, scp, addr)
int sig, code;
struct sigcontext *scp;
char *addr;
#else
private void handler(sig)
int sig;
#endif
{
    Printf ("\n\nOoops, "); (void) fflush(stdout);
    @.Ooops,@>
    Printf ("signal %d -", sig); (void) fflush(stdout);
#ifdef SIGBUS
    if (sig == SIGBUS) Printf("BUS error!\n");
#endif
    if (sig == SIGSEGV) Printf ("Segmentation violation!\n");
    if (sig == SIGFPE) Printf ("Arithmetic exception!\n");
    if (sig == SIGINT) Printf ("Interrupt!\n");
    if (sig == SIGHUP) Printf ("HUP!\n");
    if (sig == SIGINT){
        char ans[4];
        (void) printf ("Do you want the debugger? ");
@.Do you want the debugger?@>
	(void) fflush (stdout);
	scanf ("%3s", ans);
	if (!strncmp(ans, "no", strlen(ans))) exit(1);
    }
    debug_start("signal handler"); 
}


