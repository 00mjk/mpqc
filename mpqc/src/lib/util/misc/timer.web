\documentstyle{web}
\begin{document}

@* Timing regions of a parallel program.  This is a
package to help you keep up with how much time each
processor of a parallel program spends in various timed
regions.  The routines exported from the package are
prefixed with |tim_|.  Thus, |tim_enter| is used to
declare the beginning of a region to be timed, and
|tim_exit| exits a region.  A timing region is
referred to by a {\it name}, which is just a character
string.

Here is a list of the available public routines:

|tim_enter (name)| --- Enter region |name|.

|tim_exit (name)| --- Exit region |name|.  Note that |name| must
be the name of the current region.  The old timing routines allowed
overlapping timing regions, but this is not permitted any longer.  The
regions must have a tree structure.

|tim_done ()| --- Exit the current region.

|tim_print (node_timings) | --- Print out the current elapsed times
in each region for each node.  The |node_timings| argument is
a boolean which is true if the times for each node is to be printed out.

|tim_stuff(name, value)| --- Set the accumulated time
for the named region to |value|.  I used this to
include a count of something in the timer table at the
end.  That is, the |value| I put into the ``region''
was, in fact, a count of some event.  Handy.


@ Here is the outline of the package.

@c 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tmpl.h>
#include <util/group/picl.h>
#define UTIL_ASSERT
#include <util/misc/assert.h>
#define TIMING
@<Outer block declarations.@> @;@/
#include <util/misc/timer.gbl>
#include <util/misc/timer.lcl>
@<Support routines.@> @;@/
@<Public routines.@> @;@/


@ This is the structure representing a
timing region.

@<Outer...@>=
struct region_struct {
  char *name;     /* The region name. */
  double total_time;    /* Total time inside the region so far. */
  double entry_time ;   /* The time we entered the region. */
  double max_time;
  double min_time;
  double sum_time;
  struct region_struct *across;
  struct region_struct *up;
  struct region_struct *down;
};
typedef struct region_struct region_t;

@ We'll keep up with the regions with an array of these
structures along with a count of the number of defined regions.

@<Outer...@>=
static region_t  *region_tree=NULL;
static region_t  *current_region=NULL;

@ Whenever the timing routines have been entered, further calls
to the timing routines must be deactivated.  The is done with
the |timing_active| variable.
@<Outer...@>=
static int timing_active = 1;

@ This routine enters the named region.  Its only
argument is the name of the region.  The |position_region|
routine will add the needed region to the list if desired.

@<Public ...@>=
GLOBAL_FUNCTION void
tim_enter (name)
char *name;
{
  region_t *I;

  if (!timing_active) return;
  timing_active = 0;

  if (!region_tree) region_tree = new_region(NULL,"top level");

  if (!current_region) {
    current_region = new_region(region_tree,name);
    }
  else {
    for (I = current_region->down; I!=NULL; I = I->across) {
      if (!strcmp(I->name,name)) { current_region = I; break; }
      }
    if (!I) current_region = new_region(current_region,name);
    }

  current_region->entry_time = clock0();
  timing_active = 1;
}

@ The PICL |clock0| routine returns the time in seconds as a |double|.
@<Outer...@>=
double clock0();

@ The |tree_action| routine needs these globals.
@<Outer...@>=
static int me;
static int tree_depth=0;
static FILE *timfp = stdout;
static char *double_fmt = "%8.2f";
static int nproc;

@ The |tim_exit| routine leaves a named region.
The region can be entered again, accumulating
the time.
The only argument is the name of the region to leave, which must
be the name of the current region.  The |tim_done| routine is
the same, except |tim_done| does not need the |name| argument.

@<Public...@>=
GLOBAL_FUNCTION void
tim_exit (name)
char *name;
{

  if (!timing_active) return;
  timing_active = 0;

  if (!current_region) {
    fprintf(stderr,"tim_exit: " 
                   "tried to leave \"%s\" while there is no current region\n",
                   name);
    tim_traceback();
    exit(1);
    }
  if (strcmp(current_region->name,name)) {
    fprintf(stderr,"tim_exit: tried to leave \"%s\" while in \"%s\"\n",
            name,current_region->name);
    tim_traceback();
    exit(1);
    }

  tim_done();
  timing_active = 1;
  }


@ The |tim_done| routine leaves the current region.
The region can be entered again, accumulating
the time.

@<Public...@>=
GLOBAL_FUNCTION void
tim_done ()
{
  double timenow;

  if (!current_region) {
    fprintf(stderr, "tim_done: there is no current region\n");
    exit(1);
    }

  timenow = clock0();
  /* The return value of clock0 gets reset sometimes on some machines. */
  if (timenow < current_region->entry_time)timenow=current_region->entry_time;

  current_region->total_time += (timenow - current_region->entry_time);

  current_region = current_region->up;

}


@ A handy routine to have is |tim_change|, which exits the current region,
and enters a new region.  The only 
argument is the name of the new region to enter.

@<Public...@>=
void tim_change (name)
char *name;  /* The name of the new region. */
{
  tim_done();
  tim_enter(name);
}

@  This prints out the timings for the various regions. Node
zero sents timing information requests to all other nodes and
waits for replies containing the timing information.

The single argument |node_timings| is a boolean indicating
whether or not we want the timings for each individual node
printed out or not.

@<Public...@>=
GLOBAL_FUNCTION void
tim_fprint(fp,node_timings)
FILE *fp;
int node_timings;
{
  double t;
  int host;
  region_t *I;

  if (!timing_active) return;
  timing_active = 0;

  if (!region_tree || !region_tree->down) {
    printf("tim_fprint: timing information is not available\n");
    }

  /* |nproc|, |timfp|, and |me| are needed by |tree_action| */
  timfp = fp;
  who0(&nproc,&me,&host);

  /* Accumulate the current regions. */
  t = clock0();
  for (I=current_region; I!=NULL; I=I->up) {
    I->total_time += (t - I->entry_time);
    I->entry_time = t;
    }

  if (nproc == 1) {
    /* If there is only one node, then only do the following. */
    fprintf(fp,"Timing information:\n");
    tree_action(region_tree->down,print_total);
    }
  else {
    /* Print out timings on each node. */
    if (node_timings) {
      begin_sequential();

      fprintf(fp,"Timings for node %d:\n",me);
      tree_action(region_tree->down,print_total);

      end_sequential();
      }

    tree_action(region_tree->down,get_node_data);
    if (me == 0) {
      fprintf(fp,"Minimum, maximum, and average times:\n");
      tree_action(region_tree->down,summarize);
      }
    }

  timing_active = 1;
}

@ This is like |tim_fprint|, but prints to |stdout|.
@<Public...@>=
GLOBAL_FUNCTION void
tim_print(node_timings)
int node_timings;
{
  tim_fprint(stdout,node_timings);
  }

@ These types are used for the node timing information and
for the node time printouts.

@<Outer...@>=
#define MTYPE_TIME_REQ 334
#define MTYPE_TIME_ACK 335
#define MTYPE_SEQU 590

@ The |tim_traceback| routine prints out a list of regions which
have been entered.  This is especially useful for debugging.

@<Public...@>=
GLOBAL_FUNCTION void
tim_traceback()
{
  region_t *I;

  if (!timing_active) return;
  timing_active = 0;

  printf("Region traceback:\n");
  for (I=current_region; I!=NULL; I=I->up) {
    printf("On %2d: name = \"%s\" entry_time = %f\n",
           mynode0(),I->name,I->entry_time);
    }

  timing_active = 1;
  }

@ Create a new region under |up|.
@<Support routines.@>=
LOCAL_FUNCTION region_t *
new_region(up,name)
region_t *up;
char *name;
{
  region_t *r;

  r = (region_t *)malloc(sizeof(region_t));
  assert(r);
  if (!up) {
    }
  else if (!up->down) {
    up->down = r;
    }
  else {
    region_t *I;
    for (I=up->down; I->across != NULL; I=I->across);
    I->across = r;
    }

  r->up = up;
  r->across = NULL;
  r->down = NULL;

  r->name = (char *)malloc(strlen(name)+1);
  assert(r->name);
  strcpy(r->name,name);
  r->total_time = r->entry_time = r->max_time = r->min_time = r->sum_time = 0.0;

  return r;
  }

@ Transverse a |region_t| tree and perform some action on that tree.
@<Support routines.@>=
LOCAL_FUNCTION void
tree_action(tree,func)
region_t *tree;
void (*func)(region_t *); 
{
  region_t *I;

  tree_depth++;
  for (I=tree; I!=NULL; I=I->across) {
    func(I);
    tree_action(I->down,func);
    }
  tree_depth--;
  }

@
@<Support routines.@>=
LOCAL_FUNCTION void
print_total(r)
region_t *r;
{
  int i;
  for (i=0; i<tree_depth; i++) { fprintf(timfp,"  "); }
  fprintf(timfp,"%s ",r->name);
  pad(strlen(r->name) + 1 + 2 * tree_depth);
  fprintf(timfp,double_fmt,r->total_time);
  fprintf(timfp,"\n");
  }

@
@<Support routines.@>=
LOCAL_FUNCTION void
get_node_data(r)
region_t *r;
{
  extern int mtype_get();
  r->max_time = r->total_time;
  r->min_time = r->total_time;
  r->sum_time = r->total_time;
  gmin0(&r->min_time,1,5,mtype_get(),0);
  gmax0(&r->max_time,1,5,mtype_get(),0);
  gsum0(&r->sum_time,1,5,mtype_get(),0);
  }

@
@<Support routines.@>=
LOCAL_FUNCTION void
summarize(r)
region_t *r;
{
  int i;
  for (i=0; i<tree_depth; i++) { fprintf(timfp,"  "); }
  fprintf(timfp,"%s ",r->name);
  pad(strlen(r->name) + 1 + 2 * tree_depth);
  fprintf(timfp,double_fmt,r->min_time);
  fprintf(timfp," ");
  fprintf(timfp,double_fmt,r->max_time);
  fprintf(timfp," ");
  fprintf(timfp,double_fmt,r->sum_time/nproc);
  fprintf(timfp,"\n");
  }

@ This is used to line up the data in the printout.
@<Support routines.@>=
LOCAL_FUNCTION void
pad(taken)
int taken;
{
  int i;
  int distance;
 
  distance = 30-taken;
  if (distance < 0) distance = 0;

  for (i=0; i<distance; i++) fprintf(timfp," ");
  }

@ The |begin_sequential| and |end_sequential| routines do things
one node at a time.
@<Support routines.@>=
LOCAL_FUNCTION void
begin_sequential ()
{
  int val;
  if (mynode0() == 0) return;
  recv0 ((char *) &val, 1, MTYPE_SEQU);
}
LOCAL_FUNCTION void
end_sequential ()
{
  int val;
  int nproc,me,host;
  who0(&nproc,&me,&host);
  send0 ((char *) &val, 1, MTYPE_SEQU, (me + 1)%nproc);
  if (me == 0) {
    recv0 ((char *) &val, 1, MTYPE_SEQU);
  }
}

