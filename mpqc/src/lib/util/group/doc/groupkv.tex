
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The \clsnm{MessageGrp} Class}
\label{MessageGrp}\index{MessageGrp}

The \clsnm{MessageGrp} abstract class provides
a mechanism for moving data and objects between
nodes in a parallel machine.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The \clsnm{ProcMessageGrp} Class}
\label{ProcMessageGrp}\index{ProcMessageGrp}

The \clsnm{ProcMessageGrp} class provides
a simple single processor implementation of
the \clsnmref{MessageGrp} class.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The \clsnm{ShmMessageGrp} Class}
\label{ShmMessageGrp}\index{ShmMessageGrp}

The \clsnm{ShmMessageGrp} class is an implementation of
\clsnmref{MessageGrp} that allows multiple process to be
started that communication with shared memory.  This
only provides improved performance if you have multiple
CPU's in a symmetric multiprocessor configuration.  Nonetheless,
it is quite useful on a single CPU for tracking down bugs.

The \clsnm{ShmMessageGrp} \clsnmref{KeyVal} constructor takes
a single argument that specifies the number of processors.
Here is an example of a \clsnmref{ParsedKeyVal} input that
creates a \clsnm{ShmMessageGrp} that runs on four processors.
\begin{alltt}
message<\clsnm{ShmMessageGrp}>: n = 4
\end{alltt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The \clsnm{MemoryGrp} Class}
\label{MemoryGrp}\index{MemoryGrp}

The \clsnm{MessageGrp} abstract class provides a way of accessing
distributed memory in a parallel machine.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The \clsnm{ThreadGrp} Class}
\label{ThreadGrp}\index{ThreadGrp}

The \clsnm{ThreadGrp} abstract class provides a way of manipulating
multiple threads of control in a single address space.
