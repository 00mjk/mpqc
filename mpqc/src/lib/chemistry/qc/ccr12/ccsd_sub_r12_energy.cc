//
// ccsd_sub_r12_energy.cc 
//
// Copyright (C) 2009 Toru Shiozaki
//
// Author: Toru Shiozaki <shiozaki@qtp.ufl.edu>
// Maintainer: TS
//
// This file is part of the SC Toolkit.
//
// The SC Toolkit is free software; you can redistribute it and/or modify
// it under the terms of the GNU Library General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.
//
// The SC Toolkit is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Library General Public License for more details.
//
// You should have received a copy of the GNU Library General Public License
// along with the SC Toolkit; see the file COPYING.LIB.  If not, write to
// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
//
// The U.S. Government is granted a limited license as per AL 91-7.
//
  
// This is a C++ code generated by SMITH
  
#include <algorithm>
#include <chemistry/qc/ccr12/ccsd_sub_r12_energy.h>
#include <chemistry/qc/ccr12/tensor.h>
using namespace sc;
  
  
CCSD_SUB_R12_ENERGY::CCSD_SUB_R12_ENERGY(CCR12_Info* info):z(info){};
CCSD_SUB_R12_ENERGY::~CCSD_SUB_R12_ENERGY(){};
  
  
  
void CCSD_SUB_R12_ENERGY::compute_amp(Ref<Tensor>& x, Ref<Tensor>& y, Ref<Tensor>& out){ //k_i0_offset,z->in.at(0),z->x2()=>z->y2()
  
  if (out->is_this_local(0L)) { // unfortunately this is evaluated on one node... 
   if (z->irrep_e()==(z->irrep_t()^z->irrep_t())) { 
    long dimc=1; 
    double* k_c_sort=z->mem()->malloc_local_double(dimc); 
    std::fill(k_c_sort,k_c_sort+(size_t)dimc,0.0); 
    for (long h1b=0L;h1b<z->noab();++h1b) { 
     for (long h2b=h1b;h2b<z->noab();++h2b) { 
      for (long h3b=0L;h3b<z->noab();++h3b) { 
       for (long h4b=h3b;h4b<z->noab();++h4b) { 
        if (z->get_spin(h1b)+z->get_spin(h2b)==z->get_spin(h3b)+z->get_spin(h4b)) { 
         if ((z->get_sym(h1b)^(z->get_sym(h2b)^(z->get_sym(h3b)^z->get_sym(h4b))))==z->irrep_t()) { 
          long h1b_0,h2b_0,h3b_0,h4b_0; 
          z->restricted_4(h1b,h2b,h3b,h4b,h1b_0,h2b_0,h3b_0,h4b_0); 
          long h3b_1,h4b_1,h1b_1,h2b_1; 
          z->restricted_4(h3b,h4b,h1b,h2b,h3b_1,h4b_1,h1b_1,h2b_1); 
          long dim_common=z->get_range(h1b)*z->get_range(h2b)*z->get_range(h3b)*z->get_range(h4b); 
          long dima0_sort=1L; 
          long dima0=dim_common*dima0_sort; 
          long dima1_sort=1L; 
          long dima1=dim_common*dima1_sort; 
          if (dima0>0L && dima1>0L) { 
           double* k_a0_sort=z->mem()->malloc_local_double(dima0); 
           double* k_a0=z->mem()->malloc_local_double(dima0); 
           y->get_block(h4b_0+z->noab()*(h3b_0+z->noab()*(h2b_0+z->noab()*(h1b_0))),k_a0); 
           z->sort_indices4(k_a0,k_a0_sort,z->get_range(h1b),z->get_range(h2b),z->get_range(h3b),z->get_range(h4b),3,2,1,0,+1.0,false); 
           z->mem()->free_local_double(k_a0); 
           double* k_a1_sort=z->mem()->malloc_local_double(dima1); 
           double* k_a1=z->mem()->malloc_local_double(dima1); 
           x->get_block(h2b_1+z->noab()*(h1b_1+z->noab()*(h4b_1+z->noab()*(h3b_1))),k_a1); 
           z->sort_indices4(k_a1,k_a1_sort,z->get_range(h3b),z->get_range(h4b),z->get_range(h1b),z->get_range(h2b),1,0,3,2,+1.0,false); 
           z->mem()->free_local_double(k_a1); 
           double factor=1.0; 
           if (h1b==h2b) { 
            factor=factor/2.0; 
           } 
           if (h3b==h4b) { 
            factor=factor/2.0; 
           } 
           z->smith_dgemm(dima0_sort,dima1_sort,dim_common,factor,k_a0_sort,dim_common,k_a1_sort,dim_common,1.0,k_c_sort,dima0_sort); 
           z->mem()->free_local_double(k_a1_sort); 
           z->mem()->free_local_double(k_a0_sort); 
          } 
         } 
        } 
       } 
      } 
     } 
    } 
    double* k_c=z->mem()->malloc_local_double(dimc); 
    z->sort_indices0(k_c_sort,k_c,1.0,false); 
    out->add_block((0),k_c); 
    z->mem()->free_local_double(k_c); 
    z->mem()->free_local_double(k_c_sort); 
   } 
  } 
  z->mem()->sync(); 
} 

