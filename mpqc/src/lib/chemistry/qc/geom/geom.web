\documentstyle[fleqn]{web}
\begin{document}

\def\topofcontents
  {\centerline{
    \titlefont {\ttitlefont libgeom}: A geometry optimization library.}
   \bigskip
   \centerline{\bf Curtis L. Janssen}
  \vfill}

\newcommand{\Partial}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\Half}{\frac{1}{2}}
\newcommand{\Norm}[1]{(\SelfDot{#1})^\Half}
\newcommand{\SelfDot}[1]{\Vec{#1}\cdot{\Vec{#1}}}
\newcommand{\Vec}[1]{\bar{#1}}
\newcommand{\Mat}[1]{\bar{#1}}

\def\botofcontents{\vfill
\center{\bf Disclaimer}

\begin{quotation}

Copyright \copyright\ 1991, Sandia Corporation. The U.S. Government retains
a limited license in this software.

The U.S. Government retains, in this software, a paid-up,
nonexclusive, irrevocable worldwide license to reproduce, prepare
derivative works, perform publicly and display publicly by or for the
Government, including the right to distribute to other Government
contractors.

Neither the United States, the U.S. Dept. of Energy, nor any of their
employees, makes any warranty, express or implied, or assumes any
legal liability or responsibility for the accuracy, completeness, or
usefulness of any information, apparatus, product, or product
disclosed, or represents that its use would not infringe privately
owned rights.

Export Controlled. Not to be exported outside the U.S. and Canada
without prior approval of the Bureau of Export Administration, U.S.
Department of Commerce.

\end{quotation}
}

\def\webtitle{\.{libgeom}: A geometry optimization library.}

@* Introduction.
The program is divided as follows:

@c
@<Include files.@> @;@/
@<Global variables.@> @;@/
@<Global functions.@> @;@/
@<Conjugate gradient method.@> @;@/
@<Utility functions.@> @;@/

@* Include files and global variables.
@ Include files for the C library.
@<Include files.@>=
#include <stdio.h>
#include <math.h>

@ The C prototype generation facility, \.{tmpl}, is used in this file and
the libraries, so we must include its header file.
@<Include files.@>=
#include <tmpl.h>

@ The sgen library is used for some file I/O.
@<Include files.@>=
#include <util/sgen/sgen.h>

@ The \.{libmath} library provides support for several of the data types used
here and by the \.{libint} library.
@<Include files.@>=
#include <math/array/math_lib.h>


@ The input will be parsed with version 2 of the input parser, \.{libipv2}.
@<Include files.@>=
#include <util/ipv2/ip_libv2.h>

@ The integrals library's include file is needed to provide |centers_t|,
which is where the geometry information is stored.
@<Include files.@>=
#include <chemistry/qc/intv2/int_libv2.h>

@ The return codes from these routines are contained in |"retcodes.h"|.
@<Include files.@>=
#include "retcodes.h"

@ The prototypes for the global and local function definitions are found
in |geom.gbl| and |geom.lcl|, respectively.
@<Include files.@>=
#include "geom.gbl"
#include "geom.lcl"

@ These constants correspond to optimization methods.
@<Global variables.@>=
#define OPT_FLETCHER_REEVES 1
#define OPT_POLAK_RIBIERE 2
#define OPT_BFGS 3
#define OPT_STEEPEST_DESCENT 4

@ These constants correspond to coordinate transformation methods.
@<Global variables.@>=
#define COOR_CARTESIAN 1
#define COOR_PROJ_CARTESIAN 2
#define COOR_ZMAT 3
#define COOR_INTERNAL 4

@ The output file and the error file pointers are declared here.  These
are set up by the call to |geom_initialize|.
@<Global variables.@>=
static FILE *errfp;
static FILE *outfp;

@ Default values for the string parameters are set here.
@<Global variables.@>=
static char *defaultrestartfile = "geom.restart";
static char *defaultopt = "Polak-Ribiere";

@ The centers information is needed so that the new geometries can
be copied into it and the original geometry can be obtained from it.
@<Global variables.@>=
static centers_t *centers;

@ Values of the input parameters are placed into global memory by
|geom_initialize|.
@<Global variables.@>=
static char *restartfile;
static int grad_for_line_search;
static double min_f;
static int opt,coor;
static double crms,cmax,irms,imax;
static int restart;

@ Values needed for keeping track of the optimization.
@<Global variables.@>=
static int havehessian;
static int havegradient;
static int lastreturncode;
static int lastiteration;
static int laststate;
static double lastenergy;
static double x0;
static double x1;
static double g0;
static double g1;
static double_vector_t lastgeometry;
static double_vector_t lasth;
static double_vector_t lastg;
static double thisenergy;
static double_vector_t tmpncart;
static double_vector_t thisgradient;
static double_vector_t thisgeometry;
static double_matrix_t thishessian;

@ The number of coordinates involved in the optimization.
The number of Cartesian coordinates, $3 n_atom$, is held in |ncart|
and the actual number of coordinates optimized in held in |ncoor|.
@<Global variables.@>=
static int ncoor;
static int ncart;

@ To give this package the ability to restart and to be called by an
external routine each time a geometry update is needed, some of the
geometry update methods have been implemented as finite state machines.
Each state examines the |geom_update| input parameters to determine
what state should be entered next.  The current state is automatically
kept in the restart file to facilitate smooth recovery from premature
termination of the geometry optimization process.
@<Global variables.@>=
#define STATE_BEGIN 1
#define STATE_GRADIENT 2
#define STATE_ENERGY 3
#define STATE_LINEMIN 4


@* Global functions.

@ This routine must be called before any other from this library.
The input parsing routines must have been called already to parse
the input.  This library only uses the input information in
|geom_initialize|, which copies this information into global memory.

@<Global functions.@>=
GLOBAL_FUNCTION int
geom_initialize(outfile, errfile, cs)
FILE *outfile;
FILE *errfile;
centers_t *cs;
{
  char *optstring;
  char *coorstring;

  @<Initialize the global pointers.@> @;@/
  @<Read the input parameters.@> @;@/
  @<Print the input parameters.@> @;@/
  @<Compute the number of coordinates in the system.@> @;@/
  @<Initialize global arrays.@> @;@/
  @<Read restart information.@> @;@/
  @<Allocate storage for global arrays.@> @;@/
  if (lastiteration>0) {
    fprintf(outfp,"Geometry optimization restarting on iteration %d.\n",
            lastiteration);
    @<Select the inverse geometry transformation.@> @;@/
    @<Put the geometry into the |centers| structure.@> @;@/
    }

  return lastreturncode;
}


@ @<Initialize the global pointers.@>=
{
  if (outfile) outfp = outfile;
  else         outfp = stdout;

  if (errfile) errfp = errfile;
  else         errfp = stderr;

  centers = cs;
}

@ @<Read the input parameters.@>=
{
  char keyword[256];
#ifdef NCUBE
  char *doublefmt = "%f";
#else
  char *doublefmt = "%lf";
#endif

  @<Default input parameters.@> @;@/

  ip_cwk_push();
  ip_cwk_clear();
  ip_cwk_add(":geometry");

  ip_value("method",&optstring,0);

  @<Convert the optstring to |opt|.@> @;@/

  ip_cwk_push();
  ip_cwk_clear();
  ip_cwk_add(":geometry:default");
  sprintf(keyword,":geometry:%s",optstring);
  ip_cwk_add(keyword);
  ip_data("convergence:rms",doublefmt,&crms,0);
  ip_data("convergence:max",doublefmt,&cmax,0);
  ip_data("improvement:rms",doublefmt,&irms,0);
  ip_data("improvement:max",doublefmt,&imax,0);
  ip_string("restartfile",&restartfile,0);
  ip_boolean("restart",&restart,0);

  @<Default value of |coorstring| depends on |opt|.@> @;@/

  ip_value("coordinates",&coorstring,0);

  @<Convert the |coorstring| to |coor|.@> @;@/

  /* |opt| dependent input paramenters. */
  switch(opt) {
    case OPT_FLETCHER_REEVES:
    case OPT_POLAK_RIBIERE:
    case OPT_STEEPEST_DESCENT:
      ip_boolean("gradient_for_line_search",&grad_for_line_search,0);
      ip_data("min_f","%lf",&min_f,0);
      break;
    }

  ip_cwk_pop();
  ip_cwk_pop();
}

@ @<Print the input parameters.@>=
{
  fprintf(outfp,"The geometry update library input parameters:\n");
  fprintf(outfp,"  :geometry:method = %s\n",optstring);
  fprintf(outfp,"  :geometry:%s:coordinates = %s\n",optstring,coorstring);
  fprintf(outfp,"  :geometry:%s:restartfile = %s\n",optstring,restartfile);
  fprintf(outfp,"  :geometry:%s:restart = %d\n",optstring,restart);
  fprintf(outfp,"  :geometry:%s:convergence:rms = %20.12e\n",optstring,crms);
  fprintf(outfp,"  :geometry:%s:convergence:max = %20.12e\n",optstring,cmax);
  fprintf(outfp,"  :geometry:%s:improvement:rms = %20.12e\n",optstring,irms);
  fprintf(outfp,"  :geometry:%s:improvement:max = %20.12e\n",optstring,imax);
  fflush(outfp);

  /* |opt| dependent input paramenters. */
  switch(opt) {
    case OPT_FLETCHER_REEVES:
    case OPT_POLAK_RIBIERE:
    case OPT_STEEPEST_DESCENT:
      fprintf(outfp,"  :geometry:%s:gradient_for_line_search = %d\n",
              optstring,grad_for_line_search);
      fprintf(outfp,"  :geometry:%s:min_f = %12.8f\n",
              optstring,min_f);
      break;
    }
}

@ @<Default input parameters.@>=
{
  grad_for_line_search = 1;
  optstring = defaultopt;
  restartfile = defaultrestartfile;
  crms = 0.0001;
  cmax = 0.0001;
  irms = 0.1;
  imax = 0.1;
  restart = 1;
  min_f = 0.1;
}

@ @<Convert the optstring to |opt|.@>=
{
  if (!strcmp(optstring,"Polak-Ribiere")) {
    opt = OPT_POLAK_RIBIERE;
    }
  else if (!strcmp(optstring,"SteepestDescent")) {
    opt = OPT_STEEPEST_DESCENT;
    }
  else {
    fprintf(errfp,"libgeom: Unknown optimization method\n");
    exit(1);
    }
}

@ @<Convert the |coorstring| to |coor|.@>=
{
  if (!strcmp(coorstring,"cartesian")) {
    coor = COOR_CARTESIAN;
    }
  else {
    fprintf(errfp,"libgeom: Unknown coordinate system for optimization.\n");
    return GEOM_ABORT;
    }
}

@ The user may override this default for |cartesian| in the input.  The
results of doing this are unpredictable, especially when using
cartesian coordinates for something which wants linearly independent
coordinates.
@<Default value of |coorstring| depends on |opt|.@>=
{
  switch (opt) {
    case OPT_FLETCHER_REEVES:
    case OPT_POLAK_RIBIERE:
    case OPT_STEEPEST_DESCENT:
      coorstring = "cartesian";
    }
}

@ This computes the global variable |ncoor|, which holds the number
of coordinates being optimized.  This value could be either the
number of Cartesian coordinates or the number of linearly independent
coordinates, depending on the optimization method we are using.
For now it can only be the number of Cartesian coordinates.
@<Compute the number of coordinates in the system.@>=
{
  ncart = centers->n * 3;
  ncoor = ncart;
}

@ This initializes global arrays.  The arrays have to initialized so
that when the time comes to allocate storage for them, we can see
have storage has already been allocated with the ``Read restart
information'' code.
@<Initialize global arrays.@>=
{
  init_double_vector(&lastgeometry);
  init_double_vector(&lasth);
  init_double_vector(&lastg);
  init_double_vector(&tmpncart);
  init_double_vector(&thisgeometry);
  init_double_vector(&thisgradient);
  init_double_matrix(&thishessian);
  }

@ This allocates storage needed for global working arrays.  Each array
is tested to make sure that it has not already been allocated, since
this might have been done by the ``Read restart information'' code.
@<Allocate storage for global arrays.@>=
{
  if (!lastgeometry.n) allocbn_double_vector(&lastgeometry,"n",ncoor);
  if (!tmpncart.n) allocbn_double_vector(&tmpncart,"n",ncart);
  if (!thisgeometry.n) allocbn_double_vector(&thisgeometry,"n",ncoor);
  if (!thisgradient.n) allocbn_double_vector(&thisgradient,"n",ncoor);
  /* Storage for thishessian will not be allocated for now. */
  switch (opt) {
    case OPT_FLETCHER_REEVES:
    case OPT_POLAK_RIBIERE:
    case OPT_STEEPEST_DESCENT:
      if (!lasth.n) allocbn_double_vector(&lasth,"n",ncoor);
      if (!lastg.n) allocbn_double_vector(&lastg,"n",ncoor);
      break;
    }
}

@ Here the restart information is written out. Nothing is
written if either |restart == 0| or the |restartfile| cannot
be opened with write access.
@<Write restart information.@>=
{
  FILE *restartfp;
  int offset;

  if (restart && (restartfp = fopen(restartfile,"w"))) {
    offset = 0;
    fwrite_int(restartfp,&lastiteration,&offset,sizeof(int));
    fwrite_int(restartfp,&laststate,&offset,sizeof(int));
    fwrite_int(restartfp,&lastreturncode,&offset,sizeof(int));
    fwrite_double(restartfp,&lastenergy,&offset,sizeof(double));
    fwrite_double(restartfp,&thisenergy,&offset,sizeof(double));
    fwrite_double_vector(restartfp,&lastgeometry,&offset);
    fwrite_double_vector(restartfp,&thisgeometry,&offset);
    switch (opt) {
      case OPT_FLETCHER_REEVES:
      case OPT_POLAK_RIBIERE:
      case OPT_STEEPEST_DESCENT:
        fwrite_double(restartfp,&x0,&offset,sizeof(double));
        fwrite_double(restartfp,&x1,&offset,sizeof(double));
        fwrite_double(restartfp,&g0,&offset,sizeof(double));
        fwrite_double(restartfp,&g1,&offset,sizeof(double));
        fwrite_double_vector(restartfp,&lasth,&offset);
        fwrite_double_vector(restartfp,&lastg,&offset);
        break;
      }
    fclose(restartfp);
    }
}

@ @<Read restart information.@>=
{
  FILE *restartfp;
  int offset;

  if (restart && (restartfp = fopen(restartfile,"r"))) {
    offset = 0;
    fread_int(restartfp,&lastiteration,&offset,sizeof(int));
    fread_int(restartfp,&laststate,&offset,sizeof(int));
    fread_int(restartfp,&lastreturncode,&offset,sizeof(int));
    fread_double(restartfp,&lastenergy,&offset,sizeof(double));
    fread_double(restartfp,&thisenergy,&offset,sizeof(double));
    fread_double_vector(restartfp,&lastgeometry,&offset);
    fread_double_vector(restartfp,&thisgeometry,&offset);
    switch (opt) {
      case OPT_FLETCHER_REEVES:
      case OPT_POLAK_RIBIERE:
      case OPT_STEEPEST_DESCENT:
        fread_double(restartfp,&x0,&offset,sizeof(double));
        fread_double(restartfp,&x1,&offset,sizeof(double));
        fread_double(restartfp,&g0,&offset,sizeof(double));
        fread_double(restartfp,&g1,&offset,sizeof(double));
        fread_double_vector(restartfp,&lasth,&offset);
        fread_double_vector(restartfp,&lastg,&offset);
        break;
      }
    fclose(restartfp);
    }
  else {
    lastiteration = 0;
    laststate = STATE_BEGIN;
    switch (opt) {
      case OPT_FLETCHER_REEVES:
      case OPT_POLAK_RIBIERE:
      case OPT_STEEPEST_DESCENT:
        lastreturncode = GEOM_COMPUTE_GRADIENT;
        break;
      }
    }
}

@ This routine is called to update the geometry in the centers structure.
If the |gradient| or |hessian| are not known a |NULL| pointer should be
passed in their place.  If a |NULL| pointer is substituted for a required
quantity, then trouble will result.  Which quantities are required depend
on the optimization method being used.  Note that here |gradient| and
|hessian| refer to the exact quantities, not approximations.
Currently, if |hessian != NULL|, then a lot more work than necessary
was done.
@<Global functions.@>=
GLOBAL_FUNCTION int
geom_update(energy,gradient,hessian)
double energy;
double_matrix_t *gradient;
double_matrix_t *hessian;
{
  int retcode;

  lastiteration++;
  fprintf(outfp,"geom_update: iteration %d\n",lastiteration);

  /* |debug_start("in geom_update");| */

  lastenergy = thisenergy;
  thisenergy = energy;
  if (gradient) {
    havegradient = 1;
    @<Select the gradient transformation.@> @;@/
    }

  else {
    havegradient = 0;
    }
  if (hessian) {
    havehessian = 1;
    @<Select the hessian transformation.@> @;@/
    }
  else {
    havehessian = 0;
    }

  if ((retcode = grad_converged()) != GEOM_NOTDONE) return retcode;

  @<Get the geometry from the |centers| structure.@> @;@/
  @<Select the geometry transformation.@> @;@/

  switch (opt) {
    case OPT_FLETCHER_REEVES:
    case OPT_POLAK_RIBIERE:
    case OPT_STEEPEST_DESCENT:
      retcode = conj_grad();
      break;
    }

  @<Write restart information.@> @;@/
  @<Select the inverse geometry transformation.@> @;@/
  @<Write the geom.ipv2 file.@> @;@/
  @<Put the geometry into the |centers| structure.@> @;@/

  return retcode;
}

@ @<Select the gradient transformation.@>=
{
  int i,j;
  int icart = 0;

  /* Convert the gradient matrix into the gradient vector. */
  for (i=0; i<gradient->n2; i++) {
    for (j=0; j<gradient->n1; j++) {
      tmpncart.d[icart++] = gradient->d[j][i];
      }
    }
  /* Convert the cartesian gradient into the needed gradient. */
  if (coor == COOR_CARTESIAN) {
    for (i=0; i<tmpncart.n; i++) {
      thisgradient.d[i] = tmpncart.d[i];
      }
    }
  else {
    fprintf(errfp,"Can only handle cartesian optimizations\n");
    exit(1);
    }
}

@ @<Select the hessian transformation.@>=
{
  fprintf(errfp,"The hessian was not NULL--libgeom will abort\n");
  exit(1);
}

@ @<Select the geometry transformation.@>=
{
  int i;

  switch (coor) {
    case COOR_CARTESIAN:
      for (i=0; i<tmpncart.n; i++) {
        thisgeometry.d[i] = tmpncart.d[i];
        }
    }
}

@ @<Select the inverse geometry transformation.@>=
{
  int i;

  switch (coor) {
    case COOR_CARTESIAN:
      for (i=0; i<thisgeometry.n; i++) {
        tmpncart.d[i] = thisgeometry.d[i];
        }
      break;
    }
}

@ @<Get the geometry from the |centers| structure.@>=
{
  int i,j;
  int icart=0;

  for (i=0; i<centers->n; i++) {
    for (j=0; j<3; j++) {
      tmpncart.d[icart++] = centers->center[i].r[j];
      }
    }
}

@ The geom.ipv2 file contains geometry information that can be directly
copied into the users input file for restarting without the geom.restart
file.  Also, utility program can convert the information in the geom.ipv2
file into input for other programs.  The geometry written is the last
geometry actually ran.  The centers structure, from which this obtains
its data, is not updated until after this information is written to
geom.ipv2.
@<Write the geom.ipv2 file.@>=
{
   int i;
   FILE *geomipv2;
   geomipv2 = fopen("geom.ipv2","w");
   if (geomipv2) {
     fprintf(geomipv2,"%% Energy = %20.14e\n",thisenergy);
     fprintf(geomipv2,"  centers:(\n");
     fprintf(geomipv2,"    center: [\n");
     for (i=0; i<centers->n; i++) {
       fprintf(geomipv2,"      (r = [ % 16.8f % 16.8f % 16.8f ])\n",
               centers->center[i].r[0],
               centers->center[i].r[1],
               centers->center[i].r[2]);
       }
     fprintf(geomipv2,"      ]\n");
     fprintf(geomipv2,"    center: [\n");
     for (i=0; i<centers->n; i++) {
       fprintf(geomipv2,"      (atom = %s)\n",centers->center[i].atom);
       }
     fprintf(geomipv2,"      ]\n");
     fprintf(geomipv2,"    center: [\n");
     for (i=0; i<centers->n; i++) {
       fprintf(geomipv2,"      (basis = %s)\n",centers->center[i].basis.name);
       }
     fprintf(geomipv2,"      ]\n");
     fprintf(geomipv2,"    )\n");
     fclose(geomipv2);
     }
}

@ @<Put the geometry into the |centers| structure.@>=
{
  int i,j;
  int icart=0;

  for (i=0; i<centers->n; i++) {
    for (j=0; j<3; j++) {
      centers->center[i].r[j] = tmpncart.d[icart++];
      }
    }
}

@ Free storage for all of the global arrays.
@<Global functions.@>=
GLOBAL_FUNCTION VOID
geom_done()
{
  free_double_vector(&lastgeometry);
  free_double_vector(&lasth);
  free_double_vector(&lastg);
  free_double_vector(&tmpncart);
  free_double_vector(&thisgeometry);
  free_double_vector(&thisgradient);
  free_double_matrix(&thishessian);
}

@* The conjugate gradient update methods.

@ @<Conjugate gradient method.@>=
LOCAL_FUNCTION int
conj_grad()
{
  int retcode;

  if (   laststate == STATE_LINEMIN
      && grad_for_line_search
      && line_search_converged(&lasth,&lastg)) {
    laststate = STATE_GRADIENT;
    }

  if (laststate == STATE_BEGIN) {
    @<Initialize the conjugate gradient procedure.@> @;@/
    laststate = STATE_GRADIENT;
    }
  else if (laststate == STATE_GRADIENT) {
    if (opt == OPT_STEEPEST_DESCENT) {
      fprintf(outfp,"Taking a steepest descent step.\n");
      }
    else {
      fprintf(outfp,"Taking a conjugate gradient step.\n");
      }
    @<Take a new conjugate gradient step.@> @;@/
    }

  if (grad_for_line_search) {
    if (laststate == STATE_GRADIENT) {
      @<Take the first step in a line minimization.@> @;@/
      laststate = STATE_LINEMIN;
      }
    else {
      @<Line minimization with gradient.@> @;@/
      }
    retcode = GEOM_COMPUTE_GRADIENT;
    }
  else {
    /* This code doesn't seem to work. */
    if (laststate == STATE_GRADIENT) {
      @<Take the first step in a line minimization.@> @;@/
      laststate = STATE_ENERGY;
      retcode = GEOM_COMPUTE_ENERGY;
      }
    else if (laststate == STATE_ENERGY) {
      @<Take the second step without a gradient in a line minimization.@> @;@/
      laststate = STATE_GRADIENT;
      retcode = GEOM_COMPUTE_GRADIENT;
      }
    else {
      fprintf(errfp,"libgeom: bad state in conj_grad\n");
      retcode = GEOM_ABORT;
      }
    }
  return retcode;
}

@ @<Initialize the conjugate gradient procedure.@>=
{
  int i;
  for (i=0; i<thisgradient.n; i++) {
    lasth.d[i] = (lastg.d[i] = thisgradient.d[i]);
    }
}

@ @<Take a new conjugate gradient step.@>=
{
  int i;
  double lastdotg=0.0,thisdotg=0.0;
  double gamma;

  for (i=0; i<lastg.n; i++) {
    lastdotg += lastg.d[i]*lastg.d[i];
    if (opt == OPT_FLETCHER_REEVES) {
      thisdotg += thisgradient.d[i]*thisgradient.d[i];
      }
    else {
      thisdotg += (thisgradient.d[i]-lastg.d[i])*thisgradient.d[i];
      }
    }

  gamma = thisdotg/lastdotg;

  for (i=0; i<lasth.n; i++) {
    if (opt == OPT_STEEPEST_DESCENT) {
      lasth.d[i] = thisgradient.d[i];
      }
    else {
      lasth.d[i] = gamma * lasth.d[i] + thisgradient.d[i];
      }
    lastg.d[i] = thisgradient.d[i];
    }
}

@ The does the line minimization, always using gradients.  It is designed
to be robust.
@<Line minimization with gradient.@>=
{
  double f,x2;
#ifdef NCUBE
  char *doublefmt = "%12.8f";
#else
  char *doublefmt = "%12.8lf";
#endif
  char fmt[256];

  fprintf(outfp,"Doing a line minimization with gradient.\n");

  g1 = projection(&thisgradient,&lasth);
  x1 = projection(&thisgeometry,&lasth);

  if (fabs(g0-g1) < 0.0000001) {
    fprintf(errfp,"libgeom: line min with grad: g0-g1 too small\n");
    return GEOM_ABORT;
    }
  if (fabs(x0-x1) < 0.0000001) {
    fprintf(errfp,"libgeom: line min with grad: x0-x1 too small\n");
    return GEOM_ABORT;
    }

  /* From emacs calc (with mods). */
  f = (g0 - g1) / (x0 - x1);

  sprintf(fmt,"g0,g1,f = %s, %s, %s\n",doublefmt,doublefmt,doublefmt);
  fprintf(outfp,fmt,g0,g1,f);

  /* Limit the extent of step sizes by monitoring |f|. */
  if (f < min_f) {
    f = min_f;
    sprintf(fmt,"Resetting f to %s.\n",doublefmt);
    fprintf(outfp,fmt,f);
    }

  x2 = x1 - g1/f; 

  update_geometry(x2-x1, &lasth);

  /* Set point 0 to point 1 if g1 is smaller in magnitude than g0. */
  if (fabs(g0)>fabs(g1)) {
    g0 = g1;
    x0 = x1;
    }

}


@ This computes the first displacement in the line search.  Gradient
information is used to determine the magnitute of the step.  The
conjugate gradient, |lasth|, is used for the direction of the step.
More precisely, the following equation gives the energy as a quadratic
approximation,
\begin{equation}
E \approx E_m +  \frac{1}{2}  (\Vec{x} - \Vec{x}_m) \cdot \Mat{F}
                        \cdot (\Vec{x} - \Vec{x}_m)
\end{equation}
where $\Vec{x}$ is the atomic coordinate vector, $\Vec{x}_m$, is the vector
of atomic coordinates at the equilibrium geometry, and $\Mat{F}$ is the
force constant matrix.

This equation can be transformed
into a one dimensional equation along the direction
of the conjugate gradient, $\Vec{h}$, using the unitary transformation
$\frac{\Vec{h}}{\Norm{h}}$.
The transformed force constant and coordinate are written
\begin{equation}
F_h = \frac{\Vec{h}\cdot\Mat{F}\cdot\Vec{h}}{(\SelfDot{h})}
\end{equation}
and
\begin{equation}
x_h = \frac{\Vec{x}\cdot\Vec{h}}{(\SelfDot{h})^\frac{1}{2}}
\end{equation}
giving the new energy expression
\begin{equation}
E = E_m + \frac{1}{2} F_h (x_h - x_{hm})^2
\end{equation}
The transformed gradient is
\begin{equation}
\Partial{E}{x_h} = \frac{\Vec{h}\cdot\Vec{g}}{\Norm{h}}
\end{equation}
where $\Vec{g}$ is the gradient in the orginal atomic coordinate system.

Since this procedure does not know $\Mat{F}$, there is a guess
value hardwired below.
This gives us the following
\begin{equation}
\Partial{E}{x_h} =  F_h (x_h - x_{hm})
\end{equation}
which is solved for $x_{hm} = x_h - \Partial{E}{x_h} \frac{1}{F_h}$.
The change is $x_{hm}$ is then $\Delta x_h = \Partial{E}{x_h} \frac{1}{F_h}$.
This leads us to our next guess along our line search path, $\Vec{x}_{next}$,
\begin{equation}
\Vec{x}_{next} = \Delta x_h \frac{\Vec{h}}{\Norm{h}} + \Vec{x}
\end{equation}

@<Take the first step in a line minimization.@>=
{
  double steplength;
  CONST double F_h = 1.0;

  fprintf(outfp,"Taking the first step in a line minimization.\n");

  g0 = projection(&thisgradient,&lasth);
  steplength = -g0 / F_h;

  /* Save some needed globals. */
  x0 = projection(&thisgeometry,&lasth);

  /* Compute the new geometry along the h vector. */
  update_geometry(steplength,&lasth);

}

@ This computes the second step in a line minimization.  Only the
energy is used to form an update to the geometry.  This method is
still experimental and could very easily be a completely miserable
approach.  Let $x$ be the displacement along the line defined by
|lasth|.  Suppose we have the energy and points 0 and 1 and the
gradient at point 0.  If the desired point, the minimum energy point
is labeled 2 and we restrict ourselves to a quadratic approximation,
then we obtained three equations in three unknowns
\begin{equation}
E_1 = E_2 + \Half F (x_1 - x_2)^2
\end{equation}
\begin{equation}
E_0 = E_2 + \Half F (x_0 - x_2)^2
\end{equation}
and
\begin{equation}
(\Partial{E}{x})_{x_0} = F (x_0 - x_2)
\end{equation}

These equations can be solved to get
\begin{equation}
x2 = {2 x0 \times (e1 - e0) 
            + g0 \times (x0^2 - x1^2) 
            \over g0 \times (2 x0 - 2 x1) 
      + 2 (e1 - e0)}
\end{equation}
as generated by the emacs calculator.

@<Take the second step without a gradient in a line minimization.@>=
{
  double e0 = lastenergy;
  double e1 = thisenergy;
  double x2,f,e2;

  x1 = projection(&thisgeometry,&lasth);

  if (havegradient) {
    fprintf(outfp,"libgeom: a provided gradient will not be used");
    fprintf(outfp,"       the application should be more efficiently coded");
    }

  /* Here is x2 as given by the emacs calculator. */
  x2 = (2*(x0*(e1 - e0)) 
             + g0*(pow(x0, 2) - pow(x1, 2))) 
            / (g0*(2*x0 - 2*x1) + 2*(e1 - e0));

  /* The computed force constant. */
  f = g0/(x0-x2);

  /* The computed energy at x2. */
  e2 = e0 - 0.5 * f * (x0-x2)*(x0-x2);

  /* Update thisgeometry (which correspondes to x1). */
  update_geometry(x2-x1,&lasth);

}


@* Utility functions.

@ This function is called to see if the optimization has converged to an
acceptable degree or has gotten worse.  In the last case an abort
is triggered.  The return value will be one of |GEOM_NOTDONE|, |GEOM_DONE|,
or |GEOM_ABORT|.  Note that abort conditions are not yet checked.
@<Utility functions.@>=
LOCAL_FUNCTION int
grad_converged()
{
  int i;
  double rmsgrad=0.0,maxgrad=0.0;

  if (lastiteration>1) {
    fprintf(outfp,"last energy: %20.12e\n",lastenergy);
    }
  fprintf(outfp,"this energy: %20.12e\n",thisenergy);

  if (havegradient) {
    for (i=0; i<thisgradient.n; i++) {
      rmsgrad += thisgradient.d[i] * thisgradient.d[i];
      if (maxgrad < fabs(thisgradient.d[i])) maxgrad = fabs(thisgradient.d[i]);
      }
    rmsgrad = sqrt(rmsgrad/thisgradient.n);

    fprintf(outfp,"root mean square gradient: %20.12e\n",rmsgrad);
    fprintf(outfp,"maximum absolute gradient: %20.12e\n",maxgrad);

    if ((rmsgrad < crms) && (maxgrad < cmax)) {
      fprintf(outfp,"The geometry optimization has completed.\n");
      return GEOM_DONE;
      }
    }
  else {
    fprintf(errfp,"No gradient this time through.\n");
    }

  fprintf(outfp,"The geometry optimization will continue.\n");
  return GEOM_NOTDONE;
}

@ This is given a vector, |vect|, and a direction vector, |dirvect|,
and computes the projection of |vect| along |dirvect|. That is
\begin{equation}
|vect| = \frac{|vect| \cdot |dirvect|}{\Norm{|dirvect|}}
\end{equation}
@<Utility functions.@>=
LOCAL_FUNCTION double
projection(vect,dirvect)
double_vector_t *vect;
double_vector_t *dirvect;
{
  int i;
  double ddotd=0.0;
  double vdotd=0.0;

  if (vect->n != dirvect->n) {
    fprintf(errfp,"libgeom: argument error to projection\n");
    exit(1);
    }

  for (i=0; i<vect->n; i++) {
    ddotd += dirvect->d[i] * dirvect->d[i];
    vdotd += vect->d[i] * dirvect->d[i];
    }

  return vdotd/sqrt(ddotd);
}

@ This will update the |thisgeometry| vector in the direction defined
by the |dirvect| by an amount |steplength|.
@<Utility functions.@>=
LOCAL_FUNCTION VOID
update_geometry(steplength,dirvect)
double steplength;
double_vector_t *dirvect;
{
  int i;
  double ddotd = 0.0;
  double oonormd;
#ifdef NCUBE
  char *doublefmt = "% 12.8f";
#else
  char *doublefmt = "% 12.8lf";
#endif
  char fmt[256];

  for (i=0; i<dirvect->n; i++) {
    ddotd += dirvect->d[i] * dirvect->d[i];
    }

  oonormd = 1.0/sqrt(ddotd);

#if 0
  sprintf(fmt,"line: steplength = %s, gradient = %s\n",doublefmt,doublefmt);
  fprintf(outfp,fmt,
          steplength,projection(&thisgradient,dirvect));
  sprintf(fmt," %s %s %s\n",doublefmt,doublefmt,doublefmt);
  fprintf(outfp," %12s %12s %12s\n","geometry","gradient","displace");
#endif
  for (i=0; i<thisgeometry.n; i++) {
    double tmp = steplength * dirvect->d[i] * oonormd;
#if 0
    fprintf(outfp,fmt,
            thisgeometry.d[i],thisgradient.d[i],tmp);
#endif
    thisgeometry.d[i] += tmp;
    }
}

@ This will check to see if a line search has converged.
The argument |d| defines the
direction vector for the line we are searching.
The convergence criterion is a relative one.  The ratio
of the projection of the current gradient along the direction
of |d| is compared to the norm of the original gradient,
|g|.
@<Utility functions.@>=
LOCAL_FUNCTION int
line_search_converged(d,g)
double_vector_t *d;
double_vector_t *g;
{
  if (fabs(projection(&thisgradient,d)/projection(g,g))<0.05) return 1;
  return 0;
  }

