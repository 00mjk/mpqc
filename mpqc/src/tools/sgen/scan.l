%{

/* $Log$
 * Revision 1.2  1994/10/18 23:04:01  etseidl
 * fix many warnings, use memset rather than bzero
 *
 * Revision 1.1.1.1  1993/12/29  12:53:58  etseidl
 * SC source tree 0.1
 *
 * Revision 1.4  1992/10/09  19:38:00  seidl
 * add support for enums
 *
 * Revision 1.3  1992/04/01  17:29:06  seidl
 * include parse.tab.h for bison
 *
 * Revision 1.7  1991/12/14  00:13:51  cljanss
 * use __STDC__ to see if prototypes are to be used
 *
 * Revision 1.6  1991/12/02  17:39:33  cljanss
 * cannot use names input and output in the scanner due to the macro names
 * generated by the scanner generator
 *
 * Revision 1.5  91/11/18  17:23:36  cljanss
 * put in flex support
 * 
 * Revision 1.4  91/09/28  16:40:37  cljanss
 * new naming convention is used to keep names <= 14 characters.
 * 
 * Revision 1.3  91/09/28  16:11:28  cljanss
 * converted to SGI
 * 
 * Revision 1.2  1991/07/19  14:42:33  cljanss
 * Changed the way that generation modules are selected.
 *
 * Revision 1.1  1991/06/15  21:14:16  janssen
 * Initial revision
 * */

#include <tmpl.h>
#include <unistd.h>
#include "types.h"
#define IN_SCANNER
#include "global.h"
#include "error.gbl"
#include "scan.gbl"
#include "scan.lcl"
#include "parse.h"
#ifdef __STDC__
#  define YY_USE_PROTOS
#else
#  undef YY_USE_PROTOS
#endif
#ifdef FLEX
#define input yy_input
#else
#if defined(AIXV3)
#  undef input
#else
#  undef input()
#endif
#define input() (((yytchar=yysptr>yysbuf?U(*--yysptr):getc(yyin))==10?(advline(),yylineno++,yytchar):yytchar)==EOF?0:(advchar(),yytchar))
#if defined(AIXV3) || defined(SGI)
#  undef unput
#else
#  undef unput()
#endif
#define unput(c) {bckchar();yytchar= (c);if(yytchar=='\n'){yylineno--;bckline();};*yysptr++=yytchar;}
#endif /* FLEX */
%}
id		([A-Za-z_][A-Za-z0-9_]*|[0-9]+)
white		[ \t\n]
%%
^\#.*$			{ fprintf(includeoutput,"%s\n",yytext); }
^{white}*enum{white}+{id}{white}*"{"[^}]*"}"\; { fprintf(includeoutput,"%s\n",yytext); }
struct			{ return(T_STRUCT); }
signed			{ return(T_SIGNED); }
unsigned		{ return(T_UNSIGNED); }
union			{ return(T_UNION); }
default_modules { return(T_DEFAULT_MODULES); }
"=="			{ return(T_EQEQ); }
{id}			{ yylval.str = (char *)malloc(strlen(yytext)+1);
				  if (!yylval.str) {
				    perror("{id} rule");
				    error("{id} rule: malloc failed");
				    }
				  strcpy(yylval.str,yytext);
				  return(T_ID);
				  }
[ \t\n]+		;
"//".*$			{ fprintf(includeoutput,"/* %s */\n",&yytext[2]); }
[()!;:\[\]{}*]	{ return((int) yytext[0]); }
.				{ error("Illegal character: %c", yytext[0]); }
%%

#ifndef FLEX

#define MAX_LL 80
static char cur_line[MAX_LL] = {'\0'};
static int eline = 0;
static int lostline = 0;

/* Advance the input line. */
GLOBAL_FUNCTION VOID
advline()
{
  lostline = 0;
  eline = 0;
  cur_line[0] = '\0';
  }

/* Move the input line back. */
GLOBAL_FUNCTION VOID
bckline()
{
  lostline = 1;
  eline = 0;
  cur_line[0] = '\0';
  }

/* Advance the input char. */
GLOBAL_FUNCTION VOID
advchar()
{
  int i;
  /* Shift the line if it is too long. */
  if (eline==MAX_LL-1) {
    eline += -MAX_LL/2;
    for (i=0; i<eline; i++) {
      cur_line[i] = cur_line[i+MAX_LL/2];
      }
    }
  cur_line[eline++] = (char) yytchar;
  cur_line[eline] = '\0';
  }

GLOBAL_FUNCTION VOID
bckchar()
{
  if (eline==0) {
    bckline();
    return;
    }
  eline--;
  cur_line[eline] = '\0';
  }
#endif /* ! FLEX */
  

/* Show position. */
GLOBAL_FUNCTION VOID
showpos()
{
#ifndef FLEX
  int i;

  if (lostline) return;

  /* The first charater is a newline--don't print it. */
  fprintf(stderr,"%s\n",&cur_line[1]);
  for (i=0; i<eline-2-yyleng+1; i++) fprintf(stderr,"_");
  for (i=0; i<yyleng; i++) fprintf(stderr,"^");
  fprintf(stderr,"\n");
#else
  printf("flex has been used to generate the scanner so I don't\n");
  printf("know where the error is\n");
#endif /* ! FLEX */
  }

