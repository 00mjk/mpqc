
typedef int dmt_matrix;

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <tmpl.h>

extern "C" {
#include <comm/picl/picl.h>
}

#include <util/class/class.h>
#include <util/state/state.h>
#include <util/keyval/keyval.h>
#include <chemistry/molecule/molecule.h>
#include <chemistry/molecule/simple.h>
#include <chemistry/molecule/symm.h>
#include <chemistry/molecule/simpleQCList.h>
#include <chemistry/molecule/symmQCList.h>
#include <math/nihmatrix/nihmatrix.h>
#include <math/nihmatrix/lmath.h>

extern "C" {
#include <chemistry/qc/dmtqc/libdmtqc.h>
#include <util/misc/libmisc.h>
#include <util/bio/libbio.h>
}

#include "mpqc_int.h"

extern "C" {
 int mynode0();
 int numnodes0();
 void gop1(double*,int,double*,char,int);
}

/////////////////////////////////////////////////////////////////////

class four_array {
  public:
    double *d;
    int na;
    int nb;
    int nc;
    int nd;

    four_array(int i, int j, int k, int l) : na(i), nb(j), nc(k), nd(l) {
      d = new double[na*nb*nc*nd];
      bzero(d,sizeof(double)*na*nb*nc*nd);
      }
    ~four_array() { delete[] d; }
    
    void zero() { bzero(d,sizeof(double)*na*nb*nc*nd); }

    double & operator()(int i, int j, int k, int l)
      { return d[i*nb*nc*nd+j*nc*nd+k*nd+l]; }

    void print() {
      int ijkl=0;
      for (int i=0; i < na; i++)
        for (int j=0; j < nb; j++) {
          printf("\n(%d,%d)\n",i,j);
          for (int k=0; k < nc; k++) {
            printf("%4d",k);
            for (int l=0; l < nd; l++,ijkl++)
              printf(" %10.5f",d[ijkl]);
            printf("\n");
            }
          }
        }

  };



/////////////////////////////////////////////////////////////////////

int
mp2_hah(centers_t *centers, scf_struct_t *scf_info,
        dmt_matrix Scf_Vec, dmt_matrix Fock, FILE* outfile)
{
  tim_enter("init");

  ParsedKeyVal rawin("mpqc.in");
  PrefixKeyVal pref1(":mp2",rawin);
  PrefixKeyVal pref2(":default",rawin);
  AggregateKeyVal keyval(pref1,pref2);

  int nfzc=0,nfzv=0;

  if (keyval.exists("frozen_docc")) {
    nfzc = keyval.intvalue("frozen_docc");
    }

  if (keyval.exists("frozen_uocc")) {
    nfzv = keyval.intvalue("frozen_uocc");
    }

  int_initialize_offsets2(centers,centers,centers,centers);

  int flags = INT_EREP|INT_NOSTRB|INT_NOSTR1|INT_NOSTR2;

  double *intbuf = 
    int_initialize_erep(flags,0,centers,centers,centers,centers);

  int a,b;
  int i,j,k,l;
  int p,q,r,s;
  int P,Q,R,S;
  int bf1,bf2,bf3,bf4;
  int nbasis=centers->nfunc;
  int nocc=0,nvir;

  for (i=0; i < centers->n; i++) nocc += (int) centers->center[i].charge;

  nocc /= 2;
  nvir = nbasis-nocc;

  nvir -= nfzv;
  nocc -= nfzc;

  /*
   * otay, let's get a grip here, and form the MO integrals
   * this is all in core for now till I figure out what the hell
   * I'm doing
   *
   * First thing, let's get the scf vector off the nodes
   */

  DMatrix scf_vector(nbasis,nbasis);
  double *evals = new double[nbasis];

  dmt_get_diagonal(Fock,evals);

  loop_t *loop = dmt_ngl_create("%mr",Scf_Vec);
  while(dmt_ngl_next(loop)) {
    int iind,isize,jsize;
    double *col;

    dmt_ngl_create_inner(loop,0);
    while(dmt_ngl_next_inner_m(loop,&iind,&isize,&k,&jsize,&col)) {

      for (i=0; i < nbasis; i++)
        scf_vector(i,k) = col[i];
      }
    }

  dmt_ngl_kill(loop);

  double *iars = new double[nvir];
  double *ijab = new double[nvir*nvir];

  four_array A1(6,6,nbasis,nocc);
  four_array A3(nocc,nocc,nbasis,nvir);

  A3.zero();

  tim_exit("init");

  for (R=0; R < centers->nshell; R++) {
    int nr = INT_SH_NFUNC((centers),R);

    for (S=0; S <= R; S++) {
      int ns = INT_SH_NFUNC((centers),S);

      A1.zero();

      for (P=0; P < centers->nshell; P++) {
        int np = INT_SH_NFUNC((centers),P);

        for (Q=0; Q <= P; Q++) {
          int nq = INT_SH_NFUNC((centers),Q);

          int pp=P,qq=Q,rr=R,ss=S;

          tim_enter("erep");
          int_erep(INT_EREP|INT_NOBCHK|INT_NOPERM|INT_REDUND,&pp,&qq,&rr,&ss);
          tim_exit("erep");
      
          int index=0;

          for (bf1=0; bf1 < np; bf1++) {
            p = centers->func_num[pp] + bf1;

            for (bf2=0; bf2 < nq ; bf2++) {
              q = centers->func_num[qq] + bf2;

              if (q > p) {
                index += nr*ns;
                continue;
                }

              for (bf3=0; bf3 < nr ; bf3++) {
                for (bf4=0; bf4 < ns ;bf4++,index++) {
                  if (R==S && bf4>bf3) continue;

                  if (INT_NONZERO(intbuf[index])) {
                    double pqrs = intbuf[index];

                    if (p==q) pqrs *= 0.5;

                    for (i=0; i < nocc; i++) {
                      A1(bf3,bf4,q,i) += pqrs*scf_vector(p,i+nfzc);
                      A1(bf3,bf4,p,i) += pqrs*scf_vector(q,i+nfzc);
                      }
                    }
                  }
                }
              }
            }
          }
        }

      for (bf3=0; bf3 < nr ; bf3++) {
        r = centers->func_num[R] + bf3;

        for (bf4=0; bf4 < ns ; bf4++) {
          s = centers->func_num[S] + bf4;

          if (s>r) continue;

          for (i=0; i < nocc; i++) {
            bzero(iars,8*nvir);

            for (q=0; q < nbasis ; q++) {
              double prqi = A1(bf3,bf4,q,i);

              for (a=0; a < nvir; a++) {
                iars[a] += scf_vector(q,a+nfzc+nocc)*prqi;
                }
              }

            double scal = (r==s) ? 0.5 : 1;

            for (j=0; j <= i; j++) {
              double c_rj = scf_vector(r,j+nfzc)*scal;
              double c_sj = scf_vector(s,j+nfzc)*scal;

              for (a=0; a < nvir; a++) {
                A3(i,j,s,a) += iars[a] * c_rj;
                A3(i,j,r,a) += iars[a] * c_sj;
                }
              }
            }
          }
        }
      }
    }

  double Ecorr=0;

  for (i=0; i < nocc; i++) {
    for (j=0; j <= i; j++) {
      double eij = -evals[i+nfzc]-evals[j+nfzc];

      bzero(ijab,sizeof(double)*nvir*nvir);

      for (s=0; s < nbasis; s++) {
        for (b=0; b < nvir; b++) {
          for (a=0; a < nvir; a++) {
            ijab[a*nvir+b] += A3(i,j,s,a) * scf_vector(s,b+nfzc+nocc);
            }
          }
        }
      
      for (a=0; a < nvir; a++) {
        double ea=evals[a+nfzc+nocc];
        for (b=0; b < nvir; b++) {
          double eb=evals[b+nfzc+nocc];
          double t1 = ijab[a*nvir+b]*ijab[a*nvir+b];
          double t2 = ijab[a*nvir+b]*ijab[b*nvir+a];

          Ecorr += (2*t1-t2)/(ea+eb+eij);

          if (i!=j) {
            Ecorr += (2*t1-t2)/(ea+eb+eij);
            }
          }
        }
      }
    }

  printf("\n");
  printf("  E(SCF)  = %20.10f\n",scf_info->e_elec+scf_info->nuc_rep);
  printf("  E(Corr) = %20.10f\n",-Ecorr);
  printf("  E(MP2)  = %20.10f\n\n",scf_info->e_elec+scf_info->nuc_rep-Ecorr);

  return(0);
  }
