
typedef int dmt_matrix;

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <tmpl.h>

extern "C" {
#include <comm/picl/picl.h>
}

#include <util/class/class.h>
#include <util/state/state.h>
#include <util/keyval/keyval.h>
#include <chemistry/molecule/molecule.h>
#include <chemistry/molecule/simple.h>
#include <chemistry/molecule/symm.h>
#include <chemistry/molecule/simpleQCList.h>
#include <chemistry/molecule/symmQCList.h>
#include <math/nihmatrix/nihmatrix.h>
#include <math/nihmatrix/lmath.h>

extern "C" {
#include <chemistry/qc/dmtqc/libdmtqc.h>
#include <util/misc/libmisc.h>
#include <util/bio/libbio.h>
}

#include "mpqc_int.h"

extern "C" {
 int mynode0();
 int numnodes0();
 void gop1(double*,int,double*,char,int);
}


int
mp2_hah(centers_t *centers, dmt_matrix Scf_Vec, dmt_matrix Fock, FILE* outfile)
{

  int_initialize_offsets2(centers,centers,centers,centers);

  int flags = INT_EREP|INT_NOSTRB|INT_NOSTR1|INT_NOSTR2;

  double *intbuf = 
    int_initialize_erep(flags,0,centers,centers,centers,centers);

  int i,j,k,l;
  int p,q,r,s;
  int P,Q,R,S;
  int nbasis=centers->nfunc;
  int nocc=0,nvir;

  for (i=0; i < centers->n; i++) nocc += (int) centers->center[i].charge;

  nocc /= 2;
  nvir = nbasis-nocc;

  /*
   * otay, let's get a grip here, and form the MO integrals
   * this is all in core for now till I figure out what the hell
   * I'm doing
   *
   * First thing, let's get the scf vector off the nodes
   */

  DMatrix scf_vector(nbasis,nbasis);
  double *evals = new double[nbasis];

  dmt_get_diagonal(Fock,evals);

  loop_t *loop = dmt_ngl_create("%mr",Scf_Vec);
  while(dmt_ngl_next(loop)) {
    int iind,isize,jsize;
    double *col;

    dmt_ngl_create_inner(loop,0);
    while(dmt_ngl_next_inner_m(loop,&iind,&isize,&k,&jsize,&col)) {

      for (i=0; i < nbasis; i++)
        scf_vector(i,k) = col[i];
      }
    }

  dmt_ngl_kill(loop);

  scf_vector.print("scf_vector");

  double ****aoints = new double***[nbasis];

  for (i=0; i < nbasis; i++) {
    aoints[i] = new double**[nbasis];
    for (j=0; j < nbasis; j++) {
      aoints[i][j] = new double*[nbasis];
      for (k=0; k < nbasis; k++) {
        aoints[i][j][k] = new double[nbasis];
        for (l=0; l < nbasis; l++) {
          aoints[i][j][k][l] = 0;
          }
        }
      }
    }

  for (P=0; P < centers->nshell; P++) {
    for (Q=0; Q <= P; Q++) {
      for (R=0; R <= P; R++) {
        for (S=0; S <= ((P==R)?Q:R) ; S++) {

          int pp=P,qq=Q,rr=R,ss=S;

          int_erep(INT_EREP|INT_NOBCHK|INT_NOPERM,&pp,&qq,&rr,&ss);
      
          int np = INT_SH_NFUNC((centers),pp);
          int nq = INT_SH_NFUNC((centers),qq);
          int nr = INT_SH_NFUNC((centers),rr);
          int ns = INT_SH_NFUNC((centers),ss);

          int e12 = (pp==qq);
          int e13e24 = (pp==rr) && (qq==ss);
          int e34 = (rr==ss);

          int index=0;

          int bf1,bf2,bf3,bf4;
          int p1,q1,r1,s1;

          for (bf1=0; bf1<=INT_MAX1(np) ; bf1++) {
            int p = centers->func_num[pp] + bf1;

            for (bf2=0; bf2<=INT_MAX2(e12,bf1,nq) ; bf2++) {

              int q = centers->func_num[qq] + bf2;

              for (bf3=0; bf3<=INT_MAX3(e13e24,bf1,nr) ; bf3++) {
                int r = centers->func_num[rr] + bf3;

                for (bf4=0; bf4 <= INT_MAX4(e13e24,e34,bf1,bf2,bf3,ns);bf4++) {
                  if (INT_NONZERO(intbuf[index])) {
                    int s = centers->func_num[ss] + bf4;

                    aoints[p][q][r][s] =
                    aoints[q][p][r][s] =
                    aoints[p][q][s][r] =
                    aoints[q][p][s][r] =
                    aoints[r][s][p][q] =
                    aoints[r][s][q][p] =
                    aoints[s][r][p][q] =
                    aoints[s][r][q][p] =
                                         intbuf[index];

                    }

                  index++;
                  }
                }
              }
            }
          }
        }
      }
    }

  int a,b;
  double Ecorr=0;
  double iajb[7][7][7][7];
  double pajb[7][7][7][7];
  DVector pqrb(nbasis);
  DMatrix pqjb(nocc,nbasis);

  bzero(iajb,8*7*7*7*7);
  bzero(pajb,8*7*7*7*7);

  for (p=0; p < nbasis; p++) {
    for (q=0; q < nbasis; q++) {

      pqjb.zero();
      for (r=0; r < nbasis; r++) {

        pqrb.zero();
        for (s=0; s < nbasis; s++) {
          double pqrs = aoints[p][q][r][s];

          for (b=0; b < nbasis; b++) {
            pqrb[b] += pqrs * scf_vector(s,b);
            }
          }

printf("%d ints\n",r);
pqrb.print("pqrb");

        for (j=0; j < nocc; j++) {
          for (b=0; b < nbasis; b++) {
            pqjb(j,b) += pqrb[b] * scf_vector(r,j);
            }
          }
        }

      for (a=0; a < nbasis; a++) {
        for (j=0; j < nocc; j++) {
          for (b=0; b < nbasis; b++) {
            pajb[p][a][j][b] += pqjb[j][b] * scf_vector(q,a);
            }
          }
        }
      }

    for (i=0; i < nocc; i++) {
      for (a=0; a < nbasis; a++) {
        for (j=0; j < nocc; j++) {
          for (b=0; b < nbasis; b++) {
            iajb[i][a][j][b] += pajb[p][a][j][b] * scf_vector(p,i);
            }
          }
        }
      }
    }

   /*
    * alright, we've got the mo integrals, now calculate
    *  Ecorr = 
    */

  for (i=0; i < nocc; i++) {
    for (a=nocc; a < nbasis; a++) {
      for (j=0; j < nocc; j++) {
        for (b=nocc; b < nbasis; b++) {
          double t1 = iajb[i][a][j][b]*iajb[i][a][j][b];
          double t2 = iajb[i][a][j][b]*iajb[i][b][j][a];

          Ecorr += (2*t1-t2)/(evals[a]+evals[b]-evals[i]-evals[j]);
          }
        }
      }
    }

  printf(" E(MP2) = %20.10f\n\n",Ecorr);

  return(0);
  }
