
typedef int dmt_matrix;

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <tmpl.h>

extern "C" {
#include <comm/picl/picl.h>
}

#include <util/class/class.h>
#include <util/state/state.h>
#include <util/keyval/keyval.h>
#include <chemistry/molecule/molecule.h>
#include <chemistry/molecule/simple.h>
#include <chemistry/molecule/symm.h>
#include <chemistry/molecule/simpleQCList.h>
#include <chemistry/molecule/symmQCList.h>
#include <math/nihmatrix/nihmatrix.h>
#include <math/nihmatrix/lmath.h>

extern "C" {
#include <chemistry/qc/dmtqc/libdmtqc.h>
#include <util/misc/libmisc.h>
#include <util/bio/libbio.h>
}

#include "mpqc_int.h"


extern "C" {
 void scf_init_bounds(centers_t*,double*);
 int scf_erep_bound(int,int,int,int);
 void scf_done_bounds();
 int mynode0();
 int numnodes0();
 int cubedim0();
 void gop1(double*,int,double*,char,int);
 int gcolx(double*,int*,double*);
 void gdcolx(double *x, double *y, int **dims, int **offs);
}

/////////////////////////////////////////////////////////////////////

class three_array {
  public:
    double *d;
    int na;
    int nb;
    int nc;

    three_array(int i, int j, int k) : na(i), nb(j), nc(k) {
      d = new double[na*nb*nc];
      if (!d) {
        fprintf(stderr,"damn. can't allocate (%d,%d,%d) array\n",i,j,k);
        exit(0);
        }
      bzero(d,sizeof(double)*na*nb*nc);
      }
    ~three_array() { delete[] d; }

    double& operator()(int i, int j, int k) { return d[i*nb*nc+j*nc+k]; }
    void zero() { bzero(d,sizeof(double)*na*nb*nc); }
  };

class four_array {
  public:
    double *d;
    int na;
    int nb;
    int nc;
    int nd;

    four_array(int i, int j, int k, int l) : na(i), nb(j), nc(k), nd(l) {
      d = new double[na*nb*nc*nd];
      if (!d) {
        fprintf(stderr,"damn. can't allocate (%d,%d,%d,%d) array\n",i,j,k,l);
        exit(0);
        }
      bzero(d,sizeof(double)*na*nb*nc*nd);
      }
    ~four_array() { delete[] d; }
    
    void zero() { bzero(d,sizeof(double)*na*nb*nc*nd); }

    double & operator()(int i, int j, int k, int l)
      { return d[i*nb*nc*nd+j*nc*nd+k*nd+l]; }

    void print() {
      int ijkl=0;
      for (int i=0; i < na; i++)
        for (int j=0; j < nb; j++) {
          printf("\n(%d,%d)\n",i,j);
          for (int k=0; k < nc; k++) {
            printf("%4d",k);
            for (int l=0; l < nd; l++,ijkl++)
              printf(" %10.5f",d[ijkl]);
            printf("\n");
            }
          }
        }

  };



/////////////////////////////////////////////////////////////////////

int
mp2_hah(centers_t *centers, scf_struct_t *scf_info,
        dmt_matrix Scf_Vec, dmt_matrix Fock, FILE* outfile)
{
  tim_enter("init");

  ParsedKeyVal rawin("mpqc.in");
  PrefixKeyVal pref1(":mp2",rawin);
  PrefixKeyVal pref2(":default",rawin);
  AggregateKeyVal keyval(pref1,pref2);

  int nfzc=0,nfzv=0;

  int me=mynode0();
  int nproc=numnodes0();
  int dim=cubedim0();

  if (keyval.exists("frozen_docc")) {
    nfzc = keyval.intvalue("frozen_docc");
    }

  if (keyval.exists("frozen_uocc")) {
    nfzv = keyval.intvalue("frozen_uocc");
    }

  int_initialize_offsets2(centers,centers,centers,centers);

  int flags = INT_EREP|INT_NOSTRB|INT_NOSTR1|INT_NOSTR2;

  double *intbuf = 
    int_initialize_erep(flags,0,centers,centers,centers,centers);

  scf_init_bounds(centers,intbuf);

  int a,b;
  int i,j,k,l;
  int p,q,r,s;
  int P,Q,R,S;
  int bf1,bf2,bf3,bf4;
  int nbasis=centers->nfunc;
  int nocc=0,nvir;

  for (i=0; i < centers->n; i++) nocc += (int) centers->center[i].charge;

  nocc /= 2;
  nvir = nbasis-nocc;

  nvir -= nfzv;
  nocc -= nfzc;

  /*
   * otay, let's get a grip here, and form the MO integrals
   * this is all in core for now till I figure out what the hell
   * I'm doing
   *
   * First thing, let's get the scf vector off the nodes
   */

  DMatrix scf_vector(nbasis,nocc+nvir);  // only doc + uoc
  double *evals = new double[nbasis];

  dmt_get_diagonal(Fock,evals);

  for (i=0; i < nocc+nvir; i++) evals[i] = evals[i+nfzc];

  loop_t *loop = dmt_ngl_create("%mr",Scf_Vec);
  while(dmt_ngl_next(loop)) {
    int iind,isize,jsize;
    double *col;

    dmt_ngl_create_inner(loop,0);
    while(dmt_ngl_next_inner_m(loop,&iind,&isize,&k,&jsize,&col)) {

      if (k >= nfzc && k < nbasis-nfzv) {
        for (i=0; i < nbasis; i++)
          scf_vector(i,k-nfzc) = col[i];
        }
      }
    }

  dmt_ngl_kill(loop);

 /*
  * ok, now we need to figure out how many passes we need to make.
  * for each i we need N(mM+36) m=nocc, M=nvir, N=nbasis
  * plus we need M^2+M all the time, plus NM for the scf vector
  *
  * so  nstatic = M(M+N+1)*sizeof(double)
  *       nperi = N(mM+36)*sizeof(double)
  *       npass = nperi * m / (mem - nstatic)
  *       ni = m / npass
  */

  int nstatic = nvir*(nvir+nbasis+1)*sizeof(double);
  int mem = 10000000-nstatic;

  int nj = nocc*nvir*nbasis/nproc;
  int nperi = (36*nbasis+nj)*sizeof(double);

  int npass = nperi*nocc/mem;
  if (nperi*nocc%mem) npass++;

  int ni = nocc/npass;
  if (nocc%npass) ni++;

  int nij = ni*nocc/nproc;
  if (ni*nocc%nproc) nij++;

  if (me==0) {
    fprintf(outfile,"\n  in mp2:\n");
    fprintf(outfile,  "     nstatic = %d\n",nstatic);
    fprintf(outfile,  "         mem = %d\n",mem);
    fprintf(outfile,  "       npass = %d\n",npass);
    fprintf(outfile,  "          ni = %d\n",ni);
    fprintf(outfile,  "         nij = %d\n",nij);
    }

 // iarsp holds a small chunk of the iars vector.
 // first we must determine how big each nodes chunk will be
 // lens is an array of lengths for gcolx()

  int mylen = nvir/nproc;
  int remain = nvir%nproc;
  if (me < remain) mylen++;

  int first;
  if (me < remain) first = me*mylen;
  else first = remain*(mylen+1) + (me-remain)*mylen;
  int last = first+mylen;

  int *lens = new int[nproc];
  for (i=0; i < nproc; i++) lens[i] = (nvir/nproc)*sizeof(double);
  for (i=0; i < remain; i++) lens[i]+=sizeof(double);

  int **offs = new int*[dim];
  int **dims = new int*[dim];

  for (i=0; i < dim; i++) {
    offs[i] = new int[nproc];
    dims[i] = new int[nproc];
    }

  memcpy(dims[0],lens,sizeof(int)*nproc);

  offs[0][0] = 0;
  for (i=1; i < nproc; i++) offs[0][i] =
                                    offs[0][i-1]+dims[0][i-1]/sizeof(double);

  for (i=0; i < dim-1; i++) {
    int ibit = 1<<i;
    for (int j=0; j < nproc; j++) {
      if (!(j&ibit)) {
        dims[i+1][j] = dims[i+1][j^ibit] = dims[i][j^ibit] + dims[i][j];

        offs[i+1][j] = offs[i+1][j^ibit] = offs[i][j];
        }
      }
    }

  double *iarsp = new double[mylen];
  double *iars = new double[nvir];
  double *ijab = new double[nvir*nvir];

  three_array A3(nij,nbasis,nvir);

  tim_exit("init");

  double Ecorr=0;

  int pass;
  for (pass=0; pass < npass; pass++) {

    int remaini = nocc%npass;

    if (remaini && remaini==pass) ni--;

    int firsti;

    if (pass < remaini) firsti = pass*ni;
    else firsti = remaini*(ni+1) + (pass-remaini)*ni;

    int lasti = firsti+ni;

    A3.zero();

    int tol = (int) (-10.0/log10(2.0));

    tim_enter("RS loop");
    int int_index=0;
    for (R=0; R < centers->nshell; R++) {

if(me==0) printf(" %5d\n",R);
      int nr = INT_SH_NFUNC((centers),R);

      for (S=0; S <= R; S++) {
        int ns = INT_SH_NFUNC((centers),S);

        four_array A1(nr,ns,nbasis,ni);
        four_array Temp(nr,ns,nbasis,ni);
        A1.zero();

        tim_enter("PQ loop");
        for (P=0; P < centers->nshell; P++) {
          int np = INT_SH_NFUNC((centers),P);

          for (Q=0; Q <= P; Q++) {
            if (scf_erep_bound(P,Q,R,S) < tol){
              continue;
              }

            int_index++;

            if (int_index%nproc != me) continue;

            int nq = INT_SH_NFUNC((centers),Q);

            tim_enter("erep");
            int_erep(INT_EREP|INT_NOBCHK|INT_NOPERM|INT_REDUND,&P,&Q,&R,&S);
            tim_exit("erep");
        
            int index=0;

            tim_enter("a1 loop");
            for (bf1=0; bf1 < np; bf1++) {
              p = centers->func_num[P] + bf1;

              for (bf2=0; bf2 < nq ; bf2++) {
                q = centers->func_num[Q] + bf2;

                if (q > p) {
                  index += nr*ns;
                  continue;
                  }

                for (bf3=0; bf3 < nr ; bf3++) {
                  for (bf4=0; bf4 < ns ;bf4++,index++) {
                    if (R==S && bf4>bf3) continue;

                    if (INT_NONZERO(intbuf[index])) {
                      double pqrs = intbuf[index];

                      if (p==q) pqrs *= 0.5;

                      double *rsqi = &A1.d[bf3*ns*nbasis*ni+bf4*nbasis*ni+q*ni];
                      double *rspi = &A1.d[bf3*ns*nbasis*ni+bf4*nbasis*ni+p*ni];
                      double *c_p = &scf_vector[p][firsti];
                      double *c_q = &scf_vector[q][firsti];

                      for (i=0; i < ni; i++) {
                        *rsqi++ += pqrs * *c_p++;
                        *rspi++ += pqrs * *c_q++;
                        }
                      }
                    }
                  }
                }
              }
            tim_exit("a1 loop");
            }
          }
        tim_exit("PQ loop");
        
        tim_enter("a1 sum");
        gop1(A1.d,nr*ns*nbasis*ni,Temp.d,'+',3);
        tim_exit("a1 sum");

        tim_enter("a3 loop");
        for (bf3=0; bf3 < nr ; bf3++) {
          r = centers->func_num[R] + bf3;

          for (bf4=0; bf4 <= ((R==S) ? bf3 : ns-1) ; bf4++) {
            s = centers->func_num[S] + bf4;

            int ij=0;
            for (i=0; i < ni; i++) {
#if defined(I860)
              bzero(iarsp,sizeof(double)*mylen);
#else
              bzero(iars,sizeof(double)*nvir);
#endif

              tim_enter("a2 part");
              for (q=0; q < nbasis ; q++) {
                double *c_q = &scf_vector[q][first+nocc];
                double rsqi = A1(bf3,bf4,q,i);
#if defined(I860)
                double *iarspp = iarsp;
#else
                double *iarspp = &iars[first];
#endif

                for (a=0; a < mylen; a++) {
                  *iarspp++ += *c_q++ * rsqi;
                  }
                }
              tim_exit("a2 part");

              tim_enter("a2 sum");
              int cnt;
#if defined(I860)
              //gcolx(iarsp,lens,iars);
              gdcolx(iarsp,iars,dims,offs);
#else
              gsum0(iars,nvir,5,mtype_get(),0);
              bcast0(iars,sizeof(double)*nvir,mtype_get(),0);
#endif
              tim_exit("a2 sum");

              double scal = (r==s) ? 0.5 : 1;

              tim_enter("a3a part");
              for (j=0; j < nocc; j++) {
                if (((i*nocc+j)%nproc) != me) continue;
                double c_rj = scf_vector(r,j)*scal;
                double c_sj = scf_vector(s,j)*scal;

                double *a3ijs = &A3.d[ij*nbasis*nvir+s*nvir];
                double *a3ijr = &A3.d[ij*nbasis*nvir+r*nvir];

                tim_enter("a3 part");
                for (a=0; a < nvir; a++) {
                  a3ijs[a] += iars[a]*c_rj;
                  a3ijr[a] += iars[a]*c_sj;
                  }
                tim_exit("a3 part");

                ij++;
                }
              tim_exit("a3a part");
              }
            }
          }
        tim_exit("a3 loop");
        }
      }
    tim_exit("RS loop");

    tim_enter("a4 loop");
    int ij=0;
    for (i=0; i < ni; i++) {
      for (j=0; j < nocc; j++) {
        if (((i*nocc+j)%nproc) != me) continue;

        double eij = -evals[i+firsti]-evals[j];

        bzero(ijab,sizeof(double)*nvir*nvir);

        for (s=0; s < nbasis; s++) {
          for (a=0; a < nvir; a++) {
            double ijsa = A3(ij,s,a);
            double *c_s = &scf_vector[s][nocc];
            double *ijabp = & ijab[a*nvir];

            for (b=0; b < nvir; b++) {
              *ijabp++ += ijsa * *c_s++;
              }
            }
          }
        
        for (a=0; a < nvir; a++) {
          double ea=evals[a+nocc];
          for (b=0; b < nvir; b++) {
            double eb=evals[b+nocc];
            double t1 = ijab[a*nvir+b]*ijab[a*nvir+b];
            double t2 = ijab[a*nvir+b]*ijab[b*nvir+a];

            Ecorr += (2*t1-t2)/(ea+eb+eij);
            }
          }

        ij++;
        }
      }
    tim_exit("a4 loop");
    }

  gsum0(&Ecorr,1,5,mtype_get(),0);

  if (me==0) {
    printf("\n");
    printf("  E(SCF)  = %20.10f\n",scf_info->e_elec+scf_info->nuc_rep);
    printf("  E(Corr) = %20.10f\n",-Ecorr);
    printf("  E(MP2)  = %20.10f\n\n",scf_info->e_elec+scf_info->nuc_rep-Ecorr);
    }

  scf_done_bounds();
  int_done_erep();
  int_done_offsets2(centers,centers,centers,centers);

  return(0);
  }
