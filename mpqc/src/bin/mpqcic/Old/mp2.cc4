
typedef int dmt_matrix;

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <tmpl.h>

extern "C" {
#include <comm/picl/picl.h>
}

#include <util/class/class.h>
#include <util/state/state.h>
#include <util/keyval/keyval.h>
#include <chemistry/molecule/molecule.h>
#include <chemistry/molecule/simple.h>
#include <chemistry/molecule/symm.h>
#include <chemistry/molecule/simpleQCList.h>
#include <chemistry/molecule/symmQCList.h>
#include <math/nihmatrix/nihmatrix.h>
#include <math/nihmatrix/lmath.h>

extern "C" {
#include <chemistry/qc/dmtqc/libdmtqc.h>
#include <util/misc/libmisc.h>
#include <util/bio/libbio.h>
}

#include "mpqc_int.h"

extern "C" {
 int mynode0();
 int numnodes0();
 void gop1(double*,int,double*,char,int);
}


int
mp2_hah(centers_t *centers, dmt_matrix Scf_Vec, dmt_matrix Fock, FILE* outfile)
{

  int_initialize_offsets2(centers,centers,centers,centers);

  int flags = INT_EREP|INT_NOSTRB|INT_NOSTR1|INT_NOSTR2;

  double *intbuf = 
    int_initialize_erep(flags,0,centers,centers,centers,centers);

  int a,b;
  int i,j,k,l;
  int p,q,r,s;
  int P,Q,R,S;
  int nbasis=centers->nfunc;
  int nocc=0,nvir;

  for (i=0; i < centers->n; i++) nocc += (int) centers->center[i].charge;

  nocc /= 2;
  nvir = nbasis-nocc;

  /*
   * otay, let's get a grip here, and form the MO integrals
   * this is all in core for now till I figure out what the hell
   * I'm doing
   *
   * First thing, let's get the scf vector off the nodes
   */

  DMatrix scf_vector(nbasis,nbasis);
  double *evals = new double[nbasis];

  dmt_get_diagonal(Fock,evals);

  loop_t *loop = dmt_ngl_create("%mr",Scf_Vec);
  while(dmt_ngl_next(loop)) {
    int iind,isize,jsize;
    double *col;

    dmt_ngl_create_inner(loop,0);
    while(dmt_ngl_next_inner_m(loop,&iind,&isize,&k,&jsize,&col)) {

      for (i=0; i < nbasis; i++)
        scf_vector(i,k) = col[i];
      }
    }

  dmt_ngl_kill(loop);

  double pqrb[6][6][6][7]; // 6x6x6 x nvir
  double pqjb[6][6][7][7]; // 6x6 x nocc x nvir
  double pajb[6][7][7][7]; // 6 x nvir x nocc x nvir
  double iajb[7][7][7][7]; // nocc^2 x nvir^2

  bzero(iajb,8*7*7*7*7);

  for (P=0; P < centers->nshell; P++) {
    int np = INT_SH_NFUNC((centers),P);

    bzero(pajb,8*7*7*7*6);

    for (Q=0; Q < centers->nshell; Q++) {
      int nq = INT_SH_NFUNC((centers),Q);

      bzero(pqjb,8*7*7*6*6);

      for (R=0; R < centers->nshell; R++) {
        int nr = INT_SH_NFUNC((centers),R);

        bzero(pqrb,8*6*6*6*nbasis);

        for (S=0; S < centers->nshell ; S++) {

          int pp=P,qq=Q,rr=R,ss=S;

          int_erep(INT_EREP|INT_NOBCHK|INT_NOPERM,&pp,&qq,&rr,&ss);
      
          int ns = INT_SH_NFUNC((centers),ss);

          int e12 = (pp==qq);
          int e13e24 = (pp==rr) && (qq==ss);
          int e34 = (rr==ss);

          int index=0;

          int bf1,bf2,bf3,bf4;
          int p1,q1,r1,s1;
          int po,qo,ro,so;
          int po1,qo1,ro1,so1;
          int ppp,qqq,rrr,sss;

          for (bf1=0; bf1<=INT_MAX1(np) ; bf1++) {
            int p2 = centers->func_num[pp] + bf1;

            for (bf2=0; bf2<=INT_MAX2(e12,bf1,nq) ; bf2++) {
              int q2 = centers->func_num[qq] + bf2;

              if (q2 > p2) {
                p1 = q2; q1 = p2; po1 = bf2; qo1 = bf1;
                }
              else {
                p1 = p2; q1 = q2; po1 = bf1; qo1 = bf2;
                }

              int pq = p1*(p1+1)/2+q1;

              for (bf3=0; bf3<=INT_MAX3(e13e24,bf1,nr) ; bf3++) {
                int r2 = centers->func_num[rr] + bf3;

                for (bf4=0; bf4 <= INT_MAX4(e13e24,e34,bf1,bf2,bf3,ns);bf4++) {
                  if (INT_NONZERO(intbuf[index])) {
                    int s2 = centers->func_num[ss] + bf4;

                    if (s2 > r2) {
                      r1 = s2; s1 = r2; ro1 = bf4; so1 = bf3;
                      }
                    else {
                      r1 = r2; s1 = s2; ro1 = bf3; so1 = bf4;
                      }
                    
                    int rs = r1*(r1+1)/2 + s1;

                    if (rs > pq) {
                      p = r1; q = s1; r = p1; s = q1;
                      po = ro1; qo = so1; ro = po1; so = qo1;
                      }
                    else {
                      p = p1; q = q1; r = r1; s = s1;
                      po = po1; qo = qo1; ro = ro1; so = so1;
                      }

                    double pqrs = intbuf[index];

                    for (b=0; b < nbasis; b++) {
                      pqrb[po][qo][ro][b] += scf_vector(s,b)*pqrs;
                      }
                    }

                  index++;
                  }
                }
              }
            }
          }
        int ab=1;

        }
      }
    }

   /*
    * alright, we've got the mo integrals, now calculate
    *  Ecorr = 
    */

  double Ecorr=0;

  for (i=0; i < nocc; i++) {
    for (a=nocc; a < nbasis; a++) {
      for (j=0; j < nocc; j++) {
        for (b=nocc; b < nbasis; b++) {
          double t1 = iajb[i][a][j][b]*iajb[i][a][j][b];
          double t2 = iajb[i][a][j][b]*iajb[i][b][j][a];

          Ecorr += (2*t1-t2)/(evals[a]+evals[b]-evals[i]-evals[j]);
          }
        }
      }
    }

  printf(" E(MP2) = %20.10f\n\n",Ecorr);

  return(0);
  }
