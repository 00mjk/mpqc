
%
% $Id$
%

\documentstyle[drafthead]{article}

\title{MPQC: The Massively Parallel Quantum Chemistry Program}
\author{Sandia National Laboratories, Livermore \\
        National Institutes of Health
        }

\begin{document}

\newcommand{\libint}{{\tt libintv2}}
\newcommand{\libdmtscf}{{\tt libdmtscf}}
\newcommand{\libforce}{{\tt libforce}}
\newcommand{\libgeom}{{\tt libgeom}}
\newcommand{\mpqc}{{\tt mpqc}}
\newcommand{\libip}{{\tt libipv2}}

\maketitle

\begin{abstract}
The massively parallel quantum chemistry program, \mpqc{},
can compute self consistent field energies of molecules and
minimize the energy with respect to variations in nuclear
coordinates.  A general spin restricted formalism is used
which performs calculations on closed shell as well as
high spin open shell wavefunctions.
\end{abstract}

\vskip 0.25in
{
\centering
\framebox[4in]
{\begin{minipage}{3.75in}
\sc Any resemblance between the answers produced by
{\tt mpqc} and physical reality are purely coincidental.  The
{\tt mpqc} package is provided for entertainment use only.
\end{minipage}}
\vskip 0.25in
}

\tableofcontents

\section{Input Format}
The \mpqc{} program needs input for itself and for the libraries which
it uses.  In some cases, input for two or more of the libraries will
be identical.  Entering this data in two seperate sections of the input
can be eliminated by putting that input the the {\tt default} section
of the input file.  All of the input is obtained initially from the
``{\tt mpqc.in}'' file, however, additional files containing more input
can be specified within the input, as described below.

The basic format of the input is {\it keyword} {\tt =} {\it value}
pairs.\footnote
  {
  The \mpqc{} program uses version 2 of the input parsing package, \libip{},
  for which separate documentation exists.
  }
Keywords and values are separated with whitespace (space, newline,
and tab) or by special characters (``{\tt :()\{\}[]=}'').  A large keyword
can be broken up into smaller keywords by using {\tt :}.  For example,
the \mpqc{} program may require a parameter {\tt threshold}.  To
distinguish this keyword from keywords with the same name in other
packages, it is convenient to rename this and all other keywords in
the \mpqc{} program to {\tt mpqcthreshold}.  Typing {\tt mpqc} in
front of each keyword is inconvenient, so the {\tt :} character
is used to separate the keyword into two pieces, here {\tt mpqc:threshold}.
If several parameters must be specified for the \mpqc{} program, then
they can be grouped as follows:
\begin{verbatim}
mpqc: (
  threshold = 10
  optimize_geometry = yes
  throttle = 2
  )
\end{verbatim}

Thus, the overall layout of the input file will be something like
\begin{verbatim}
default: (
  local_P = yes
  )

mpqc: (
  threshold = 10
  optimize_geometry = yes
  throttle = 2
  )

force: (
  threshold = 10
  )
\end{verbatim}
where each package has its own section in the input file.  After each
package looks for input in its section it looks in the {\tt default}
section if it could not find the needed data.  In the above example,
both the \mpqc{} program's input and the input for the force library
will have {\tt local\_P} {\tt =} {\tt yes}.

\subsection{MPQC input}
\label{mpqcsection}
The input for the \mpqc{} program is searched for first in the {\tt mpqc}
section and then in the {\tt default} section.  The input parameters are
given in Table~\ref{mpqcinput}.

Some of the more important options are {\tt restart} which lets
an old vector be used as the initial guess.  The {\tt optimize\_geometry}
option should be {\tt yes} if a geometry optimization is desired.
When this is true then the {\tt force} and {\tt geometry} input sections
will also be used.  The {\tt nopt} option gives the maximum number
of iterations in a geometry optimization.  Fewer will be used if the
gradients become smaller than limits established in the {\tt geometry}
section.  The {\tt print\_geometry} option should be {\tt yes} if
the geometry is desired in the output file.  Finally, the {\tt local\_P}
options should be {\tt yes} if the memory requirements do not exceed
the limitations on any of the nodes.  Setting this option to {\tt yes}
should improve the load balancing, especially if you are using symmetry.

Additional input can be included as
an extension to the input file with the {\tt inputdir}
and {\tt inputfiles} keywords.   The {\tt inputdir} keyword is a string
that gives the pathname to the directory where the additional files
reside.  The {\tt inputfiles}
keyword is a vector of strings to the names of input files.  For each
of the {\tt inputfiles} the {\tt inputdir} string is preppended to
the filename and the file with the resulting name is logically appended to
the input file.

\begin{table}
\centering
\begin{tabular}{|lccp{2.75in}|}
\hline
\multicolumn{1}{|c}{Keyword} & \multicolumn{1}{c}{Type} &
  \multicolumn{1}{c}{Default} & \multicolumn{1}{c|}{Description} \\
\hline
  {\tt optimize\_geometry}&boolean& no & If this is {\tt yes}, then
                                         the geometry will be optimized. \\
  {\tt nopt}              &integer&  1 & This is the maximum number
                                         of iterations in the geometry
                                         optimization. \\
  {\tt restart}           &boolean&yes & Specifies whether or not the
                                         old scf vector is to be read in from a
                                         scratch file. \\
  {\tt save\_vector}      &boolean&yes & Specifies whether or not the scf
                                         vector is to be saved. \\
  {\tt save\_fock}        &boolean& no & Specifies whether or not the scf
                                         fock matrix is to be saved. \\
  {\tt node\_timings}     &boolean&  0 & If this is true timings for all
                                         nodes are printed. \\
  {\tt throttle}          &integer&  0 & The number of advance blocks to
                                         be sent out in a distributed
                                         matrix loop. \\
  {\tt sync\_loop}        &integer&  1 & The number of blocks that a node
                                         can fall behind before the send
                                         will begin
                                         requiring synchronization with
                                         the node. \\
  {\tt print\_geometry}   &boolean& no & If this is true the geometry will
                                         be sent to the output file. \\
  {\tt local\_P}          &boolean& no & If this is true a more sophisticated
                                         distribution scheme will be used,
                                         requiring $O(n^2 )$ integers of
                                         data allocated to compute. \\
  {\tt filename}          &string&mpqc& The filename used for
                                            restart and other files.\\
\hline
\end{tabular}
\caption{The {\tt mpqc} input section.}
\label{mpqcinput}
\end{table}

\subsection{SCF Input}
The \mpqc{} program uses the \libdmtscf{} library which requires its own
input.  This input
is searched for first in the {\tt scf}
section and then in the {\tt default} section.  The input parameters are given
in Tables~\ref{scfinputa} and \ref{scfinputb}.
Most of these parameters do not need to be
changed for runs on typical molecules.  However, it is important to
be familiar with a few of these options and these will be outlined
in more detail below.

Several options strongly affect the performance of the program.
The {\tt local\_P} should be {\tt yes} if the molecule is small
enough to hold all of the Fock matrices and density matrices on each
node.  This will boost performance by a factor of two to three.
The {\tt convergence} option specifies how tightly the wavefunction
will be converged and, hence, the number of SCF iterations
required to obtain the wavefunctions.
The {\tt integral\_storage} option gives the number if integrals
that can be saved on each node from iteration to iteration.  If
there is any free memory left on the nodes, it is useful to set
this option to be nonzero to eliminate redundant integral
computation.
The {\tt threshold} gives how large a contribution to a Fock
matrix element from an integral must be before it will be
considered.  The {\tt projected\_guess} option is used to
indicate that another wavefunction, computed in a different basis set,
is to be read in and projected onto the current basis set.  If
a basis set with polarization exponents is used this option is
very useful if a smaller basis set calculation happens to be
available.

Several options must be specified if a calculation is being done on
an open shell or a charged molecule or a molecule that has symmetry.
If the molecule
is a closed shell ${\rm C}_1$ symmetry neutral, then these options
need not be given.  If the use of symmetry is desired for molecules
with higher than ${\rm C}_1$ symmetry the {\tt symmetry}
option must be given with the point group of the molecule.  For all
non-${\rm C}_1$ molecules and charged molecules the {\tt docc} keyword
is needed.  The {\tt docc} keyword is an integer vector giving the
number of doubly occupied orbitals in each irreducible representation.  If the
molecule is open shell then the keyword {\tt opentype} must give the
type of open shell molecule.  The possibilities are outlined in
Table~\ref{opentypes}.  For open shell molecules, both the {\tt docc}
keyword and the {\tt socc} keyword must be given.  The {\tt socc} keyword
is an integer vector giving the number of singly occupied orbitals
in each irreducible representation.

The description of the molecule is also found in the {\tt scf} input
section.  The {\tt atoms} keyword is a vector of strings which give
the names of each of the symmetry unique atoms in the molecule.  Either
the full name or the atomic symbol may be used.  The program is not
sensitive to the case of the names.  The {\tt geometry} input is
given as a vector of vectors of reals.  Each vector of reals is the
$x$, $y$, and $z$ coordinate of the symmetry unique atoms, in the
same order as they are given in the {\tt atoms} keyword.  The
name of the basis set is given in the {\tt basis} keyword.  A basis
set of this name must be found for each of the atoms in the molecule
in the {\tt basis} section of the input.

If the user would like to have standard basis set information included as
an extension to the input file, this can be done with the {\tt basisdir}
and {\tt basisfiles} keywords.   The {\tt basisdir} keyword is a string
that gives the pathname to the basis set library.  The {\tt basisfiles}
keyword is a vector of strings to the names of basis files.  For each
of the {\tt basisfiles} the {\tt basisdir} string is preppended to
the filename and the file with the resulting name is logically appended to
the input file.  Basis set can also be specified directly in the
input file, this information has precedence over any basis set
information that is added with the {\tt basisdir} and {\tt basisfiles}
keywords.

Other options which mainly exist for debugging the code are the boolean
print flags {\tt scf\_info}, {\tt sym\_info}, {\tt irrep\_info}, and
{\tt centers\_info}.

\begin{table}
\centering
\begin{tabular}{|lccp{2.75in}|}
\hline
\multicolumn{1}{|c}{Keyword} & \multicolumn{1}{c}{Type} &
  \multicolumn{1}{c}{Default} & \multicolumn{1}{c|}{Description} \\
\hline
  {\tt restart}           &boolean& no & Not used.                           \\
  {\tt warmrestart}       &boolean& no & If true, begin with the old
                                         checkpoint file.\\
  {\tt projected\_guess}  &boolean& no & If true, project the vector in a 
                                         different basis set onto this basis
                                         set. \\
  {\tt local\_P}          &boolean& no & If true, the entire Fock and
                                         density matrices are stored on
                                         each node. \\
  {\tt convergence}       &integer&  7 & The accuracy to which the
                                         wavefunction is converged. \\
  {\tt maxiter}           &integer& 40 & The maximum number of SCF iterations.\\
  {\tt symmetry}          &string & c1 & The point group symmetry of the
                                         molecule. See Table~\ref{symmetry}.\\
  {\tt opentype}          &string &none& Specifies
                                         sorts of open shell wavefunctions.
                                         See Table~\ref{opentypes}. \\
  {\tt socc}              &vector &none& The number of singly
                                         occupied orbitals in each
                                         irreducible representation. \\
  {\tt docc}              &vector &see text& This gives the number of doubly
                                         occupied orbitals in each
                                         irreducible representation. \\
\hline
\end{tabular}
\caption{The most frequently used {\tt scf} input options.}
\label{scfinputa}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}
\centering
\begin{tabular}{|lccp{2.75in}|}
\hline
\multicolumn{1}{|c}{Keyword} & \multicolumn{1}{c}{Type} &
  \multicolumn{1}{c}{Default} & \multicolumn{1}{c|}{Description} \\
\hline
  {\tt chkt\_dir}         &string &see text& The directory to
                                         which checkpoint information
                                         is written. \\
  {\tt filename}          &string &libscfv3& This gives the file name
                                         for checkpoint files. \\
  {\tt angstrom}          &boolean& no & If true, the input geometry
                                         is converted from \AA ngstroms to
                                         Bohr. \\
  {\tt cheat}             &boolean& no & If true, change the threshold
                                         from iteration to iteration. \\
  {\tt eliminate}         &boolean&yes & If true, eliminate integral batches
                                         based on pmax. \\
  {\tt ckpt\_del}         &boolean&yes & If true, delete the checkpoint file
                                         when the calculation is done. \\
  {\tt print\_flg}        &integer& 0  & If nonzero, more stuff is printed. \\
  {\tt ckpt\_freq}        &integer& 5  & The number of SCF iterations between
                                         checkpoints. \\
 \parbox{1in}
  {\tt density\_reset{\rm -} \\ \_frequency}

          &integer& 10 & The number of SCF iterations
                                         between density matrix resets. \\
%  {\tt use\_symmetry}     &boolean& no & If true, do the calculation in the
%                                         SO basis.  This only works for
%                                         subgroups of ${\rm D}_{2h}$. \\
  {\tt diisstart}         &integer&  0 & The iteration at which the DIIS
                                         extrapolation method begins being
                                         used. \\
  {\tt threshold}         &integer& 12 & The integral cutoff threshold is
                                         set to $10^{-{\tt threshold}}$. \\
  {\tt integral\_storage} &integer&  0 & The number of integrals which
                                         will be stored on each node. \\
  {\tt diis}              &boolean&yes & If true, use DIIS. \\
  {\tt ndiis}             &integer&varies& The number of error matrices
                                         which will be stored. \\
  {\tt diisdamp}          &real&varies& A DIIS damping factor. \\
  {\tt levelshift}        &real&varies& The level shift parameter. \\
\hline
\end{tabular}
\caption{The less frequently used {\tt scf} input options.}
\label{scfinputb}
\end{table}

\begin{table}
\centering
\begin{tabular}{|lc|}
\hline
\multicolumn{1}{|c}{\tt symmetry} & \multicolumn{1}{c|}{Point Group} \\
\hline
  {\tt c1}   & $ {\rm C}_1 $ \\
  {\tt c2v}   & $ {\rm C}_{2v} $ \\
  {\tt others} & there are others \\
\hline
\end{tabular}
\caption{The {\tt scf:symmetry} options.}
\label{symmetry}
\end{table}

\begin{table}
\centering
\begin{tabular}{|lp{3.5in}|}
\hline
\multicolumn{1}{|c}{\tt opentype} & \multicolumn{1}{c|}{Wavefunction} \\
\hline
  {\tt none}     & Closed shell singlet wavefunctions. \\
  {\tt highspin} & High spin open shell cases. \\
  {\tt singlet}  & Open shell singlet. \\
  {\tt twocon}   & Two configuration SCF. \\
  {\tt special}  & The alpha and beta coefficients will be read from
                   the input. \\
\hline
\end{tabular}
\caption{The {\tt scf:opentype} options.}
\label{opentypes}
\end{table}

\subsection{Basis Set Input}
The \mpqc{} program uses the \libint{} library which requires input
for the basis set information.
This input is searched for only in the {\tt basis} section of the input.
For each atom in the molecule the keyword
{\it atom\_name}{\tt :}{\it basis} is searched for the basis information.
The full name of the atom is used for {\it atom\_name} even if the
atomic symbol is used in the input.  The {\it basis} string comes from
the value of the {\tt scf:basis} keyword.

Some basis set names are provided in the basis set libraries discussed
in Section~\ref{implementation}; these are listed in Table~\ref{basissets}.
Others can be provided directly in
the input.  Until the documentation becomes more fully developed,
look in the basis set library files to learn the basis set format.


\begin{table}
\centering
\begin{tabular}{|lll|}
\hline
\multicolumn{1}{|c}{\tt Name} & \multicolumn{1}{c}{Basis Set}
                              & \multicolumn{1}{c|}{Needed Files} \\
\hline
{\tt sto-3g}    & STO-3G       & v2g90.ipv2, v2g90supp.ipv2 \\
{\tt 3-21}      & 3-21G        & v2g90.ipv2, v2g90supp.ipv2 \\
{\tt 6-31}      & 6-31G        & v2g90.ipv2, v2g90supp.ipv2 \\
{\tt 6-311}     & 6-311G       & v2g90.ipv2, v2g90supp.ipv2 \\
{\tt 6-31s}     & 6-31G*       & v2g90.ipv2, v2g90supp.ipv2 \\
{\tt 6-311s}    & 6-311G*      & v2g90.ipv2, v2g90supp.ipv2 \\
{\tt 6-31ss}    & 6-31G**      & v2g90.ipv2, v2g90supp.ipv2 \\
{\tt 6-311ss}   & 6-311G**     & v2g90.ipv2, v2g90supp.ipv2 \\
\hline
\end{tabular}
\caption{Basis sets provided in the basis set libraries.}
\label{basissets}
\end{table}

\subsection{Force Library Input}
The \mpqc{} program uses the \libforce{} library which requires its own
input.  This input
is searched for first in the {\tt force}
section and then in the {\tt default} section.  The only input parameters
of importance are the integer {\tt threshold}, the boolean
{\tt local\_P}, and the boolean {\tt bounds}.
If a contribution to the gradient are less than
$10^{-{\tt threshold}}$ then it is ignored.  The default is 12.  If
{\tt local\_P} is {\tt yes}, then each node will store a copy of the
density matrix.  This makes the code run two to three times faster.
The default is {\tt no}.  If {\tt bounds} is {\tt yes}, which is the
default, then bounds checking is done.  This requires that certain
second derivative integrals be computed, which requires more storage
for holding the integral intermediates.  Bounds checking saves roughly
a factor of 3 in CPU time, but this figure will vary greatly with the
case.

\subsection{Geometry Optimization Input}
The \mpqc{} program uses the \libgeom{} library which requires its own
input.  This input
is searched for first in the {\tt geometry}
section and then in the {\tt default} section.
The \libgeom{} library first determine the method to be used by examining
the string valued {\tt method} keyword.  The default method is {\tt
Polak-Ribiere} and there is currently no reason to choose any other.
Each method has its own subsection within the {\tt geometry} section and
reads further input from there.  If the information sought can not be found
in the method's subsection, then the {\tt default} subsection is consulted.

The input for the Polak-Ribiere method is summarized in
Table~\ref{polakribiere}.  Options that may need adjusting are
{\tt restart}, {\tt convergence:rms}, {\tt convergence:max}, and
{\tt min\_f}.

\begin{table}
\centering
\begin{tabular}{|lccp{2.75in}|}
\hline
\multicolumn{1}{|c}{Keyword} & \multicolumn{1}{c}{Type} &
  \multicolumn{1}{c}{Default} & \multicolumn{1}{c|}{Description} \\
\hline
{\tt coordinates} & string & cartesian & Cannot be changed. \\
{\tt restartfile} & string &geom.restart& Name of file with restart
                                          information.\\
{\tt restart}     & boolean& yes & If the restart file exists, restart
                                   the calculation from that point. \\
{\tt convergence:rms} & real & $10^{-4} $& Maximum value of the root mean
                                          square gradient at convergence. \\
{\tt convergence:max} & real & $10^{-4} $& Maximum absolute value of any
                                          gradient at convergence. \\
%{\tt improvement:rms} & real & $10^{-1} $& Not currently used. \\
%{\tt improvement:max} & real & $10^{-1} $& Not currently used. \\
{\tt min\_f}           & real & $10^{-1} $& The minimum force constant used
                                           in line searches. \\
\hline
\end{tabular}
\caption{Options in the {\tt geometry:Polak-Ribiere} section.}
\label{polakribiere}
\end{table}

\section{Converting Input Formats}
The {\tt geomcnv} utility program can convert between the geometry
input formats\footnote
  {
  No attempt is made to convert any other part of the input, such as
  basis set or wavefunction specification.
  }
for various packages, including {\tt mpqc}.  The arguments is a list of file
names.  The first name is the input file from which the geometry is
obtained and the rest of the names are output file names.  The
format of each file is determined by the filename's extension.
Table~\ref{geomcnvtab} lists the allowed extensions.

A commonly needed conversion is from Gaussian format to the {\tt mpqc}
format.  This is accomplished by the following sequence of csh or bsh
commands:
\begin{verbatim}
% newzmat -ocon < he2.com > he2.con
% geomcnv he2.con mpqc.in
\end{verbatim}
The ``mpqc.in'' file now contains the geometry specification given
in zmat format in the he2.com file.  The rest of the input required
by {\tt mpqc} can either be added to the ``mpqc.in'' file or it can
be given another name and the real ``mpqc.in'' file can append
the file with the geometry as described in Section~\ref{mpqcsection}.

\begin{table}
\centering
\begin{tabular}{|lccp{2.75in}|}
\hline
\multicolumn{1}{|c}{Extension} & \multicolumn{1}{c}{Input} &
  \multicolumn{1}{c}{Output} & \multicolumn{1}{c|}{Description} \\
\hline
{\tt in}  &           &$\bullet$  & {\tt mpqc} input (uses Bohrs as units)\\
{\tt ipv2}&$\bullet$  &$\bullet$  & {\tt mpscf} input (uses Bohrs as units)\\
{\tt g90} &$\bullet$  &           & center number, atomic number, and
                                    $x$, $y$, $z$ in \AA ngstroms as they
                                    would appear in a G90 output file\\
{\tt xyz} &           &$\bullet$  & $x$, $y$, $z$ coordinates in \AA ngstroms\\
{\tt ang} &$\bullet$  &$\bullet$  & atomic number and $x$, $y$, $z$ in
                                    \AA ngstroms as they might appear
                                    in a G90 input file\\
{\tt pdb} &           &$\bullet$  & protein database format \\
{\tt con} &$\bullet$  &           & QUIPU \\
\hline
\end{tabular}
\caption{File formats recognized by {\tt geomcnv}.}
\label{geomcnvtab}
\end{table}

\section{Examples}
The follow input file will determine the STO-3G ${\rm H}_2{\rm O}$
optimum geometry:
\begin{verbatim}
force: (
  threshold=8
  )

default: (
  restart = no
  local_P = yes
  print_geometry = yes
  optimize_geometry = yes
  nopt = 10
  convergence = 12
  atoms = [o h h]
  geometry = [
    [0.0  0.0  0.0]
    [0.0  1.4  1.0]
    [0.0 -1.4  1.0]
    ]
  basis = sto-3g

 basisdir = "/usr/people2/cljanss/lib/"
 basisfiles = [ "v2g90.ipv2" "v2g90supp.ipv2" ]
 )
\end{verbatim}

\section{Implementation Notes}
\label{implementation}

\subsection{Silicon Graphics machines at Sandia, Livermore}
The basis sets are in ``\~{}cljanss/lib''.  Some useful databases
are ``v2g90.ipv2'' and ``v2g90supp.ipv2''.  The executables
are in ``\~{}cljanss/SGI/bin''.  The ``mpqcpvm'' executable uses
PVM and can be used to run calculations on multiple processors of
machines like ransgi and trantor or even on multiple machines using
the Ethernet to communicate.

If you don't want to communicate across the Ethernet, but are only
using multiple processors on a single SGI, then use the ``mpqcnode'' command
instead of ``mpqcpvm''.  The ``mpqcnode'' command uses shared memory with
synchronization via semaphores and is vastly more efficient.
The command is run by first setting the environmental variable NUMPROC
to the number of nodes which must be one of the integers 1, 2, 4, or 8
(ransgi only) and then running the
command ``\~{}cljanss/SGI/bin/mpqcnode''.
If your calculation dies unexpectedly,
then you must make sure that the shared memory and semaphores that
your job has allocated are released.  This is very important because
of the small system-wide IRIX imposed limits on how many of these things can be
around at once.  You can remove {\em all} of your shared memory and semaphore
resources with the command ``\~{}cljanss/bin/ipcclean''.  If you want
to be more selective, then consult the manual pages for the ``ipcs'' and
``ipcrm'' commands.

Finally, if you only want to run on one node, then use the command
``mpqcproc''.  This version has the least parallel processing overhead.

If you want to use PVM on trantor or ransgi to run {\tt mpqc} on
multiple processors with ``mpqcpvm'', then PVM needs some things set up.
The PVM
daemon must find the ``mpqcpvm'' program in ``\~{}/pvm/SGI'' (that's
your home, not mine), so I recommend that you set up some symbolic links.
After thats done, run the PVM daemon with the command
``\~{}cljanss/bin/runpvmd''.
Now {\tt mpqc} can be run by setting the environmental variable NUMPROC
to one of the integers 1, 2, 4, or 8 (ransgi only) and running the
command ``\~{}cljanss/SGI/bin/mpqcpvm''.  The NUMPROC variable
gives the number of processors to use to run ``mpqcpvm''.
If the mpqcpvm program
dies for some reason, then make sure you kill your pvmd process (do
a ``ps -ef $|$ grep {\it username} $|$ grep pvmd'' to find the process or
do a control-C in the window where you are running ``runpvmd'').
If you don't kill this process and restart it with ``runpvmd'', then
``mpqcpvm'' will produce unexpected results.

If you want to use PVM to distribute your job on machines across the
Ethernet, then you must directly use the ``pvmd'' command without using
``runpvmd''.  This command will take as an argument the name of a file
which contains a list of hosts which ``mpqcpvm''s are to be run on.
For each of these nodes you must specify in the hosts file the pathname
to the ``pvmd'' executable.  This will usually be ``\~{}cljanss/SGI/bin/pvmd''.
On each machine where you'll have ``mpqcpvm'' processes running, you'll
also need to have your ``\~{}/pvm/SGI'' directory set up.

When using PVM you will get messages like ``sendto: No buffer space available''.
This isn't any problem, except there may be a lot of these messages
in the output,
so you may want to redirect the standard error somewhere.

\subsection{RS6000 cluster at Lawerence, Livermore}
The code is available on machines ocfkms1 to ocfkms18 on the
FDDI connected cluster of RS6000's at LLNL.  The single processor
version of the code is ``\~{}cljansf/RS6000_3_1/mpqcproc'' and the
PVM version of the code is ``\~{}cljansf/RS6000_3_1/mpqcpvm''.  Use the
PVM daemon in ``/usr/local/bin/pvmd''.  You will need a symbolic link
from ``\~{}/pvm/RIOS/mpqcpvm'' to the
``\~{}cljansf/RS6000_3_1/mpqcpvm'' executable.  The ``runpvmd'' command,
described above, is not available on the LLNL cluster.

\subsection{nCUBE 2 machine at Sandia, Albuquerque}
You must have an account on ceratiidae (aka cs.sandia.gov) and
n1024fe1 or cubicle to run on the nCUBE 2.  The machines n1024fe1 and
cubicle are the front ends to the two 1024 nCUBE 2's, so you will
run the following commands on one of these machines.
Your path should include
``/usr/ncube/current/bin/sun4'' and ``/usr/ncube/current/bin''.
The environmental variable ``NCUBE\_PATH'' should be
``\~{}cljanss/NCUBE\_V3/bin''.
The {\tt mpqc} program can be run by typing ``xnc -d$dim$ mpqcnode'', where
$dim$ is the dimension of the hypercube.
If the job dies, your subcube will not be automatically deallocated,
so you must keep an eye on your job.  If it does die, you must explicitly
kill the process id appearing in the ``ncube -aup'' command.
Note that if your job completes as expected, your subcube will be properly
deallocated.
Several serious problems which predated June 17, 1992
have been worked around.  This unfortunately requires compiling most
of the code without optimization, but at least the most CPU intensive parts
can and have been optimized.  I've only tried up to 256 node subcubes with the
current set of codes.

Since the nCUBE doesn't have much memory, you might need to turn off
derivative bound computation if your basis set has d functions.  This
is done by putting {\tt force : bounds = no } in ``mpqc.in''.


\subsection{Intel IPSC/I860 machine at Sandia, Albuquerque}
You must have an account on ceratiidae (aka cs.sandia.gov) and
littlemo or math to run on the Intel.  The machine littlemo is
a 386 machine to which the IPSC connects.  The machine math is
a Sun 4 that accesses the IPSC over the network.  The remote host
software running on math is extremely unreliable, so I'll give
directions for using littlemo only.
Your path should contain ``/usr/bin''.
The {\tt mpqc} program is run
with ``cubeexec -td$dim$ /Net/home1/cljanss/I860/bin/mpqcnode'', where
$dim$ is the dimension of the hypercube.
Until I sort out some bugs
try using $dim < 5$ only.
Don't run in the background
because your job will die unexpectedly.

\section{Bugs}
Yes.

\end{document}

