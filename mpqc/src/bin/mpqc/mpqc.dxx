
/**@name The Massively Parallel Quantum Chemistry Program (MPQC)

The Massively Parallel Quantum Chemistry program (MPQC) computes
the properties of molecules, {\it ab initio}, on a wide variety
of computer architectures.

MPQC can compute closed shell and general restricted open-shell
Hartree-Fock energies and gradients, second order open-shell
perturbation theory (OPT2[2]) and Z-averaged perturbation theory
(ZAPT2) energies, and second order closed shell Moeller-Plesset
perturbation theory energies and gradients.  It also includes a
robust internal coordinate geometry optimizer that efficiently
optimizes molecules with many degrees of freedom.

MPQC is designed using object-oriented programming techniques and
implemented in the C++ programming language.  This design has propagated
even to the input of MPQC which is object-oriented as well.  The user
specifies a group of objects that the program creates when it starts.  MPQC
manipulates the objects to produce energies, gradients, geometries, and
properties.

MPQC runs on Unix compatible workstations (Intel/Linux, SGI/IRIX,
IBM RS/6000), symmetric multi-processors (Intel/Linux, SGI/IRIX), and
massively parallel computers (IBM SP2, Intel Paragon).


\begin{center}
{\bf License}
\end{center}

MPQC is open-source software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

\begin{center}
{\bf Warranty}
\end{center}

MPQC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.

*/

//@{

/**@name Compiling MPQC
 MPQC is distributed with the SC Toolkit.  MPQC will automatically
be compiled when SC is compiled.  See the compilation instructions
for SC for more information.
*/

/**@name Running MPQC

This chapter explains how to run mpqc in a variety of environments.

*/

//@{

/**@name Command Line Options

  MPQC recognizes the following command line options:

\begin{description}
\item[{\tt -f}] The name of the input file.  The default is
                     {\tt mpqc.in}.
\item[{\tt -messagegrp}] A ParsedKeyVal specification of a
                      MessageGrp object.
                      The default depends on how MPQC was compiled.
\item[{\tt -threadgrp}] A ParsedKeyVal specification of a
                      ThreadGrp object.
                      The default depends on how MPQC was compiled.
\item[{\tt -l}] Sets a limit on the number of basis functions.
                     The default is zero, which means an unlimited number
                     of basis functions.
\item[{\tt -W}] Sets the working directory.  The default is the
                      current directory.
\item[{\tt -c}] Check the input and exit.
\item[{\tt -v}] Print the version number.
\item[{\tt -w}] Print the warranty information (there is no
                      warranty).
\item[{\tt -d}] If a debugger object was given in the input
                      start the debugger running as soon as MPQC
                      is started.
\item[{\tt -h}] Print a list of options.
\end{description}

Some MPI environments do not pass the command line to slave programs, but
supply it when MPI_Init is called.  To make MPQC call MPI_Init on start-up,
instead of when an MPIMessageGrp is created, name the executable
mpqc-mpi.

*/

/**@name Environmental Variables

MPQC looks at four environmental variables to set up
communication and find library files.  Machine specific libraries
and utilities to run programs in parallel might look
at other environment variables as well.  The four that
apply on all platforms are:

\begin{description}
\item[{\tt SCLIBDIR}] The name of the library directory.  The default
                      is the directory in the source distribution.  See the
                      GaussianBasisSet class documentation and
                      look below for more information.
\item[{\tt MESSAGEGRP}] A ParsedKeyVal specification of a
                      MessageGrp object.
                      The default depends on how MPQC was compiled.  See
                      the MessageGrp class documentation for
                      more information.
\item[{\tt MEMORYGRP}] A ParsedKeyVal specification of a
                      MemoryGrp object.
                      The default depends on how MPQC was compiled and the
                      MessageGrp in use.
\item[{\tt THREADGRP}] A ParsedKeyVal specification of a
                      ThreadGrp object.
                      The default depends on how MPQC was compiled.
\end{description}

By default, MPQC tries to find basis set library files in
the source code distribution.  If the executable or source
code is moved, MPQC can be notified with the environmental
variable #SCLIBDIR#.  In the source code distribution
this directory is #SC/lib#.

For example if you need to run MPQC on a machine that doesn't
have the source code distribution in the same place as the
machine on which MPQC is compiled you must do the following
on the machine with the source code:

\begin{verbatim}
cd SC/lib
tar cvf ../sclib.tar basis molinfo.ipv2
\end{verbatim}

Then transfer #sclib.tar# to the machine that you want to run
MPQC on and do something like

\begin{verbatim}
mkdir ~/sclib
cd ~/sclib
tar xvf ../sclib.tar
setenv SCLIBDIR ~/sclib
\end{verbatim}

The setenv command is specific to the C-shell.  You will need to
do what is appropriate for your shell.

The other three keywords specify objects.  This is done by
giving a mini ParsedKeyVal input in a string.  The
object is anonymous, that is, no keyword is associated with it.
Here is an example:

\begin{verbatim}
setenv MESSAGEGRP "<ShmMessageGrp>:(n = 4)"
\end{verbatim}
*/

/**@name Running MPQC on a Shared Memory Multiprocessor

By default, MPQC will run on only one CPU.  To specify more, you can give a
ShmMessageGrp object on the command line.
The following would run mpqc in four processes:
\begin{verbatim}
mpqc -messagegrp "<ShmMessageGrp>:(n = 4)" -f input_file
\end{verbatim}

Alternately, the ShmMessageGrp object can
be given as an environmental variable:
\begin{verbatim}
setenv MESSAGEGRP "<ShmMessageGrp>:(n = 4)"
mpqc -f input_file
\end{verbatim}

If MPQC should unexpectedly die, shared memory segments and
semaphores will be left on the machine.  These should be promptly
cleaned up or other jobs may be prevented from running.  To
see if you have any of these resources allocated, use the
#ipcs# command.  The output will look something
like:

\begin{verbatim}
IPC status from /dev/kmem as of Wed Mar 13 14:42:18 1996
T     ID     KEY        MODE       OWNER    GROUP
Message Queues:
Shared Memory:
m 288800 0x00000000 --rw-------  cljanss     user
Semaphores:
s    390 0x00000000 --ra-------  cljanss     user
s    391 0x00000000 --ra-------  cljanss     user
\end{verbatim}

To remove the IPC resources used by #cljanss# in
the above example on IRIX, type:

\begin{verbatim}
ipcrm -m 288800
ipcrm -s 390
ipcrm -s 391
\end{verbatim}

And on Linux, type:

\begin{verbatim}
ipcrm shm 288800
ipcrm sem 390
ipcrm sem 391
\end{verbatim}

*/

/**@name Running MPQC on the Intel Paragon Running OSF

To run interactively type:
\begin{verbatim}
mpqc -sz n_node -f input_file
\end{verbatim}
*/

/**@name Running MPQC on the IBM SP2

The big SP2 installations have extensive information on how to run on an
SP2.  See, for example, the Maui SP2's WWW site,
\URL{http://www.mhpcc.edu/}.

*/

//@{

/**@name Running Interactively

When running interactively on an SP2,
the job is controlled by a group of environment variables.
Here are my current settings:
\begin{verbatim}
MP_CSS_INTERRUPT=YES
MP_HOSTFILE=NULL
MP_EUILIB=us
MP_EUIDEVICE=css0
MP_RMPOOL=0
MP_RESD=YES
MP_LABELIO=yes
MP_INFOLEVEL=1
MP_PGMMODEL=spmd
MP_PROCS=4
\end{verbatim}
The last variable, #MP_NPROCS#, sets the number
of processors that will be used.

The program can be run with the shell following /bin/sh script:

\begin{verbatim}
export MEMORYGRP="<MPLMemoryGrp>:(ack=yes)"
export MESSAGEGRP="<MPIMessageGrp>:(errors_return=1)"
/usr/bin/poe executable -f inputfile
\end{verbatim}

The #MEMORYGRP# variable must be set for MP2 calculations to work.
However, for as yet unknown reasons, MP2 using the memgrp algorithm
will occasionally give a wrong answer on the SP2.  This is not
reproducible.

*/

/**@name Using Load Leveler

A load leveler script is needed to submit a command to the batch queue.
This specifies the queue (called class) and constraints on memory the
number of processors, etc.  The following template is a good start for
MPQC:

\begin{verbatim}
#!/bin/sh
#@ environment = MessageGrp=MPIMessageGrp;MP_LANG=En_US;MP_LABELIO=YES;MP_INFOLEVEL=1;MP_PGMMODEL=spmd;MP_RESD=YES;MP_CSS_INTERRUPT=YES;MP_EUILIB=us
#@ input = /dev/null
#@ output = mpqc.out.$(Cluster).$(Process)
#@ error = mpqc.err.$(Cluster).$(Process)
#@ class = CLASS
#@ job_type = parallel
#@ min_processors = MINPROC
#@ max_processors = MAXPROC
#@ requirements =  (Adapter == "hps_user" && Memory >= MEMORY)
#@ notification = complete
#@ notify_user = EMAIL
#@ shell = /bin/sh
#@ cpu_limit = CPULIMIT
#@ queue
export MEMORYGRP="<MPLMemoryGrp>:(ack=yes)"
export MESSAGEGRP="<MPIMessageGrp>:(errors_return=1)"
/usr/bin/poe EXECUTABLE -f INPUTFILE
\end{verbatim}

To make the above useful, the italicized variables must be replaced.
The table below explains the meaning of the variables:

\begin{center}
\begin{tabular}{lp{2.5in}c}
  \multicolumn{1}{c}{Variable}
     & \multicolumn{1}{c}{Meaning}
     & \multicolumn{1}{c}{Example} \\
  CLASS & queue name & small_short \\
  MINPROC & minimum number of nodes & 4 \\
  MAXPROC & maximum number of nodes & 8 \\
  EMAIL & your email address & ynh@ude.edu \\
  CPULIMIT & maximum CPU time (hour:min:sec) & 1:0:0 \\
  MEMORY & maximum amount of memory (MBytes) & 64 \\
  EXECUTABLE & path to the executable & mpqc \\
  INPUTFILE & the input file name & mpqc.in \\
\end{tabular}
\end{center}

The modified script is submitted with the following command:

\begin{verbatim}
llsubmit scriptname
\end{verbatim}

*/

//@}

*/

//@}

/**@name MPQC Input

MPQC is an object-oriented program that directly allows the user to specify
objects that MPQC then manipulates to obtain energies, properties, etc.
Thus, the input may seem a bit complex to the beginner; however, most
calculations should be quite similar to the one of the examples given later
in this chapter.  The best way to get started is to use one of the example
input files and modify it to meet your needs.

MPQC starts off by creating a ParsedKeyVal object that parses the input
file specified on the command line.  It is the ParsedKeyVal object that
dictates the format of the input file.  It is basically a free format input
that associates keywords and logical groupings of keywords with values.
The values can be scalars, arrays, or objects.

The keywords recognized by MPQC begin with the mpqc prefix.
That is, they must be nested between an mpqc:( and a ).
Alternately, each keyword can be individually prefixed by mpqc:.
If they are not found with the mpqc prefix, the prefix
default will also be considered.  The primary keywords are given
below.  Some of the keywords specify objects, in which
case the object will require more KeyVal input.  These objects
are created from the input by using their KeyVal constructors,
which are documented in
several chapters that follow.

\begin{description}
\item[mole] This is the most important keyword for mpqc.
        It specifies the MolecularEnergy
        object.  This is an object that knows how to
        compute the energy of a molecule.  The specializations of
        MolecularEnergy that are most commonly used here are
        CLSCF, HSOSSCF, and MBPT2.
\item[opt] This keyword must be specified for optimizations.  It
        specifies an Optimize object.
        Usually, QNewtonOpt is best for finding minima and
        EFCOpt is best for transition states.
\item[freq] This keyword must be specified to compute frequencies.
        It specifies an MolecularFrequencies
        object.
\item[thread] This specifies an object of type
        ThreadGrp that can be used to advantage on shared-memory
        multiprocessor machines for certain types of calculations.  This
        keyword can be overridden by giving the ThreadGrp in the
        environment or command line.  See
        the section on running MPQC
        for more information.
\item[checkpoint] The value of this keyword is boolean.  If true,
        then optimizations will be checkpointed after each iteraction.  The
        default is to checkpoint.
\item[savestate] The value of this keyword is boolean.  If true,
        then the states of the optimizer and wavefunction objects will be
        saved after the calculation completes.  The default is to save
        state.
\item[restart] The value of this keyword is boolean.  If true
        mpqc will attempt to restart the calculation.  If the
        checkpoint file is not found, the calculation will continue as if
        the value were false. The default is true.
\item[restart_file] This gives the name of a file from which
        restart information is read.  If the file name ends in
        #.wfn# the mole object will be restored.  Otherwise,
        the opt object will be restored.  The default file name
        is formed by appending #.ckpt# to the input file name
        with the extension removed.
\item[do_energy] The value of this keyword is boolean.  If
        true a single point energy calculation will be done for the
        MolecularEnergy object given with the mole
        keyword.  The default is true.
\item[do_gradient] The value of this keyword is boolean.  If
        true a single point gradient calculation will be done for the
        MolecularEnergy object given with the mole
        keyword.  The default is false.
\item[optimize] The value of this keyword is boolean.  If
        true and the opt keyword was set to a valid value,
        then an optimization will be performed.  The default is true.
\item[write_pdb] The value of this keyword is boolean.  If
        true a PDB file with the molecular coordinates will be written.
\item[filename] The value of this keyword is a string that
        gives a name from which checkpoint and other filenames are
        constructed.  The default is the basename of the input file.
\item[print_timings] If this is true, timing information
        is printed at the end of the run.  The default is true.
\end{description}

There also some utility keywords that tell mpqc some technical
details about how to do the calculation:
\begin{description}
\item[debug] This optional keyword gives a Debugger
        object which can used to help find the problem
        if MPQC encounters a catastrophic error.
\item[matrixkit]
        This optional keyword gives a SCMatrixKit specialization
        which is used to produce matrices of the desired type.
        The default is a ReplSCMatrixKit which replicates
        matrices on all of the nodes.
\end{description}

*/

//@{

/**@name Sample Input Files

The easiest way to get started with mpqc is to start with
one of sample inputs that most nearly matches your problem.  All
of the samples inputs shown here can be found in the directory
#src/bin/mpqc/samples#.

*/

//@{

// samples/scf.in
/**@name SCF Energy

The following input will compute the SCF energy of water.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = C2V
  angstroms = yes
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
  )
)
\end{verbatim}

*/

// samples/mp2.in
/**@name MP2 Energy

The following input will compute the MP2 energy of water.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = C2V
  angstroms = yes
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole<MBPT2>: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
    % reference wavefunction
    reference<CLHF>: (
      molecule = $:molecule
      basis = $:basis
      memory = 16000000
    )
  )
)
\end{verbatim}

*/

// samples/scfopt.in
/**@name SCF Optimization

The following input will optimize the geometry of water using
the quasi-newton method.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = C2V
  angstroms = yes
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "6-31G*"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor<SymmMolecularCoor>: (
    molecule = $:molecule
    generator<IntCoorGen>: (
      molecule = $:molecule
    )
  )
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % optimizer object for the molecular geometry
  opt<QNewtonOpt>: (
    function = $..:mole
    update<BFGSUpdate>: ()
    convergence<MolEnergyConvergence>: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
\end{verbatim}

*/

// samples/scfoptguesshess.in
/**@name Optimization with a Computed Guess Hessian

The following input will optimize the geometry of water using
the quasi-newton method.  The guess hessian will be computed
at a lower level of theory.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = C2V
  angstroms = yes
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "6-31G*"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor<SymmMolecularCoor>: (
    molecule = $:molecule
    generator<IntCoorGen>: (
      molecule = $:molecule
    )
  )
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
    guess_hessian<FinDispMolecularHessian>: (
      molecule = $:molecule
      only_totally_symmetric = yes
      eliminate_cubic_terms = no
      checkpoint = no
      energy<CLHF>: (
        molecule = $:molecule
        memory = 16000000
        basis<GaussianBasisSet>: (
          name = "3-21G"
          molecule = $:molecule
        )
      )
    )
  )
  % optimizer object for the molecular geometry
  opt<QNewtonOpt>: (
    function = $..:mole
    update<BFGSUpdate>: ()
    convergence<MolEnergyConvergence>: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
\end{verbatim}

*/

// samples/newton.in
/**@name Optimization Using Newton's Method

The following input will optimize the geometry of water using the Newton's
method.  The hessian will be computed at each step in the optimization.
However, hessian recomputation is usually not worth the cost; try using the
computed hessian as a guess hessian for a quasi-Newton method before
resorting to a Newton optimization.

\begin{verbatim}
% Emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = c2v
  angstroms = yes
  { atoms geometry } = {
     O     [     0.00000000     0.00000000     0.36937294 ]
     H     [     0.78397590     0.00000000    -0.18468647 ]
     H     [    -0.78397590     0.00000000    -0.18468647 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "3-21G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  restart = no
  % molecular coordinates for optimization
  coor<SymmMolecularCoor>: (
    molecule = $:molecule
    generator<IntCoorGen>: (
      molecule = $:molecule
    )
  )
  do_energy = no
  do_gradient = no
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
    coor = $..:coor
    guess_wavefunction<CLHF>: (
      molecule = $:molecule
      total_charge = 0
      basis<GaussianBasisSet>: (
        molecule = $:molecule
        name = "STO-3G"
      )
      memory = 16000000
    )
    hessian<FinDispMolecularHessian>: (
      only_totally_symmetric = yes
      eliminate_cubic_terms = no
      checkpoint = no
    )
  )
  optimize = yes
  % optimizer object for the molecular geometry
  opt<NewtonOpt>: (
    print_hessian = yes
    max_iterations = 20
    function = $..:mole
    convergence<MolEnergyConvergence>: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
\end{verbatim}

*/

// samples/scffreq.in
/**@name SCF Frequencies

The following input will compute SCF frequencies by finite
displacements.  A thermodynamic analysis will also be
performed.  If optimization input is also provided, then the
optimization will be run first, then the frequencies.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = C1
  { atoms geometry } = {
    O     [  0.0000000000    0.0000000000    0.8072934188 ]
    H     [  1.4325589285    0.0000000000   -0.3941980761 ]
    H     [ -1.4325589285    0.0000000000   -0.3941980761 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
  )
% vibrational frequency input
  freq<MolecularFrequencies>: (
    molecule = $:molecule
  )
)
\end{verbatim}

*/

// samples/mancoor.in
/**@name Giving Coordinates and a Guess Hessian

The following example shows several features that are really independent.
The variable coordinates are explicitly given, rather than generated
automatically.  This is especially useful when a guess hessian is to be
provided, as it is here.  This hessian, as given by the user, is not
complete and the QNewtonOpt object will fill in the missing
values using a guess the hessian provided by the MolecularEnergy
object.  Also, fixed coordinates are given in this sample input.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = C1
  { atoms geometry } = {
      H    [ 0.088    2.006    1.438 ]
      O    [ 0.123    3.193    0.000 ]
      H    [ 0.088    2.006   -1.438 ]
      O    [ 4.502    5.955   -0.000 ]
      H    [ 2.917    4.963   -0.000 ]
      H    [ 3.812    7.691   -0.000 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % molecular coordinates for optimization
  coor<SymmMolecularCoor>: (
    molecule = $:molecule
    generator<IntCoorGen>: (
      molecule = $:molecule
      extra_bonds = [ 2 5 ]
    )
    % use these instead of generated coordinates
    variable<SetIntCoor>: [
      <StreSimpleCo>:( atoms = [ 2 5 ] )
      <BendSimpleCo>:( atoms = [ 2 5 4 ] )
      <OutSimpleCo>: ( atoms = [ 5 2 1 3 ] )
      <SumIntCoor>: (
        coor: [
          <StreSimpleCo>:( atoms = [ 1 2 ] )
          <StreSimpleCo>:( atoms = [ 2 3 ] )
          ]
        coef = [ 1.0 1.0 ]
        )
      <SumIntCoor>: (
        coor: [
          <StreSimpleCo>:( atoms = [ 4 5 ] )
          <StreSimpleCo>:( atoms = [ 4 6 ] )
          ]
        coef = [ 1.0 1.0 ]
        )
      <BendSimpleCo>:( atoms = [ 1 2 3 ] )
      <BendSimpleCo>:( atoms = [ 5 4 6 ] )
    ]
    % these are fixed by symmetry anyway,
    fixed<SetIntCoor>: [
      <SumIntCoor>: (
        coor: [
          <StreSimpleCo>:( atoms = [ 1 2 ] )
          <StreSimpleCo>:( atoms = [ 2 3 ] )
          ]
        coef = [ 1.0 -1.0 ]
        )
      <SumIntCoor>: (
        coor: [
          <StreSimpleCo>:( atoms = [ 4 5 ] )
          <StreSimpleCo>:( atoms = [ 4 6 ] )
          ]
        coef = [ 1.0 -1.0 ]
        )
      <TorsSimpleCo>:( atoms = [ 2 5 4 6] )
      <OutSimpleCo>:( atoms = [ 3 2 6 4 ] )
      <OutSimpleCo>:( atoms = [ 1 2 6 4 ] )
    ]
  )
  % optimizer object for the molecular geometry
  opt<QNewtonOpt>: (
    function = $..:mole
    update<BFGSUpdate>: ()
    convergence<MolEnergyConvergence>: (
      cartesian = yes
      energy = $..:..:mole
    )
    % give a partial guess hessian in internal coordinates
    % the missing elements will be filled in automatically
    hessian = [
        [  0.0109261670 ]
        [ -0.0004214845    0.0102746106  ]
        [ -0.0008600592    0.0030051330    0.0043149957 ]
        [  0.0             0.0             0.0          ]
        [  0.0             0.0             0.0          ]
        [  0.0             0.0             0.0          ]
        [  0.0             0.0             0.0          ]
     ]
  )
)
\end{verbatim}

*/

// samples/hbondopt.in
/**@name Optimization with a Hydrogen Bond

The automatic internal coordinate generator will fail if it cannot find
enough redundant internal coordinates.  In this case, the internal
coordinate generator must be explicitly created in the input and given
extra connectivity information, as is shown below.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = C1
  { atoms geometry } = {
      H    [ 0.088    2.006    1.438 ]
      O    [ 0.123    3.193    0.000 ]
      H    [ 0.088    2.006   -1.438 ]
      O    [ 4.502    5.955   -0.000 ]
      H    [ 2.917    4.963   -0.000 ]
      H    [ 3.812    7.691   -0.000 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % molecular coordinates for optimization
  coor<SymmMolecularCoor>: (
    molecule = $:molecule
    % give an internal coordinate generator that knows about the
    % hydrogen bond between atoms 2 and 5
    generator<IntCoorGen>: (
      molecule = $:molecule
      extra_bonds = [ 2 5 ]
    )
  )
  % optimizer object for the molecular geometry
  opt<QNewtonOpt>: (
    function = $..:mole
    update<BFGSUpdate>: ()
    convergence<MolEnergyConvergence>: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
\end{verbatim}

*/

// samples/fixed.in
/**@name Fixed Coordinate Optimization

 This example shows how to selectively fix internal coordinates in an
optimization.  Any number of linearly independent coordinates can be given.
These coordinates must remain linearly independent throughout the
optimization, a condition that might not hold since the coordinates can be
nonlinear.

 By default, the initial fixed coordinates' values are taken from the
cartesian geometry given by the Molecule object; however, the
molecule will be displaced to the internal coordinate values given with the
fixed internal coordinates if have_fixed_values keyword is set to
true, as shown in this example.  In this case, the initial cartesian
geometry should be reasonably close to the desired initial geometry and all
of the variable coordinates will be frozen to their original values during
the initial displacement.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = CS
  { atoms geometry } = {
    H [  3.04 -0.69 -1.59 ]
    H [  3.04 -0.69  1.59 ]
    N [  2.09 -0.48 -0.00 ]
    C [ -0.58 -0.15  0.00 ]
    H [ -1.17  1.82  0.00 ]
    H [ -1.41 -1.04 -1.64 ]
    H [ -1.41 -1.04  1.64 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "4-31G*"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor<SymmMolecularCoor>: (
    molecule = $:molecule
    generator<IntCoorGen>: (
      molecule = $:molecule
    )
    have_fixed_values = yes
    fixed<SetIntCoor>: [
      <OutSimpleCo>: ( value = -0.1
                       label = "N-inversion"
                       atoms = [4 3 2 1] )
      ]
  )
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % optimizer object for the molecular geometry
  opt<QNewtonOpt>: (
    max_iterations = 20
    function = $..:mole
    update<BFGSUpdate>: ()
    convergence<MolEnergyConvergence>: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
\end{verbatim}

*/

// samples/ts.in
/**@name Transition State Optimization

This example shows a transition state optimization of the N-inversion in
$\mathrm{CH}_3\mathrm{NH}_2$ using mode following.  The initial geometry
was obtained by doing a few fixed coordinate optimizations along the
inversion coordinate.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = CS
  { atoms geometry } = {
    H [  3.045436 -0.697438 -1.596748 ]
    H [  3.045436 -0.697438  1.596748 ]
    N [  2.098157 -0.482779 -0.000000 ]
    C [ -0.582616 -0.151798  0.000000 ]
    H [ -1.171620  1.822306  0.000000 ]
    H [ -1.417337 -1.042238 -1.647529 ]
    H [ -1.417337 -1.042238  1.647529 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "4-31G*"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor<SymmMolecularCoor>: (
    molecule = $:molecule
    generator<IntCoorGen>: (
      molecule = $:molecule
    )
    followed<OutSimpleCo> = [ "N-inversion" 4 3 2 1 ]
  )  
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % optimizer object for the molecular geometry
  opt<EFCOpt>: (
    transition_state = yes
    mode_following = yes
    max_iterations = 20
    function = $..:mole
    update<PowellUpdate>: ()
    convergence<MolEnergyConvergence>: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
\end{verbatim}

*/

// samples/tsguesshess.in
/**@name Transition State Optimization with a Computed Guess Hessian

This example shows a transition state optimization of the N-inversion in
$\mathrm{CH}_3\mathrm{NH}_2$ using mode following.  The initial geometry
was obtained by doing a few fixed coordinate optimizations along the
inversion coordinate.  An approximate guess hessian will be computed, which
makes the optimiziation converge much faster in this case.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = CS
  { atoms geometry } = {
    H [  3.045436 -0.697438 -1.596748 ]
    H [  3.045436 -0.697438  1.596748 ]
    N [  2.098157 -0.482779 -0.000000 ]
    C [ -0.582616 -0.151798  0.000000 ]
    H [ -1.171620  1.822306  0.000000 ]
    H [ -1.417337 -1.042238 -1.647529 ]
    H [ -1.417337 -1.042238  1.647529 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "4-31G*"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor<SymmMolecularCoor>: (
    molecule = $:molecule
    generator<IntCoorGen>: (
      molecule = $:molecule
    )
    followed<OutSimpleCo> = [ "N-inversion" 4 3 2 1 ]
  )  
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
    guess_hessian<FinDispMolecularHessian>: (
      molecule = $:molecule
      only_totally_symmetric = yes
      eliminate_cubic_terms = no
      checkpoint = no
      energy<CLHF>: (
        molecule = $:molecule
        memory = 16000000
        basis<GaussianBasisSet>: (
          name = "3-21G"
          molecule = $:molecule
        )
      )
    )
  )
  % optimizer object for the molecular geometry
  opt<EFCOpt>: (
    transition_state = yes
    mode_following = yes
    max_iterations = 20
    function = $..:mole
    update<PowellUpdate>: ()
    convergence<MolEnergyConvergence>: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
\end{verbatim}

*/

//@}

//@}

/**@name Validating MPQC

 After you compile MPQC, you should run it through the validation suite.
You should also run the validation suite if you upgrade your operating
system software, since this could change shared libraries that are linking
with MPQC and could affect the results.

 The validation suite is in #src/bin/mpqc/validate#.  The
input files are divided into several categories:
\begin{description}
  \item[#h2o#] These are simple tests that exercise many of MPQC's
        features.

  \item[#h2omp2#] Tests that further exercise MP2.

  \item[#mbpt#] These tests exercise MP2 as well as the open-shell
        perturbation theory methods.  The various available
        algorithms are tested as well.

  \item[#ckpt#] Tests the checkpoint and restart capabilities.

  \item[#symm1#] Tests of point group symmetry.

  \item[#symm2#] More point group symmetry tests.  These use basis
        sets with higher angular momentum than #symm1#.

  \item[#basis1#] A variety of basis sets are tested for first row
        atoms along with hydrogen and helium.

  \item[#basis2#] Basis sets test for second row atoms.

\end{description}

  To generate the input files change into the #src/bin/mpqc/validate#
subdirectory of your object directory (where you compiled MPQC) and type
#make inputs#.  This will create a #run# subdirectory containing
MPQC input files ending with the #.in# suffix.  Files ending with a
#.qci# suffix will also be placed in the #run# directory.
These contain a description of the calculation that is used by the utility
program that checks the results of the validation suite.

  Next you need to run the calculations.  You might want to start with the
#h2o# input files first since they shouldn't take too long to run.
For the #ckpt# calculations you should run the calculations
alphabetically by input file name.  This ensures that the checkpoint files
will be created before they are needed.

  While the test calculations are running you can begin monitoring the
results by typing #make checkrun# in the #src/bin/mpqc/validate#
directory.  This will first do some consistency checks between pairs of
files selected from the #ckpt#, #mbpt#, #symm1#, and
#symm2# groups of calculations (see below for a discussion of the
output for comparison of two files).  Then each file is individually
checked.  An #ok# is printed next the test name, if it looks like the
calculation made it to the end.  A #missing# means the output file
could not be found.  A #failed# means that the output file has
problems (or the calculation may still be running).

  Next you will want to see if your compiled MPQC produces the same answer
as ours.  Note that we don't say ``the correct answer'' here, because our
reference validation suite has not been verified relative to a independent
code, except for a few spot checks.  If you find that MPQC doesn't produce
the same answer as another quantum chemistry program that you trust, then
please promptly notify us and send all the details.  The reference
validation suite is distributed separately from MPQC.  Obtain it (hopefully
it is available where you got the source code) and untar it in the
#src/bin/mpqc/validate# subdirectory of your MPQC object code
directory.  This will create the #ref# subdirectory.  Now you can
type #make check# and outputs in the #ref# and #run#
directories will be pairwise compared.

  When files are pairwise compared first the status (#ok#,
#missing#, or #failed#) for each file is printed.  If both
statuses are #ok# then an #E:# is printed followed by the number
of digits to which the energies agree.  If they agree to all digits
#99# is printed.  If a gradient was computed, then #Grad:# is
printed followed by the number of digits to which the gradients in least
agreement agree.  Likewise if frequencies were computed.

  If two numbers do not agree to the expected accuracy, then an asterisk,
#*#, is printed after the number of digits in agreement.  There are a
few cases where a #*# might appear, but the calculations do agree.
These situations arise where there are degenerate orbitals and the
quantities compared depend on the choice of the orbitals.  This will never
happen for physical observables, like the energy and its derivatives;
however, it can happen for the quantities printed with the labels
#|S2|1#, #|S2|i#, #S2L#, and #D1L# in the #symm1#
test series.


  Finally, you can do a detailed comparison of the contents of the
#ref# and #run# subdirectories by typing #make diff#.

*/

//@}
