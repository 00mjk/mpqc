
/**@name The MPQC Program

The Massively Parallel Quantum Chemistry program (MPQC) computes
the properties of molecules, {\it ab initio}, on a wide variety
of computer architectures.

MPQC can compute closed shell and general restricted open-shell
Hartree-Fock energies and gradients, second order open-shell
perturbation theory (OPT2[2]) and Z-averaged perturbation theory
(ZAPT2) energies, and second order closed shell Moeller-Plesset
perturbation theory energies and gradients.  It also includes
methods for optimizing molecules in either Cartesian or internal
coordinates.

MPQC is designed using object-oriented programming techniques and
implemented in the C++ programming language.  This design has propagated
even to the input of MPQC which is object-oriented as well.  The user
specifies a group of objects that the program creates when it starts.  MPQC
manipulates the objects to produce energies, gradients, geometries, and
properties.

   @memo The Massively Parallel Quantum Chemistry Program.

*/

//@{

/**@name Compiling MPQC
 MPQC is distributed with the SC Toolkit.  MPQC will automatically
be compiled when SC is compiled.  See the \Ref{Compiling}
for more information.
*/

/**@name Running MPQC

This chapter explains how to run mpqc in a variety of environments.

*/

//@{

/**@name Command Line Options

  MPQC can be given options following by an optional simple input file
name.  The following command line options are recognized:

\begin{description}
\item[{\tt -o}] Gives the name of the output file.  The default is the
                console.
\item[{\tt -i}] Convert a simple input file to an object oriented input file
                and write the result to the ouput.  No calculations are done.
\item[{\tt -f}] The name of an object-oriented input file.  The default is
                {\tt mpqc.in}.  This cannot be used if a simple file is
                specified.
\item[{\tt -messagegrp}] A \Ref{ParsedKeyVal} specification of a
                      \Ref{MessageGrp} object.
                      The default depends on how MPQC was compiled.
\item[{\tt -memorygrp}] A \Ref{ParsedKeyVal} specification of a
                      \Ref{MemoryGrp} object.
                      The default depends on how MPQC was compiled.
\item[{\tt -threadgrp}] A \Ref{ParsedKeyVal} specification of a
                      \Ref{ThreadGrp} object.
                      The default depends on how MPQC was compiled.
\item[{\tt -l}] Sets a limit on the number of basis functions.
                     The default is zero, which means an unlimited number
                     of basis functions.
\item[{\tt -W}] Sets the working directory.  The default is the
                      current directory.
\item[{\tt -c}] Check the input and exit.
\item[{\tt -v}] Print the version number.
\item[{\tt -w}] Print the warranty information (there is no
                      warranty).
\item[{\tt -d}] If a debugger object was given in the input
                      start the debugger running as soon as MPQC
                      is started.
\item[{\tt -h}] Print a list of options.
\end{description}

Some MPI environments do not pass the command line to slave programs, but
supply it when MPI_Init is called.  To make MPQC call MPI_Init on start-up,
instead of when an MPIMessageGrp is created, name the executable
mpqc-mpi.

*/

/**@name Environmental Variables

MPQC looks at four environmental variables to set up
communication and find library files.  Machine specific libraries
and utilities to run programs in parallel might look
at other environment variables as well.  The four that
apply on all platforms are:

\begin{description}
\item[{\tt SCLIBDIR}] The name of the library directory.  The default
                      is the directory in the source distribution.  See the
                      \Ref{GaussianBasisSet} documentation and
                      look below for more information.
\item[{\tt MESSAGEGRP}] A \Ref{ParsedKeyVal} specification of a
                      \Ref{MessageGrp} object.
                      The default depends on how MPQC was compiled.  See
                      the \Ref{MessageGrp} class documentation for
                      more information.
\item[{\tt MEMORYGRP}] A \Ref{ParsedKeyVal} specification of a
                      \Ref{MemoryGrp} object.
                      The default depends on how MPQC was compiled and the
                      \Ref{MessageGrp} in use.
\item[{\tt THREADGRP}] A \Ref{ParsedKeyVal} specification of a
                      \Ref{ThreadGrp} object.
                      The default depends on how MPQC was compiled.
\end{description}

By default, MPQC tries to find library files first in the installation
directory and then in the source code distribution directory.  If the
library files cannot be found, MPQC must be notified of the new location
with the environmental variable #SCLIBDIR#.  In the source code
distribution this directory is #SC/lib#.

For example if you need to run MPQC on a machine that doesn't
have the source code distribution in the same place as it was
located on the machine on which MPQC is compiled you must do the
following on the machine with the source code:

\begin{verbatim}
cd SC/lib
tar cvf ../sclib.tar basis atominfo.kv
\end{verbatim}

Then transfer #sclib.tar# to the machine that you want to run
MPQC on and do something like

\begin{verbatim}
mkdir ~/sclib
cd ~/sclib
tar xvf ../sclib.tar
setenv SCLIBDIR ~/sclib
\end{verbatim}

The setenv command is specific to the C-shell.  You will need to
do what is appropriate for your shell.

The other three keywords specify objects.  This is done by
giving a mini \Ref{ParsedKeyVal} input in a string.  The
object is anonymous, that is, no keyword is associated with it.
Here is an example:

\begin{verbatim}
setenv MESSAGEGRP "<ShmMessageGrp>:(n = 4)"
\end{verbatim}
*/

/**@name Shared Memory Multiprocessor with SysV IPC

By default, MPQC will run on only one CPU.  To specify more, you can give a
\Ref{ShmMessageGrp} object on the command line.
The following would run mpqc in four processes:
\begin{verbatim}
mpqc -messagegrp "<ShmMessageGrp>:(n = 4)" -f input_file
\end{verbatim}

Alternately, the ShmMessageGrp object can
be given as an environmental variable:
\begin{verbatim}
setenv MESSAGEGRP "<ShmMessageGrp>:(n = 4)"
mpqc -f input_file
\end{verbatim}

If MPQC should unexpectedly die, shared memory segments and
semaphores will be left on the machine.  These should be promptly
cleaned up or other jobs may be prevented from running.  To
see if you have any of these resources allocated, use the
#ipcs# command.  The output will look something
like:

\begin{verbatim}
IPC status from /dev/kmem as of Wed Mar 13 14:42:18 1996
T     ID     KEY        MODE       OWNER    GROUP
Message Queues:
Shared Memory:
m 288800 0x00000000 --rw-------  cljanss     user
Semaphores:
s    390 0x00000000 --ra-------  cljanss     user
s    391 0x00000000 --ra-------  cljanss     user
\end{verbatim}

To remove the IPC resources used by #cljanss# in
the above example on IRIX, type:

\begin{verbatim}
ipcrm -m 288800
ipcrm -s 390
ipcrm -s 391
\end{verbatim}

And on Linux, type:

\begin{verbatim}
ipcrm shm 288800
ipcrm sem 390
ipcrm sem 391
\end{verbatim}

*/

/**@name Shared Memory Multiprocessor with POSIX Threads

By default, MPQC will run with only one thread.  To specify more,
you can give a \Ref{PthreadThreadGrp} object on the command line.
MPQC is not parallelized to as large an extent with threads as it
is with the more conventional distributed memory model, so you
might not get the best performance using this technique.

The following would run mpqc in four threads:

\begin{verbatim}
mpqc -threadgrp "<PthreadThreadGrp>:(num_threads = 4)" -f input_file
\end{verbatim}

Alternately, the PthreadThreadGrp object can
be given as an environmental variable:
\begin{verbatim}
setenv THREADGRP "<PthreadThreadGrp>:(n = 4)"
mpqc -f input_file
\end{verbatim}

*/

/**@name Shared or Distributed Memory Multiprocessor with MPI

A \Ref{MPIMessageGrp} object is used to run using MPI.  The
number of nodes used is determined by the MPI run-time and is not
specified as input data to \Ref{MPIMessageGrp}.

\begin{verbatim}
mpqc -messagegrp "<MPIMessageGrp>:()" -f input_file
\end{verbatim}

Alternately, the MPIMessageGrp object can
be given as an environmental variable:
\begin{verbatim}
setenv MESSAGEGRP "<MPIMessageGrp>:()"
mpqc -f input_file
\end{verbatim}

*/

/**@name Special Notes for MP2 Gradients

The MP2 gradient algorithm uses \Ref{MemoryGrp} object to access
distributed shared memory.  The \Ref{MTMPIMemoryGrp} class is the
most efficient and reliable implementation of \Ref{MemoryGrp}.
It requires a multi-thread aware MPI implementation, which are
still not common (the IBM SP does support it).  To run MP2
gradients on a machine with POSIX threads and an multi-thread
aware MPI, use:

\begin{verbatim}
mpqc -messagegrp "<MPIMessageGrp>:()" \
     -threadgrp "<PthreadThreadGrp>:()" \
     -memorygrp "<MTMPIMemoryGrp>:()" \
     -f input_file
\end{verbatim}

or

\begin{verbatim}
setenv MESSAGEGRP "<MPIMessageGrp>:()"
setenv THREADGRP "<PthreadThreadGrp>:()"
setenv MEMORYGRP "<MTMPIMemoryGrp>:()"
mpqc -f input_file
\end{verbatim}

*/

//@}

/**@name MPQC Input

   MPQC supports two input formats.  The primary input is
an object oriented format which gives users access to all
of MPQC's options.  The second format allows access to a
subset of MPQC's capabilities, but is more intuitive and
easier to learn.  New users are advised to start with the
simplified format.  MPQC can be used to convert the simplified
format to the full object-oriented format.

*/

//@{

/**@name Simple Input

The simple input format consists of keywords followed by a ":" followed by
a value.  The values might be modified by options found in parenthesis.
For example, the following input performs an optimization of water using
density functional theory with the B3LYP exchange-correlation functional:

\begin{verbatim}
% B3LYP optimization of water
optimize: yes
method: KS (xc = B3LYP)
basis: 3-21G*
molecule:
    O    0.172   0.000   0.000
    H    0.745   0.000   0.754
    H    0.745   0.000  -0.754
\end{verbatim}

Comments begin with a #%# and continue to the end of the line.
Basis set names containing a special characters, such as a space
or parentheses, can be quoted inside a pair of double quotes.
The accepted keywords are:

\begin{description}
\item[molecule] Gives the atoms types and coordinates.  The following options
  can be used
  \begin{description}
     \item[bohr] The coordinates are given in Bohr.
     \item[angstrom]  The coordinates are given in Angstroms.
     \item[charge]  This option can be given after an "element x y z"
                  quadruple.  This will override the charge on the
                  atom.  For example, #(charge = 0)# can be given
                  for the ghost atoms in a counterpoise correction
                  calculation.
  \end{description}
\item[multiplicity] Gives the multiplicity of the molecule.  The
  default is #1#.
\item[optimize] If #yes#, then an optimization will be performed.  The
  default is #no#.  The following options can be given.
  \begin{description}
     \item[cartesian] Use Cartesian coordinates.
     \item[internal] Use internal coordinates.
     \item[redundant] Use redundant internal coordinates.
  \end{description}
\item[gradient] If #yes#, then a gradient calculation will be performed.  The
  default is #no#.
\item[frequencies] If #yes#, then the frequencies will be obtained.
  The default is #no#.
\item[charge] Specificies the charge on the molecule.  The default is #0#.
\item[method] Specifices the method.  There is no default and the possible
   values are:
   \begin{description}
     \item[HF] Hartree-Fock.  Unrestricted HF is used if #multiplicity# > 1
     \item[RHF] Restricted Hartree-Fock.
     \item[UHF] Unestricted Hartree-Fock.
     \item[KS] Kohn-Sham.  Unrestricted KS is used if #multiplicity# > 1
     \item[RKS] Restricted Kohn-Sham.
     \item[UKS] Unestricted Kohn-Sham.
     \item[MP2] Second order Moeller-Plesset perturbation theory.
                Only available for #multiplicity# = 1.
     \item[ZAPT2]  Z-averaged perturbation theory.
                Only available for #multiplicity# > 1.  No gradient,
                optimization, or frequencies are possible.
   \end{description}
   The following options are valid with the #KS#, #RKS#, and #UKS# methods:
   \begin{description}
     \item[grid] Specifies the grid to be used for numerical integrations.
        The following values can be given:
        \begin{description}
           \item[xcoarse]
           \item[coarse]
           \item[medium]
           \item[fine]
           \item[xfine]
        \end{description}
     \item[xc] Specifies the exchange-correlation functional.  There is
        no default.  See the \Ref{StdDenFunctional} class documentation
        for the possible values.
   \end{description}
\item[basis]  Specifies the basis set.  There is no default.
      See the \Ref{GaussianBasisSet} class documentation for the
      available basis sets.
\item[restart]  Set to #yes# to restart an optimization.  The default is #no#.
\item[checkpoint]  Set to #no# to not save checkpoint files during an
   optimization.  The default is #yes#.
\item[symmetry] Specifices the Schoenflies symbol of the point group of the
   molecule.  The default is #auto#, which will cause to program to find
   the highest order Abelian subgroup of the molecule.
\item[docc] Gives the number of doubly occupied orbitals in each each
   irreducible representation in a parenthesized list.  The symmetry must
   be specified and not be #auto#.  The method must be restricted.
\item[socc] Gives the number of single occupied orbitals in each each
   irreducible representation in a parenthesized list.  The symmetry must
   be specified and not be #auto#.  The method must be restricted.
\item[alpha] Gives the number of alpha occupied orbitals in each each
   irreducible representation in a parenthesized list.  The symmetry must
   be specified and not be #auto#.  The method must be unrestricted.
\item[beta] Gives the number of beta occupied orbitals in each each
   irreducible representation in a parenthesized list.  The symmetry must
   be specified and not be #auto#.  The method must be unrestricted.
\item[frozen_docc]  Gives the number of frozen core orbitals.  Can be each
   a single integer or a parenthesized list giving the frozen core
   orbitals in each irreducible representation.
\item[frozen_uocc]  Gives the number of frozen virtual orbitals.  Can be each
   a single integer or a parenthesized list giving the frozen virtual
   orbitals in each irreducible representation.
\end{description}

*/

/**@name Object-Oriented Input

MPQC is an object-oriented program that directly allows the user to
specify objects that MPQC then manipulates to obtain energies,
properties, etc.  This makes the input very flexible, but very complex.
However, most calculations should be quite similar to the one of the
examples given later in this chapter.  The best way to get started is to
use one of the example input files and modify it to meet your needs.

MPQC starts off by creating a \Ref{ParsedKeyVal} object that parses the
input file specified on the command line.  The format of the input file
is documented in \Ref{The KeyVal Library}.  It is basically a free
format input that associates keywords and logical groupings of keywords
with values.  The values can be scalars, arrays, or objects.

The keywords recognized by MPQC begin with the mpqc prefix.
That is, they must be nested between an #mpqc:(# and a #)#.
Alternately, each keyword can be individually prefixed by #mpqc:#.
If they are not found with the mpqc prefix, the prefix
#default# will also be considered.  The primary keywords are given
below.  Some of the keywords specify objects, in which
case the object will require more \Ref{ParsedKeyVal} input.  These objects
are created from the input by using their \Ref{ParsedKeyVal} constructors.
These constructors are documented with the source code documentation
for the class.

\begin{description}
\item[mole] This is the most important keyword for mpqc.
        It specifies the \Ref{MolecularEnergy}
        object.  This is an object that knows how to
        compute the energy of a molecule.  The specializations of
        \Ref{MolecularEnergy} that are most commonly used here are
        \Ref{CLHF}, \Ref{HSOSHF}, and \Ref{MBPT2}.
\item[opt] This keyword must be specified for optimizations.  It
        specifies an \Ref{Optimize} object.
        Usually, \Ref{QNewtonOpt} is best for finding minima and
        \Ref{EFCOpt} is best for transition states.
\item[freq] This keyword must be specified to compute frequencies.
        It specifies an \Ref{MolecularFrequencies}
        object.
\item[thread] This specifies an object of type
        \Ref{ThreadGrp} that can be used to advantage on shared-memory
        multiprocessor machines for certain types of calculations.  This
        keyword can be overridden by giving the \Ref{ThreadGrp} in the
        environment or command line.  See
        the section on running MPQC
        for more information.
\item[checkpoint] The value of this keyword is boolean.  If true,
        then optimizations will be checkpointed after each iteraction.  The
        default is to checkpoint.
\item[savestate] The value of this keyword is boolean.  If true,
        then the states of the optimizer and wavefunction objects will be
        saved after the calculation completes.  The default is to save
        state.
\item[restart] The value of this keyword is boolean.  If true
        mpqc will attempt to restart the calculation.  If the
        checkpoint file is not found, the calculation will continue as if
        the value were false. The default is true.
\item[restart_file] This gives the name of a file from which
        restart information is read.  If the file name ends in
        #.wfn# the mole object will be restored.  Otherwise,
        the opt object will be restored.  The default file name
        is formed by appending #.ckpt# to the input file name
        with the extension removed.
\item[do_energy] The value of this keyword is boolean.  If
        true a single point energy calculation will be done for the
        \Ref{MolecularEnergy} object given with the mole
        keyword.  The default is true.
\item[do_gradient] The value of this keyword is boolean.  If
        true a single point gradient calculation will be done for the
        \Ref{MolecularEnergy} object given with the mole
        keyword.  The default is false.
\item[optimize] The value of this keyword is boolean.  If
        true and the opt keyword was set to a valid value,
        then an optimization will be performed.  The default is true.
\item[write_pdb] The value of this keyword is boolean.  If
        true a PDB file with the molecular coordinates will be written.
\item[filename] The value of this keyword is a string that
        gives a name from which checkpoint and other filenames are
        constructed.  The default is the basename of the input file.
\item[print_timings] If this is true, timing information
        is printed at the end of the run.  The default is true.
\end{description}

There also some utility keywords that tell mpqc some technical
details about how to do the calculation:
\begin{description}
\item[debug] This optional keyword gives a \Ref{Debugger}
        object which can used to help find the problem
        if MPQC encounters a catastrophic error.
\item[matrixkit]
        This optional keyword gives a \Ref{SCMatrixKit} specialization
        which is used to produce matrices of the desired type.
        The default is a \Ref{ReplSCMatrixKit} which replicates
        matrices on all of the nodes.  Other choices are not thoroughly
        tested.
\end{description}

*/

//@{

/**@name A Walk-Through of an Object-Oriented Input File

This example input does a Hartree-Fock calculation on water.
Following is the entire input, followed by a breakdown with
descriptions.

\begin{verbatim}
% This input does a Hartree-Fock calculation on water.
molecule<Molecule>: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
basis<GaussianBasisSet>: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
  )
)
\end{verbatim}

We start with a descriptive comment.  Comments begin
with a #%#.  Everything beginning with the #%# to the end
of the line are ignored.

\begin{verbatim}
% This input does a Hartree-Fock calculation on water.
\end{verbatim}

Now lets set up a \Ref{Molecule} object.  The name of the object comes
first, it is #molecule#.  Then in angle brackets comes the type of the
molecule, which is the class \Ref{Molecule}.  The completed keyword is
followed by a #:# and then several pieces of input grouped between a pair
of matching parentheses.  These parentheses contain the information that
will be given to \Ref{Molecule} \Ref{KeyVal} constructor.

\begin{verbatim}
molecule<Molecule>: (
\end{verbatim}

The point group of the molecule is needed.  This is done by
assigning #symmetry# to a case insensitive Schoenflies symbol
that is used to initialize a \Ref{PointGroup} object.

\begin{verbatim}
  symmetry = C2V
\end{verbatim}

The default unit for the Cartesian coordinates is Bohr.  You can
specify other units by assigned #unit# to a string that will be
used to initialize a \Ref{Units} object.

\begin{verbatim}
  unit = angstrom
\end{verbatim}

Finally, the atoms and coordinates are given.  This can be given in the
shorthand table syntax shown below.  The headings of the table are the
keywords between the first pair of brackets.  These are followed by an #=#
and another pair of brackets that contain the data.  The first datum is
assigned to the first element of the array that corresponds to the first
heading, #atom#.  The second datum is assigned to the first element of the
array associated with the second heading, #geometry#, and so on.  Here the
second datum is actually a vector: the x, y and z coordinates of the first
atom.

\begin{verbatim}
  { atoms                       geometry                   } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
\end{verbatim}

Next, a basis set object is given.

\begin{verbatim}
basis<GaussianBasisSet>: (
  name = "STO-3G"
  molecule = $:molecule
)
\end{verbatim}

Now we will give the main body of input.  All the subsequent
keywords will be grouped in the #mpqc# section of the input
(that is, each keyword will be prefixed with #mpqc:#).

\begin{verbatim}
mpqc: (
\end{verbatim}

Next we create specify the #mole# keyword which specifies a specialization
of the \Ref{MolecularEnergy} class.  In this case we will do a Hartree-Fock
calculation.  That is done with an object of type \Ref{CLHF}.  The keywords
that \Ref{CLHF} accepts are given with the documentation for the \Ref{CLHF}
class, usually in the description of the #const RefKeyVal&# constructor for
the class.  Also with the \Ref{CLHF} documentation is a list of parent
classes.  Each of the parent classes may also have input.  This input is
included with the rest of the input for the child class.

\begin{verbatim}
  mole<CLHF>: (
\end{verbatim}

The next line specifies the molecule to be used.  There are two things to
note, first that this is actually a reference to complete molecule
specification elsewhere in the input file.  The #$# indicates that this is
a reference and the keyword following the #$# is the actual location of the
molecule.  The #:# in front of the keyword means that the keyword is not
relative to the current location in the input, but rather relative to the
root of the tree of keywords.  Thus, this line grabs the molecule that was
specified above.  The molecule object could have been placed here, but
frequently it is necessary that several objects refer to the exact same
object and this can only be done using references.

The second point is that if you look at the documentation for \Ref{CLHF},
you will see that it doesn't read #molecule# keyword.  However, if you
follow its parent classes up to \Ref{MolecularEnergy}, you'll find that
#molecule# is indeed read.

\begin{verbatim}
    molecule = $:molecule
\end{verbatim}

Just as we gave #molecule#, specify the basis set with the #basis# keyword
as follows:

\begin{verbatim}
    basis = $:basis
\end{verbatim}

Now we close off the parentheses we opened above and we are finished.

\begin{verbatim}
  )
)
\end{verbatim}

  */

/**@name Sample Object-Oriented Input Files

The easiest way to get started with mpqc is to start with
one of sample inputs that most nearly matches your problem.  All
of the samples inputs shown here can be found in the directory
#src/bin/mpqc/samples#.

*/

//@{

// samples/scf.in
/**@name Hartree-Fock Energy

The following input will compute the Hartree-Fock energy of water.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
  )
)
\end{verbatim}

*/

// samples/mp2.in
/**@name MP2 Energy

The following input will compute the MP2 energy of water.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole<MBPT2>: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
    % reference wavefunction
    reference<CLHF>: (
      molecule = $:molecule
      basis = $:basis
      memory = 16000000
    )
  )
)
\end{verbatim}

*/

// samples/scfopt.in
/**@name Hartree-Fock Optimization

The following input will optimize the geometry of water using
the quasi-newton method.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "6-31G*"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor<SymmMolecularCoor>: (
    molecule = $:molecule
    generator<IntCoorGen>: (
      molecule = $:molecule
    )
  )
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % optimizer object for the molecular geometry
  opt<QNewtonOpt>: (
    function = $..:mole
    update<BFGSUpdate>: ()
    convergence<MolEnergyConvergence>: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
\end{verbatim}

*/

// samples/scfoptguesshess.in
/**@name Optimization with a Computed Guess Hessian

The following input will optimize the geometry of water using
the quasi-newton method.  The guess hessian will be computed
at a lower level of theory.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [     0.00000000     0.00000000     0.37000000 ]
    H     [     0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "6-31G*"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor<SymmMolecularCoor>: (
    molecule = $:molecule
    generator<IntCoorGen>: (
      molecule = $:molecule
    )
  )
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
    guess_hessian<FinDispMolecularHessian>: (
      molecule = $:molecule
      only_totally_symmetric = yes
      eliminate_cubic_terms = no
      checkpoint = no
      energy<CLHF>: (
        molecule = $:molecule
        memory = 16000000
        basis<GaussianBasisSet>: (
          name = "3-21G"
          molecule = $:molecule
        )
      )
    )
  )
  % optimizer object for the molecular geometry
  opt<QNewtonOpt>: (
    function = $..:mole
    update<BFGSUpdate>: ()
    convergence<MolEnergyConvergence>: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
\end{verbatim}

*/

// samples/newton.in
/**@name Optimization Using Newton's Method

The following input will optimize the geometry of water using the Newton's
method.  The hessian will be computed at each step in the optimization.
However, hessian recomputation is usually not worth the cost; try using the
computed hessian as a guess hessian for a quasi-Newton method before
resorting to a Newton optimization.

\begin{verbatim}
% Emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = c2v
  unit = angstrom
  { atoms geometry } = {
     O     [     0.00000000     0.00000000     0.36937294 ]
     H     [     0.78397590     0.00000000    -0.18468647 ]
     H     [    -0.78397590     0.00000000    -0.18468647 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "3-21G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  restart = no
  % molecular coordinates for optimization
  coor<SymmMolecularCoor>: (
    molecule = $:molecule
    generator<IntCoorGen>: (
      molecule = $:molecule
    )
  )
  do_energy = no
  do_gradient = no
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
    coor = $..:coor
    guess_wavefunction<CLHF>: (
      molecule = $:molecule
      total_charge = 0
      basis<GaussianBasisSet>: (
        molecule = $:molecule
        name = "STO-3G"
      )
      memory = 16000000
    )
    hessian<FinDispMolecularHessian>: (
      only_totally_symmetric = yes
      eliminate_cubic_terms = no
      checkpoint = no
    )
  )
  optimize = yes
  % optimizer object for the molecular geometry
  opt<NewtonOpt>: (
    print_hessian = yes
    max_iterations = 20
    function = $..:mole
    convergence<MolEnergyConvergence>: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
\end{verbatim}

*/

// samples/scffreq.in
/**@name Hartree-Fock Frequencies

The following input will compute Hartree-Fock frequencies by finite
displacements.  A thermodynamic analysis will also be
performed.  If optimization input is also provided, then the
optimization will be run first, then the frequencies.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = C1
  { atoms geometry } = {
    O     [  0.0000000000    0.0000000000    0.8072934188 ]
    H     [  1.4325589285    0.0000000000   -0.3941980761 ]
    H     [ -1.4325589285    0.0000000000   -0.3941980761 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
  )
% vibrational frequency input
  freq<MolecularFrequencies>: (
    molecule = $:molecule
  )
)
\end{verbatim}

*/

// samples/mancoor.in
/**@name Giving Coordinates and a Guess Hessian

The following example shows several features that are really independent.
The variable coordinates are explicitly given, rather than generated
automatically.  This is especially useful when a guess hessian is to be
provided, as it is here.  This hessian, as given by the user, is not
complete and the QNewtonOpt object will fill in the missing
values using a guess the hessian provided by the MolecularEnergy
object.  Also, fixed coordinates are given in this sample input.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = C1
  { atoms geometry } = {
      H    [ 0.088    2.006    1.438 ]
      O    [ 0.123    3.193    0.000 ]
      H    [ 0.088    2.006   -1.438 ]
      O    [ 4.502    5.955   -0.000 ]
      H    [ 2.917    4.963   -0.000 ]
      H    [ 3.812    7.691   -0.000 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % molecular coordinates for optimization
  coor<SymmMolecularCoor>: (
    molecule = $:molecule
    generator<IntCoorGen>: (
      molecule = $:molecule
      extra_bonds = [ 2 5 ]
    )
    % use these instead of generated coordinates
    variable<SetIntCoor>: [
      <StreSimpleCo>:( atoms = [ 2 5 ] )
      <BendSimpleCo>:( atoms = [ 2 5 4 ] )
      <OutSimpleCo>: ( atoms = [ 5 2 1 3 ] )
      <SumIntCoor>: (
        coor: [
          <StreSimpleCo>:( atoms = [ 1 2 ] )
          <StreSimpleCo>:( atoms = [ 2 3 ] )
          ]
        coef = [ 1.0 1.0 ]
        )
      <SumIntCoor>: (
        coor: [
          <StreSimpleCo>:( atoms = [ 4 5 ] )
          <StreSimpleCo>:( atoms = [ 4 6 ] )
          ]
        coef = [ 1.0 1.0 ]
        )
      <BendSimpleCo>:( atoms = [ 1 2 3 ] )
      <BendSimpleCo>:( atoms = [ 5 4 6 ] )
    ]
    % these are fixed by symmetry anyway,
    fixed<SetIntCoor>: [
      <SumIntCoor>: (
        coor: [
          <StreSimpleCo>:( atoms = [ 1 2 ] )
          <StreSimpleCo>:( atoms = [ 2 3 ] )
          ]
        coef = [ 1.0 -1.0 ]
        )
      <SumIntCoor>: (
        coor: [
          <StreSimpleCo>:( atoms = [ 4 5 ] )
          <StreSimpleCo>:( atoms = [ 4 6 ] )
          ]
        coef = [ 1.0 -1.0 ]
        )
      <TorsSimpleCo>:( atoms = [ 2 5 4 6] )
      <OutSimpleCo>:( atoms = [ 3 2 6 4 ] )
      <OutSimpleCo>:( atoms = [ 1 2 6 4 ] )
    ]
  )
  % optimizer object for the molecular geometry
  opt<QNewtonOpt>: (
    function = $..:mole
    update<BFGSUpdate>: ()
    convergence<MolEnergyConvergence>: (
      cartesian = yes
      energy = $..:..:mole
    )
    % give a partial guess hessian in internal coordinates
    % the missing elements will be filled in automatically
    hessian = [
        [  0.0109261670 ]
        [ -0.0004214845    0.0102746106  ]
        [ -0.0008600592    0.0030051330    0.0043149957 ]
        [  0.0             0.0             0.0          ]
        [  0.0             0.0             0.0          ]
        [  0.0             0.0             0.0          ]
        [  0.0             0.0             0.0          ]
     ]
  )
)
\end{verbatim}

*/

// samples/hbondopt.in
/**@name Optimization with a Hydrogen Bond

The automatic internal coordinate generator will fail if it cannot find
enough redundant internal coordinates.  In this case, the internal
coordinate generator must be explicitly created in the input and given
extra connectivity information, as is shown below.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = C1
  { atoms geometry } = {
      H    [ 0.088    2.006    1.438 ]
      O    [ 0.123    3.193    0.000 ]
      H    [ 0.088    2.006   -1.438 ]
      O    [ 4.502    5.955   -0.000 ]
      H    [ 2.917    4.963   -0.000 ]
      H    [ 3.812    7.691   -0.000 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "STO-3G"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % molecular coordinates for optimization
  coor<SymmMolecularCoor>: (
    molecule = $:molecule
    % give an internal coordinate generator that knows about the
    % hydrogen bond between atoms 2 and 5
    generator<IntCoorGen>: (
      molecule = $:molecule
      extra_bonds = [ 2 5 ]
    )
  )
  % optimizer object for the molecular geometry
  opt<QNewtonOpt>: (
    function = $..:mole
    update<BFGSUpdate>: ()
    convergence<MolEnergyConvergence>: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
\end{verbatim}

*/

// samples/fixed.in
/**@name Fixed Coordinate Optimization

 This example shows how to selectively fix internal coordinates in an
optimization.  Any number of linearly independent coordinates can be given.
These coordinates must remain linearly independent throughout the
optimization, a condition that might not hold since the coordinates can be
nonlinear.

 By default, the initial fixed coordinates' values are taken from the
cartesian geometry given by the Molecule object; however, the
molecule will be displaced to the internal coordinate values given with the
fixed internal coordinates if have_fixed_values keyword is set to
true, as shown in this example.  In this case, the initial cartesian
geometry should be reasonably close to the desired initial geometry and all
of the variable coordinates will be frozen to their original values during
the initial displacement.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = CS
  { atoms geometry } = {
    H [  3.04 -0.69 -1.59 ]
    H [  3.04 -0.69  1.59 ]
    N [  2.09 -0.48 -0.00 ]
    C [ -0.58 -0.15  0.00 ]
    H [ -1.17  1.82  0.00 ]
    H [ -1.41 -1.04 -1.64 ]
    H [ -1.41 -1.04  1.64 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "4-31G*"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor<SymmMolecularCoor>: (
    molecule = $:molecule
    generator<IntCoorGen>: (
      molecule = $:molecule
    )
    have_fixed_values = yes
    fixed<SetIntCoor>: [
      <OutSimpleCo>: ( value = -0.1
                       label = "N-inversion"
                       atoms = [4 3 2 1] )
      ]
  )
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % optimizer object for the molecular geometry
  opt<QNewtonOpt>: (
    max_iterations = 20
    function = $..:mole
    update<BFGSUpdate>: ()
    convergence<MolEnergyConvergence>: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
\end{verbatim}

*/

// samples/ts.in
/**@name Transition State Optimization

This example shows a transition state optimization of the N-inversion in
$\mathrm{CH}_3\mathrm{NH}_2$ using mode following.  The initial geometry
was obtained by doing a few fixed coordinate optimizations along the
inversion coordinate.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = CS
  { atoms geometry } = {
    H [  3.045436 -0.697438 -1.596748 ]
    H [  3.045436 -0.697438  1.596748 ]
    N [  2.098157 -0.482779 -0.000000 ]
    C [ -0.582616 -0.151798  0.000000 ]
    H [ -1.171620  1.822306  0.000000 ]
    H [ -1.417337 -1.042238 -1.647529 ]
    H [ -1.417337 -1.042238  1.647529 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "4-31G*"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor<SymmMolecularCoor>: (
    molecule = $:molecule
    generator<IntCoorGen>: (
      molecule = $:molecule
    )
    followed<OutSimpleCo> = [ "N-inversion" 4 3 2 1 ]
  )  
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % optimizer object for the molecular geometry
  opt<EFCOpt>: (
    transition_state = yes
    mode_following = yes
    max_iterations = 20
    function = $..:mole
    update<PowellUpdate>: ()
    convergence<MolEnergyConvergence>: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
\end{verbatim}

*/

// samples/tsguesshess.in
/**@name Transition State Optimization with a Computed Guess Hessian

This example shows a transition state optimization of the N-inversion in
$\mathrm{CH}_3\mathrm{NH}_2$ using mode following.  The initial geometry
was obtained by doing a few fixed coordinate optimizations along the
inversion coordinate.  An approximate guess hessian will be computed, which
makes the optimiziation converge much faster in this case.

\begin{verbatim}
% emacs should use -*- KeyVal -*- mode
% molecule specification
molecule<Molecule>: (
  symmetry = CS
  { atoms geometry } = {
    H [  3.045436 -0.697438 -1.596748 ]
    H [  3.045436 -0.697438  1.596748 ]
    N [  2.098157 -0.482779 -0.000000 ]
    C [ -0.582616 -0.151798  0.000000 ]
    H [ -1.171620  1.822306  0.000000 ]
    H [ -1.417337 -1.042238 -1.647529 ]
    H [ -1.417337 -1.042238  1.647529 ]
  }
)
% basis set specification
basis<GaussianBasisSet>: (
  name = "4-31G*"
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor<SymmMolecularCoor>: (
    molecule = $:molecule
    generator<IntCoorGen>: (
      molecule = $:molecule
    )
    followed<OutSimpleCo> = [ "N-inversion" 4 3 2 1 ]
  )  
  % method for computing the molecule's energy
  mole<CLHF>: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
    guess_hessian<FinDispMolecularHessian>: (
      molecule = $:molecule
      only_totally_symmetric = yes
      eliminate_cubic_terms = no
      checkpoint = no
      energy<CLHF>: (
        molecule = $:molecule
        memory = 16000000
        basis<GaussianBasisSet>: (
          name = "3-21G"
          molecule = $:molecule
        )
      )
    )
  )
  % optimizer object for the molecular geometry
  opt<EFCOpt>: (
    transition_state = yes
    mode_following = yes
    max_iterations = 20
    function = $..:mole
    update<PowellUpdate>: ()
    convergence<MolEnergyConvergence>: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)
\end{verbatim}

*/

//@}

//@}

//@}

/**@name Validating MPQC

 After you compile MPQC, you should run it through the validation suite.
You should also run the validation suite if you upgrade your operating
system software, since this could change shared libraries that are linking
with MPQC and could affect the results.

 The validation suite is in #src/bin/mpqc/validate#.  The
input files are divided into several categories:
\begin{description}
  \item[#h2o#] These are simple tests that exercise many of MPQC's
        features.

  \item[#h2omp2#] Tests that further exercise MP2.

  \item[#mbpt#] These tests exercise MP2 as well as the open-shell
        perturbation theory methods.  The various available
        algorithms are tested as well.

  \item[#ckpt#] Tests the checkpoint and restart capabilities.

  \item[#symm1#] Tests of point group symmetry.

  \item[#symm2#] More point group symmetry tests.  These use basis
        sets with higher angular momentum than #symm1#.

  \item[#symm3#] Tests automatic point group determination.

  \item[#basis1#] A variety of basis sets are tested for first row
        atoms along with hydrogen and helium.

  \item[#basis2#] Basis sets test for second row atoms.

  \item[#methods#] Tests the self-consistent-field methods and the
                  density functional theory functionals.

\end{description}

  To generate the input files change into the #src/bin/mpqc/validate#
subdirectory of your object directory (where you compiled MPQC) and type
#make inputs#.  This will create a #run# subdirectory containing
MPQC input files ending with the #.in# suffix.  Files ending with a
#.qci# suffix will also be placed in the #run# directory.
These contain a description of the calculation that is used by the utility
program that checks the results of the validation suite.

  Next you need to run the calculations.  You might want to start with the
#h2o# input files first since they shouldn't take too long to run.
For the #ckpt# calculations you should run the calculations
alphabetically by input file name.  This ensures that the checkpoint files
will be created before they are needed.

  While the test calculations are running you can begin monitoring the
results by typing #make checkrun# in the #src/bin/mpqc/validate#
directory.  This will first do some consistency checks between pairs of
files selected from the #ckpt#, #mbpt#, #symm1#, and
#symm2# groups of calculations (see below for a discussion of the
output for comparison of two files).  Then each file is individually
checked.  An #ok# is printed next the test name, if it looks like the
calculation made it to the end.  A #missing# means the output file
could not be found.  A #failed# means that the output file has
problems (or the calculation may still be running).

  Next you will want to see if your compiled MPQC produces the same answer
as ours.  Note that we don't say ``the correct answer'' here, because our
reference validation suite has not been verified relative to a independent
code, except for a few spot checks.  If you find that MPQC doesn't produce
the same answer as another quantum chemistry program that you trust, then
please promptly notify us and send all the details.  The reference
validation suite is distributed separately from MPQC.  Obtain it (hopefully
it is available where you got the source code) and untar it in the
#src/bin/mpqc/validate# subdirectory of your MPQC object code
directory.  This will create the #ref# subdirectory.  Now you can
type #make check# and outputs in the #ref# and #run#
directories will be pairwise compared.

  When files are pairwise compared first the status (#ok#,
#missing#, or #failed#) for each file is printed.  If both
statuses are #ok# then an #E:# is printed followed by the number
of digits to which the energies agree.  If they agree to all digits
#99# is printed.  If a gradient was computed, then #Grad:# is
printed followed by the number of digits to which the gradients in least
agreement agree.  Likewise if frequencies were computed.

  If two numbers do not agree to the expected accuracy, then an asterisk,
#*#, is printed after the number of digits in agreement.  There are a
few cases where a #*# might appear, but the calculations do agree.
These situations arise where there are degenerate orbitals and the
quantities compared depend on the choice of the orbitals.  This will never
happen for physical observables, like the energy and its derivatives;
however, it can happen for the quantities printed with the labels
#|S2|1#, #|S2|i#, #S2L#, and #D1L# in the #symm1#
test series.


  Finally, you can do a detailed comparison of the contents of the
#ref# and #run# subdirectories by typing #make diff#.

*/

/**@name License

MPQC is open-source software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

*/

/**@name Warranty

MPQC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.

*/

//@}
